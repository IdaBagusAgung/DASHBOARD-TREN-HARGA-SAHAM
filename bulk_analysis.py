import dash
from dash import html, dcc, dash_table, callback_context, dash_table
from dash.dependencies import Input, Output, State, MATCH, ALL
import pandas as pd
import numpy as np
import plotly.graph_objs as go
from plotly.subplots import make_subplots  # Add this import
import traceback
import json
import pymysql
from datetime import datetime, timedelta
import io
from io import StringIO
import base64
import re
import traceback
# from dash_table.Format import Format

from Save_analysis_data import save_bulk_analysis_to_database



# Import shared functions from main file to reuse logic
# from get_backtesting_data import get_backtesting_data
from Ticker import AVAILABLE_TICKERS
# from chart_generators import TechnicalAnalysisCharts, create_technical_chart


app = dash.Dash(__name__)

def fetch_ticker_data(ticker, start_date, end_date):
    """
    Fetch data for a specific ticker from the database with improved error handling
    """
    print(f"Attempting to fetch data for {ticker} from {start_date} to {end_date}")
    
    connection = None
    cursor = None
    
    try:
        # Establish connection
        connection = pymysql.connect(
            host="localhost",
            user="root",
            password="",
            database="harga_saham",
            cursorclass=pymysql.cursors.DictCursor
        )
        cursor = connection.cursor()
        
        # Try the exact table name - data_saham_max_all_mei
        sql = f"SELECT * FROM data_saham_max_all_mei WHERE Ticker = '{ticker}'"
        print(f"Executing SQL: {sql}")
        
        # Check if query was successful
        row_count = cursor.execute(sql)
        print(f"Query returned {row_count} rows")
        
        result = cursor.fetchone()
        
        if not result:
            print(f"No data found for ticker {ticker} in data_saham_max_all_mei table")
            return pd.DataFrame()
        
        # Print column names for debugging
        print(f"Available columns in result: {list(result.keys())}")
        
        # Check for 'Data' column
        if 'Data' not in result:
            print(f"ERROR: 'Data' column not found in result. Available columns: {list(result.keys())}")
            # Try to use the result directly if no Data column
            return pd.DataFrame([result])
        
        # Try to parse JSON data with robust error handling
        try:
            # Check if Data is already a dict/list
            if isinstance(result['Data'], (dict, list)):
                json_data = result['Data']
                print(f"Data already in dictionary/list format")
            else:
                # Parse as JSON string
                json_data = json.loads(result['Data'])
                print(f"Successfully parsed JSON data")
            
            # Check if JSON data is a single object or array
            if isinstance(json_data, dict):
                print("JSON data is a single object, converting to list")
                df = pd.DataFrame([json_data])
            else:
                print(f"JSON array contains {len(json_data)} records")
                df = pd.DataFrame(json_data)
                
        except json.JSONDecodeError as e:
            print(f"JSON parsing error: {str(e)}")
            print(f"First 100 chars of data: {str(result['Data'])[:100]}...")
            
            # Try to fix common JSON issues
            try:
                # Sometimes data is stored with single quotes instead of double quotes
                fixed_json = result['Data'].replace("'", "\"")
                json_data = json.loads(fixed_json)
                print("Successfully parsed JSON after fixing quotes")
                df = pd.DataFrame(json_data if isinstance(json_data, list) else [json_data])
            except Exception as e2:
                print(f"Failed to fix JSON: {str(e2)}")
                return pd.DataFrame()
        
        print(f"DataFrame created with {len(df)} rows and columns: {df.columns.tolist()}")
        
        # Handle date column - try different column names
        date_col_options = ['Date', 'Datetime', 'date', 'datetime', 'Date_Time', 'time']
        date_col = next((col for col in date_col_options if col in df.columns), None)
        
        if not date_col:
            print(f"WARNING: No date column found in {df.columns.tolist()}")
            return df
        
        print(f"Using '{date_col}' as date column")
        
        # Convert to datetime and standardize column name
        df[date_col] = pd.to_datetime(df[date_col])
        if date_col != 'Datetime':
            df.rename(columns={date_col: 'Datetime'}, inplace=True)
        
        # Filter by date range
        df_filtered = df[(df['Datetime'] >= start_date) & (df['Datetime'] <= end_date)]
        print(f"Filtered data: {len(df_filtered)} rows (from original {len(df)} rows)")
        
        # Check if any data remains after filtering
        if df_filtered.empty:
            print(f"WARNING: No data remains after date filtering.")
            print(f"Available date range: {df['Datetime'].min()} to {df['Datetime'].max()}")
            return pd.DataFrame()
        
        # Add ticker column if not present
        if 'Ticker' not in df_filtered.columns:
            df_filtered['Ticker'] = ticker
        
        # Ensure necessary columns exist
        required_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
        missing_cols = [col for col in required_cols if col not in df_filtered.columns]
        if missing_cols:
            print(f"WARNING: Missing required columns: {missing_cols}")
        
        return df_filtered
    
    except Exception as e:
        print(f"Error fetching data for {ticker}: {str(e)}")
        traceback.print_exc()
        return pd.DataFrame()
    finally:
        # Ensure connection and cursor are properly closed
        if cursor:
            cursor.close()
        if connection:
            connection.close()


def render_bulk_analysis_page():
    """
    Renders the bulk analysis page layout with improved backtesting result visualization
    """
    return html.Div([
        # Navigation bar
        html.Nav(
            html.Div([
                # Left section with back link and title
                html.Div([
                    html.A(
                        "â† Back",
                        href="/",
                        className="inline-block px-4 py-2 text-white hover:bg-blue-700 rounded-lg mr-4 transition-colors"
                    ),
                    html.H1("Bulk Analysis", className="text-xl font-bold text-white")
                ], className="flex items-center"),
            ], className="container mx-auto px-6 py-3 flex justify-between items-center"),
            className="bg-blue-600 shadow-lg mb-6"
        ),


        dcc.Store(id="stored-results", storage_type="memory"),


        # Main container
        html.Div([
            html.Div([
                html.H2("Multi-Ticker Analysis & Backtesting", className="text-2xl font-bold mb-6"),
                
                # Ticker selection section
                html.Div([
                    html.H3("1. Select Tickers for Analysis", className="text-xl font-semibold mb-3"),
                    dcc.Dropdown(
                        id='bulk-ticker-dropdown',
                        options=[{'label': ticker, 'value': ticker} for ticker in AVAILABLE_TICKERS],
                        multi=True,
                        placeholder="Select multiple tickers for analysis",
                        className="w-full"
                    ),
                ], className="mb-8 p-4 bg-white rounded shadow"),
                
                # Technical analysis selection
                html.Div([
                    html.H3("2. Select Technical Indicators", className="text-xl font-semibold mb-3"),
                    dcc.Checklist(
                        id='bulk-technical-checklist',
                        options=[
                            {'label': ' Bollinger Bands', 'value': 'Bollinger_Signal'},
                            {'label': ' Moving Average', 'value': 'MA_Signal'},
                            {'label': ' RSI', 'value': 'RSI_Signal'},
                            {'label': ' MACD', 'value': 'MACD_Signal'},
                            {'label': ' ADX', 'value': 'ADX_Signal'},
                            {'label': ' Volume', 'value': 'Volume_Signal'},
                            {'label': ' Fibonacci Retracement', 'value': 'Fibonacci_Signal'},
                            {'label': ' Candlestick Patterns', 'value': 'Candlestick_Signal'},
                        ],
                        value=['Bollinger_Signal', 'MA_Signal', 'RSI_Signal'],
                        className="space-y-2"
                    ),
                ], className="mb-8 p-4 bg-white rounded shadow"),
                
                # Date Range Selection
                html.Div([
                    html.H3("3. Select Date Range", className="text-xl font-semibold mb-3"),
                    html.Div([
                        # Start Date
                        html.Div([
                            html.Label("Start Date", className="block text-sm mb-1"),
                            html.Div([
                                dcc.Dropdown(
                                    id='bulk-start-year-dropdown',
                                    placeholder="Year",
                                    className="w-full",
                                    value=2024,  # Default Start Year: 2024
                                    options=[{'label': str(year), 'value': year} for year in range(2020, 2026)]
                                ),
                                dcc.Dropdown(
                                    id='bulk-start-month-dropdown',
                                    placeholder="Month",
                                    className="w-full",
                                    value=6,  # Default Start Month: June (6)
                                    options=[
                                        {'label': 'January', 'value': 1}, {'label': 'February', 'value': 2},
                                        {'label': 'March', 'value': 3}, {'label': 'April', 'value': 4},
                                        {'label': 'May', 'value': 5}, {'label': 'June', 'value': 6},
                                        {'label': 'July', 'value': 7}, {'label': 'August', 'value': 8},
                                        {'label': 'September', 'value': 9}, {'label': 'October', 'value': 10},
                                        {'label': 'November', 'value': 11}, {'label': 'December', 'value': 12}
                                    ]
                                ),
                                dcc.Dropdown(
                                    id='bulk-start-day-dropdown',
                                    placeholder="Day",
                                    className="w-full",
                                    value=1,  # Default Start Day: 1
                                    options=[{'label': str(day), 'value': day} for day in range(1, 32)]
                                ),
                            ], className="grid grid-cols-3 gap-2")
                        ], className="mb-4"),

                        # End Date
                        html.Div([
                            html.Label("End Date", className="block text-sm mb-1"),
                            html.Div([
                                dcc.Dropdown(
                                    id='bulk-end-year-dropdown',
                                    placeholder="Year",
                                    className="w-full",
                                    value=2025,  # Default End Year: 2025
                                    options=[{'label': str(year), 'value': year} for year in range(2020, 2026)]
                                ),
                                dcc.Dropdown(
                                    id='bulk-end-month-dropdown',
                                    placeholder="Month",
                                    className="w-full",
                                    value=5,  # Default End Month: May (5)
                                    options=[
                                        {'label': 'January', 'value': 1}, {'label': 'February', 'value': 2},
                                        {'label': 'March', 'value': 3}, {'label': 'April', 'value': 4},
                                        {'label': 'May', 'value': 5}, {'label': 'June', 'value': 6},
                                        {'label': 'July', 'value': 7}, {'label': 'August', 'value': 8},
                                        {'label': 'September', 'value': 9}, {'label': 'October', 'value': 10},
                                        {'label': 'November', 'value': 11}, {'label': 'December', 'value': 12}
                                    ]
                                ),
                                dcc.Dropdown(
                                    id='bulk-end-day-dropdown',
                                    placeholder="Day",
                                    className="w-full",
                                    value=31,  # Default End Day: 31
                                    options=[{'label': str(day), 'value': day} for day in range(1, 32)]
                                ),
                            ], className="grid grid-cols-3 gap-2")
                        ]),
                    ], className="space-y-4"),
                ], className="mb-8 p-4 bg-white rounded shadow"),


                # html.Div([
                #     html.H3("3. Select Date Range", className="text-xl font-semibold mb-3"),
                #     html.Div([
                #         # Start Date
                #         html.Div([
                #             html.Label("Start Date", className="block text-sm mb-1"),
                #             html.Div([
                #                 dcc.Dropdown(
                #                     id='bulk-start-year-dropdown',
                #                     placeholder="Year",
                #                     className="w-full"
                #                 ),
                #                 dcc.Dropdown(
                #                     id='bulk-start-month-dropdown',
                #                     placeholder="Month",
                #                     className="w-full"
                #                 ),
                #                 dcc.Dropdown(
                #                     id='bulk-start-day-dropdown',
                #                     placeholder="Day",
                #                     className="w-full"
                #                 ),
                #             ], className="grid grid-cols-3 gap-2")
                #         ], className="mb-4"),
                        
                #         # End Date
                #         html.Div([
                #             html.Label("End Date", className="block text-sm mb-1"),
                #             html.Div([
                #                 dcc.Dropdown(
                #                     id='bulk-end-year-dropdown',
                #                     placeholder="Year",
                #                     className="w-full"
                #                 ),
                #                 dcc.Dropdown(
                #                     id='bulk-end-month-dropdown',
                #                     placeholder="Month",
                #                     className="w-full"
                #                 ),
                #                 dcc.Dropdown(
                #                     id='bulk-end-day-dropdown',
                #                     placeholder="Day",
                #                     className="w-full"
                #                 ),
                #             ], className="grid grid-cols-3 gap-2")
                #         ]),
                #     ], className="space-y-4"),
                # ], className="mb-8 p-4 bg-white rounded shadow"),
                
                # Capital Input
                html.Div([
                    html.H3("4. Capital & Parameters", className="text-xl font-semibold mb-3"),
                    html.Div([
                        html.Label("Initial Capital Amount:", className="text-sm"),
                        dcc.Input(
                            id='bulk-capital-input',
                            type='number',
                            placeholder='Enter initial capital',
                            value=1000000,
                            className="w-full p-2 border rounded mb-4"
                        ),
                        
                        # Optional advanced parameters toggle
                        html.Div([
                            html.Button(
                                html.Div([
                                    html.Span("Advanced Parameters", className="mr-2"),
                                    html.I(className="fas fa-chevron-down")
                                ], className="flex items-center"),
                                id="advanced-params-toggle",
                                className="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded"
                            ),
                            
                            # Collapsible advanced parameters section
                            html.Div([
                                # Will populate with parameter controls when opened
                            ], id="advanced-params-content", className="hidden mt-4")
                        ], className="mt-2")
                    ])
                ], className="mb-8 p-4 bg-white rounded shadow"),
                
                # Run Analysis Button
                html.Div([
                    html.Button(
                        html.Div([
                            html.I(className="fas fa-play-circle mr-2"),
                            "Run Bulk Analysis"
                        ], className="flex items-center justify-center"),
                        id="run-bulk-analysis",
                        className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded w-full"
                    ),
                ], className="mb-8"),
                
                # Progress indicator
                html.Div([
                    dcc.Loading(
                        id="bulk-loading",
                        type="circle",
                        children=html.Div(id="bulk-loading-output")
                    )
                ], className="mb-4"),
                
                # Results Section with Enhanced Tabs
                html.Div([
                    # Main Results Tabs
                    html.Div([
                        html.H2("Backtesting Results", className="text-2xl font-bold mb-4"),
                        dcc.Tabs(
                            id="main-results-tabs", 
                            className="mb-8",
                            children=[
                                dcc.Tab(
                                    label="Raw Data", 
                                    className="font-semibold py-3 px-4",
                                    selected_className="bg-blue-50 border-t-2 border-blue-600",
                                    children=[
                                        html.Div(id="raw-data-explorer", className="mt-4 p-4")
                                    ]
                                ),
                                dcc.Tab(
                                    label="Backtesting Analysis", 
                                    className="font-semibold py-3 px-4",
                                    selected_className="bg-blue-50 border-t-2 border-blue-600",
                                    children=[
                                        html.Div(id="backtesting-analysis-content", className="mt-4 p-4")
                                    ]
                                ),
                                # dcc.Tab(
                                #     label="Backtesting Profit", 
                                #     className="font-semibold py-3 px-4",
                                #     selected_className="bg-blue-50 border-t-2 border-blue-600",
                                #     children=[
                                #         html.Div(id="backtesting-profit-content", className="mt-4 p-4")
                                #     ]
                                # )
                            ]
                        )
                    ], className="border-b pb-6 mb-6"),
                    
                    # # Detailed Results Section with nested tabs by ticker
                    # html.Div([
                    #     html.H2("Detailed Results by Ticker", className="text-xl font-bold mb-4"),
                    #     html.Div(id="detailed-results-by-ticker", className="mt-4"),
                    # ], className="mb-6"),
                    
                    # # Leaderboard Section
                    # html.Div([
                    #     html.H2("Performance Leaderboard", className="text-xl font-bold mb-4"),
                    #     dcc.Tabs([
                    #         dcc.Tab(
                    #             label="Analysis Leaderboard", 
                    #             className="font-semibold py-3 px-4",
                    #             selected_className="bg-blue-50 border-t-2 border-blue-600",
                    #             children=[
                    #                 html.Div(id="analysis-leaderboard", className="mt-4 p-4")
                    #             ]
                    #         ),
                    #         dcc.Tab(
                    #             label="Profit Leaderboard", 
                    #             className="font-semibold py-3 px-4",
                    #             selected_className="bg-blue-50 border-t-2 border-blue-600",
                    #             children=[
                    #                 html.Div(id="profit-leaderboard", className="mt-4 p-4")
                    #             ]
                    #         )
                    #     ], className="mb-4")
                    # ], className="mb-6"),
                    
                    # # Download section
                    # html.Div([
                    #     html.Button(
                    #         html.Div([
                    #             html.I(className="fas fa-download mr-2"),
                    #             "Download Results as Excel"
                    #         ], className="flex items-center justify-center"),
                    #         id="download-bulk-results",
                    #         className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded mt-4"
                    #     ),
                    #     dcc.Download(id="download-bulk-data")
                    # ], className="mt-4")
                ], id="bulk-results-container", className="p-6 bg-white rounded shadow hidden")
            ], className="max-w-7xl mx-auto")
        ], className="container mx-auto px-4")
    ], className="min-h-screen bg-gray-50 pb-12")



@app.callback(
    Output("detailed-results-by-ticker", "children"),
    [Input("bulk-ticker-dropdown", "value"),
     Input("run-bulk-analysis", "n_clicks")],
    [State("backtesting-analysis-content", "children"),
    #  State("backtesting-profit-content", "children"),
     State("raw-data-explorer", "children")]
)
def update_detailed_results_by_ticker(selected_tickers, n_clicks, analysis_results, profit_results, raw_data_results):
    if not selected_tickers or not n_clicks:
        return html.Div("Run analysis to see detailed results by ticker", className="text-center text-gray-500 p-4")
        
    try:
        # Create tabs for result type selection first
        return html.Div([
            html.Div([
                html.H2("Detailed Results by Ticker", className="text-2xl font-bold mb-4"),
                
                dcc.Tabs([
                    # General Overview Tab
                    dcc.Tab(
                        label="General Overview",
                        className="font-semibold py-3 px-4",
                        selected_className="bg-blue-50 border-t-2 border-blue-600",
                        children=[
                            html.Div([
                                # Summary metrics across tickers
                                html.Div([
                                    html.H3("Performance Summary", className="text-xl font-semibold mb-3"),
                                    html.Div([
                                        html.Div([
                                            html.Div([
                                                html.Span("Analyzed Tickers", className="block text-sm text-gray-500"),
                                                html.Span(f"{len(selected_tickers)}", className="block text-xl font-bold text-blue-600")
                                            ], className="p-4 border rounded bg-white shadow-sm")
                                        ], className="w-1/4 px-2"),
                                        html.Div([
                                            html.Div([
                                                html.Span("Best Ticker", className="block text-sm text-gray-500"),
                                                html.Span(id="best-ticker-general", className="block text-xl font-bold text-blue-600")
                                            ], className="p-4 border rounded bg-white shadow-sm")
                                        ], className="w-1/4 px-2"),
                                        html.Div([
                                            html.Div([
                                                html.Span("Best Return", className="block text-sm text-gray-500"),
                                                html.Span(id="best-return-general", className="block text-xl font-bold text-green-600")
                                            ], className="p-4 border rounded bg-white shadow-sm")
                                        ], className="w-1/4 px-2"),
                                        html.Div([
                                            html.Div([
                                                html.Span("Best Indicator", className="block text-sm text-gray-500"),
                                                html.Span(id="best-indicator-general", className="block text-xl font-bold text-blue-600")
                                            ], className="p-4 border rounded bg-white shadow-sm")
                                        ], className="w-1/4 px-2"),
                                    ], className="flex -mx-2 mb-6")
                                ], className="mb-6"),
                                
                                # Ticker comparison table
                                html.Div([
                                    html.H3("Ticker Performance Comparison", className="text-xl font-semibold mb-3"),
                                    dash_table.DataTable(
                                        id="ticker-comparison-table",
                                        columns=[
                                            {'name': 'Ticker', 'id': 'ticker'},
                                            {'name': 'Best Indicator', 'id': 'best_indicator'},
                                            {'name': 'Best Profit %', 'id': 'best_profit', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                                            {'name': 'Total Trades', 'id': 'total_trades'},
                                            {'name': 'Win Rate', 'id': 'win_rate', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}}
                                        ],
                                        style_table={'overflowX': 'auto'},
                                        style_cell={'textAlign': 'left', 'padding': '10px'},
                                        style_header={
                                            'backgroundColor': 'rgb(240, 240, 240)',
                                            'fontWeight': 'bold'
                                        },
                                        style_data_conditional=[
                                            {
                                                'if': {'filter_query': '{best_profit} < 0'},
                                                'color': 'red'
                                            },
                                            {
                                                'if': {'filter_query': '{best_profit} >= 0'},
                                                'color': 'green'
                                            }
                                        ],
                                        sort_action='native',
                                        filter_action='native',
                                        page_size=15
                                    ),
                                ], className="mb-6"),
                                
                                # Performance chart
                                html.Div([
                                    html.H3("Performance Comparison", className="text-xl font-semibold mb-3"),
                                    dcc.Graph(id="ticker-performance-chart")
                                ])
                            ], className="mt-4 p-4")
                        ]
                    ),
                    
                    # Individual Ticker Results Tab
                    dcc.Tab(
                        label="Individual Ticker Results",
                        className="font-semibold py-3 px-4",
                        selected_className="bg-blue-50 border-t-2 border-blue-600",
                        children=[
                            html.Div([
                                # Ticker selector
                                html.Div([
                                    html.Label("Select Ticker:", className="mr-2 font-medium"),
                                    dcc.Dropdown(
                                        id="individual-ticker-selector",
                                        options=[{'label': ticker, 'value': ticker} for ticker in selected_tickers],
                                        value=selected_tickers[0] if selected_tickers else None,
                                        className="w-full"
                                    )
                                ], className="mb-4"),
                                
                                # Detailed ticker results (with nested tabs)
                                html.Div([
                                    # Summary metrics for this ticker
                                    html.Div([
                                        html.H3(id="ticker-summary-header", className="text-xl font-semibold mb-3"),
                                        html.Div([
                                            html.Div([
                                                html.Div([
                                                    html.Span("Best Indicator", className="block text-sm text-gray-500"),
                                                    html.Span(id="selected-ticker-best-indicator", className="block text-xl font-bold text-blue-600")
                                                ], className="p-4 border rounded bg-white shadow-sm")
                                            ], className="w-1/4 px-2"),
                                            html.Div([
                                                html.Div([
                                                    html.Span("Best Profit %", className="block text-sm text-gray-500"),
                                                    html.Span(id="selected-ticker-best-profit", className="block text-xl font-bold text-green-600")
                                                ], className="p-4 border rounded bg-white shadow-sm")
                                            ], className="w-1/4 px-2"),
                                            html.Div([
                                                html.Div([
                                                    html.Span("Total Trades", className="block text-sm text-gray-500"),
                                                    html.Span(id="selected-ticker-total-trades", className="block text-xl font-bold text-blue-600")
                                                ], className="p-4 border rounded bg-white shadow-sm")
                                            ], className="w-1/4 px-2"),
                                            html.Div([
                                                html.Div([
                                                    html.Span("Win Rate", className="block text-sm text-gray-500"),
                                                    html.Span(id="selected-ticker-win-rate", className="block text-xl font-bold text-green-600")
                                                ], className="p-4 border rounded bg-white shadow-sm")
                                            ], className="w-1/4 px-2"),
                                        ], className="flex -mx-2 mb-6")
                                    ], className="mb-6"),
                                    
                                    # Three main tabs for data, analysis and profit
                                    dcc.Tabs([
                                        # Raw Data Tab
                                        dcc.Tab(
                                            label="Raw Data", 
                                            className="font-semibold py-3 px-4",
                                            selected_className="bg-blue-50 border-t-2 border-blue-600",
                                            children=[
                                                html.Div(id="selected-ticker-raw-data", className="mt-4")
                                            ]
                                        ),
                                        
                                        # Backtesting Analysis Tab
                                        dcc.Tab(
                                            label="Backtesting Analysis", 
                                            className="font-semibold py-3 px-4",
                                            selected_className="bg-blue-50 border-t-2 border-blue-600",
                                            children=[
                                                html.Div(id="selected-ticker-analysis", className="mt-4")
                                            ]
                                        ),
                                        
                                        # Backtesting Profit Tab
                                        dcc.Tab(
                                            label="Backtesting Profit", 
                                            className="font-semibold py-3 px-4",
                                            selected_className="bg-blue-50 border-t-2 border-blue-600",
                                            children=[
                                                html.Div(id="selected-ticker-profit", className="mt-4")
                                            ]
                                        )
                                    ], id="selected-ticker-results-tabs", className="mb-4")
                                ], id="individual-ticker-results")
                            ], className="mt-4 p-4")
                        ]
                    )
                ])
            ], className="p-4 bg-white rounded shadow-sm")
        ])
    
    except Exception as e:
        return html.Div([
            html.H3("Error", className="text-xl font-bold text-red-600 mb-2"),
            html.P(f"An error occurred: {str(e)}", className="text-red-500"),
            html.Pre(traceback.format_exc(), className="bg-gray-100 p-4 rounded text-sm mt-2")
        ])





# Callback to update selected ticker data in the individual ticker tab
@app.callback(
    [Output("ticker-summary-header", "children"),
     Output("selected-ticker-best-indicator", "children"),
     Output("selected-ticker-best-profit", "children"),
     Output("selected-ticker-total-trades", "children"),
     Output("selected-ticker-win-rate", "children"),
     Output("selected-ticker-raw-data", "children"),
     Output("selected-ticker-analysis", "children"),
     Output("selected-ticker-profit", "children")],
    [Input("individual-ticker-selector", "value")],
    [State("run-bulk-analysis", "n_clicks")]
)
def update_selected_ticker_details(selected_ticker, n_clicks):
    if not n_clicks or not selected_ticker:
        raise dash.exceptions.PreventUpdate
    
    try:
        # Prepare the header and summary data
        header_text = f"Performance Summary for {selected_ticker}"
        
        # Fetch data for this ticker
        start_date = pd.Timestamp(year=2022, month=1, day=1)  # Use actual dates from your inputs
        end_date = pd.Timestamp(year=2023, month=1, day=1)
        
        df = fetch_ticker_data(selected_ticker, start_date, end_date)
        
        if df.empty:
            return (
                header_text,
                "N/A",
                "N/A",
                "N/A",
                "N/A",
                html.Div(f"No data available for {selected_ticker}", className="text-center text-gray-500"),
                html.Div(f"No data available for {selected_ticker}", className="text-center text-gray-500"),
                html.Div(f"No data available for {selected_ticker}", className="text-center text-gray-500")
            )
        
        # Apply technical indicators
        indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
        df = apply_technical_indicators(df, indicators)
        
        # Calculate performance metrics for each indicator
        indicator_performance = {}
        best_indicator = None
        best_profit = -float('inf')
        
        for indicator in indicators:
            if indicator in df.columns:
                result = run_backtest_for_indicator(df, indicator, 10000000)  # 10M initial capital
                if result:
                    indicator_performance[indicator] = result
                    if result['profit_percentage'] > best_profit:
                        best_profit = result['profit_percentage']
                        best_indicator = indicator
        
        # If we have a combined signal, calculate its performance too
        if 'Combined_Signal' in df.columns:
            result = run_backtest_for_indicator(df, 'Combined_Signal', 10000000)
            if result and result['profit_percentage'] > best_profit:
                best_profit = result['profit_percentage']
                best_indicator = 'Combined_Signal'
        
        # Get total trades and win rate from best indicator
        total_trades = 0
        win_rate = 0
        if best_indicator and best_indicator in indicator_performance:
            total_trades = indicator_performance[best_indicator]['num_trades']
            win_rate = indicator_performance[best_indicator]['win_rate']
        
        # Create raw data display
        raw_data_display = create_ticker_raw_data_display(df, selected_ticker)
        
        # Create analysis display
        analysis_display = create_ticker_analysis_display(df, indicator_performance, selected_ticker)
        
        # Create profit display
        profit_display = create_ticker_profit_display(df, indicator_performance, selected_ticker)
        
        return (
            header_text,
            best_indicator if best_indicator else "N/A",
            f"{best_profit:.2f}%" if best_profit > -float('inf') else "N/A",
            str(total_trades),
            f"{win_rate:.2f}%",
            raw_data_display,
            analysis_display,
            profit_display
        )
        
    except Exception as e:
        error_display = html.Div([
            html.P(f"Error loading ticker details: {str(e)}", className="text-red-500"),
            html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
        ])
        return (
            f"Error: {selected_ticker}",
            "Error",
            "Error",
            "Error",
            "Error",
            error_display,
            error_display,
            error_display
        )
    




def create_ticker_raw_data_display(df, ticker):
    """Create the raw data display for a specific ticker"""
    return html.Div([
        html.H3(f"Raw Data for {ticker}", className="text-xl font-semibold mb-3"),
        
        # Create summary stats
        html.Div([
            html.H4("Data Summary", className="text-lg font-semibold mb-2"),
            html.Div([
                html.P(f"Total Records: {len(df)}", className="mb-1"),
                html.P(f"Date Range: {df['Datetime'].min()} to {df['Datetime'].max()}", className="mb-1"),
                html.P(f"Average Price: {df['Close'].mean():.2f}", className="mb-1"),
                html.P(f"Price Range: {df['Close'].min():.2f} to {df['Close'].max():.2f}", className="mb-1"),
                html.P(f"Average Volume: {df['Volume'].mean():.2f}", className="mb-1"),
            ], className="p-3 bg-gray-50 rounded mb-4")
        ]),
        
        # Create data table
        dash_table.DataTable(
            data=df.head(1000).to_dict('records'),  # Limited to first 1000 rows for performance
            columns=[{'name': col, 'id': col} for col in df.columns],
            style_table={'overflowX': 'auto', 'maxHeight': '500px'},
            style_cell={'textAlign': 'left', 'padding': '5px'},
            style_data_conditional=[
                {
                    'if': {'column_id': col, 'filter_query': '{' + col + '} = "Buy"'}
                    for col in [c for c in df.columns if 'Signal' in c]
                },
                {
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                {
                    'if': {'column_id': col, 'filter_query': '{' + col + '} = "Sell"'}
                    for col in [c for c in df.columns if 'Signal' in c]
                },
                {
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                }
            ],
            page_size=15,
            sort_action='native',
            filter_action='native'
        ),
        
        # Price chart
        html.Div([
            html.H4("Price Chart", className="text-lg font-semibold mt-4 mb-3"),
            dcc.Graph(
                figure=create_ticker_price_chart(df, ticker),
                config={'displayModeBar': True}
            )
        ])
    ])

def create_ticker_analysis_display(df, indicator_performance, ticker):
    """Create the backtesting analysis display for a specific ticker"""
    if not indicator_performance:
        return html.Div("No indicator performance data available", className="text-center text-gray-500")
    
    # Sort indicators by profit percentage
    sorted_indicators = sorted(
        indicator_performance.items(), 
        key=lambda x: x[1]['profit_percentage'], 
        reverse=True
    )
    
    return html.Div([
        html.H3(f"Analysis Results for {ticker}", className="text-xl font-semibold mb-3"),
        
        # Add summary metrics cards for this ticker's analysis
        html.Div([
            html.Div([
                html.Div([
                    html.Span("Signal Accuracy", className="block text-sm text-gray-500"),
                    html.Span(
                        f"{sorted_indicators[0][1]['win_rate']:.2f}%" if sorted_indicators else "N/A", 
                        className="block text-xl font-bold text-blue-600"
                    )
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/3 px-2"),
            html.Div([
                html.Div([
                    html.Span("Buy Signals", className="block text-sm text-gray-500"),
                    html.Span(
                        f"{len(df[df[sorted_indicators[0][0]] == 'Buy'])}" if sorted_indicators else "N/A", 
                        className="block text-xl font-bold text-green-600"
                    )
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/3 px-2"),
            html.Div([
                html.Div([
                    html.Span("Sell Signals", className="block text-sm text-gray-500"),
                    html.Span(
                        f"{len(df[df[sorted_indicators[0][0]] == 'Sell'])}" if sorted_indicators else "N/A",
                        className="block text-xl font-bold text-red-600"
                    )
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/3 px-2"),
        ], className="flex -mx-2 mb-6"),
        
        # Add indicator tabs for detailed analysis
        html.Div([
            html.H4("Indicator Performance", className="text-lg font-semibold mb-3"),
            dcc.Tabs(
                className="mb-4",
                children=[
                    dcc.Tab(
                        label=indicator,
                        className="font-semibold",
                        selected_className="border-b-2 border-blue-500",
                        children=[
                            create_indicator_analysis_tab(df, indicator, result, ticker)
                        ]
                    ) for indicator, result in sorted_indicators
                ]
            )
        ]),
        
        # Add signal chart
        html.Div([
            html.H4("Signal Distribution", className="text-lg font-semibold mb-3"),
            dcc.Graph(
                figure=create_signal_distribution_chart(df, ticker)
            )
        ], className="mb-6"),
    ])

def create_ticker_profit_display(df, indicator_performance, ticker):
    """Create the backtesting profit display for a specific ticker"""
    if not indicator_performance:
        return html.Div("No profit data available", className="text-center text-gray-500")
    
    # Sort indicators by profit percentage
    sorted_indicators = sorted(
        indicator_performance.items(), 
        key=lambda x: x[1]['profit_percentage'], 
        reverse=True
    )
    
    best_indicator, best_result = sorted_indicators[0]
    
    return html.Div([
        html.H3(f"Profit Results for {ticker}", className="text-xl font-semibold mb-3"),
        
        # Add profit metrics cards
        html.Div([
            html.Div([
                html.Div([
                    html.Span("Initial Capital", className="block text-sm text-gray-500"),
                    html.Span(f"{best_result['initial_capital']:,.2f}", className="block text-xl font-bold text-blue-600")
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
            html.Div([
                html.Div([
                    html.Span("Final Capital", className="block text-sm text-gray-500"),
                    html.Span(f"{best_result['final_capital']:,.2f}", className="block text-xl font-bold text-green-600")
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
            html.Div([
                html.Div([
                    html.Span("Total Profit", className="block text-sm text-gray-500"),
                    html.Span(
                        f"{best_result['total_profit']:,.2f}", 
                        className=f"block text-xl font-bold {'text-green-600' if best_result['total_profit'] >= 0 else 'text-red-600'}"
                    )
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
            html.Div([
                html.Div([
                    html.Span("Return %", className="block text-sm text-gray-500"),
                    html.Span(
                        f"{best_result['profit_percentage']:.2f}%", 
                        className=f"block text-xl font-bold {'text-green-600' if best_result['profit_percentage'] >= 0 else 'text-red-600'}"
                    )
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
        ], className="flex -mx-2 mb-6"),
        
        # Profit comparison
        html.Div([
            html.H4("Indicator Profit Comparison", className="text-lg font-semibold mb-3"),
            dcc.Graph(
                figure=go.Figure(
                    data=[
                        go.Bar(
                            x=[ind for ind, _ in sorted_indicators],
                            y=[res['profit_percentage'] for _, res in sorted_indicators],
                            marker_color=['green' if res['profit_percentage'] >= 0 else 'red' for _, res in sorted_indicators],
                            text=[f"{res['profit_percentage']:.2f}%" for _, res in sorted_indicators],
                            textposition='auto'
                        )
                    ],
                    layout=go.Layout(
                        title=f"Profit Percentage by Indicator for {ticker}",
                        xaxis_title="Indicator",
                        yaxis_title="Profit %",
                        height=400
                    )
                )
            )
        ], className="mb-6"),
        
        # Capital growth chart
        html.Div([
            html.H4("Capital Growth", className="text-lg font-semibold mb-3"),
            dcc.Graph(
                figure=create_capital_growth_chart(best_result, ticker, best_indicator)
            )
        ], className="mb-6"),
        
        # Detailed trade history
        html.Div([
            html.H4("Detailed Trade History", className="text-lg font-semibold mb-3"),
            dash_table.DataTable(
                data=[{
                    'Date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
                    'Type': t['type'],
                    'Price': f"{t['price']:.2f}",
                    'Shares': t['shares'],
                    'Value': f"{t['value']:,.2f}",
                    'Cash After': f"{t['remaining_cash']:,.2f}",
                } for t in best_result['trades'] if hasattr(t['date'], 'strftime') or isinstance(t['date'], str)],
                columns=[
                    {'name': 'Date', 'id': 'Date'},
                    {'name': 'Type', 'id': 'Type'},
                    {'name': 'Price', 'id': 'Price'},
                    {'name': 'Shares', 'id': 'Shares'},
                    {'name': 'Value', 'id': 'Value'},
                    {'name': 'Cash After', 'id': 'Cash After'},
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Type} = "Buy"'},
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                        'color': 'green'
                    },
                    {
                        'if': {'filter_query': '{Type} = "Sell"'},
                        'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                        'color': 'red'
                    }
                ],
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                page_size=15,
                sort_action='native'
            )
        ], className="mb-6"),
    ])





# @app.callback(
#     [# Output("analysis-leaderboard", "children"),
#      Output("profit-leaderboard", "children")],
#     [Input("run-bulk-analysis", "n_clicks")],
#     [State("backtesting-analysis-content", "children"),
#      State("backtesting-profit-content", "children")]
# )
# def update_leaderboards(n_clicks, analysis_results, profit_results):
#     """Generate leaderboard tables for Analysis and Profit results"""
#     if not n_clicks:
#         raise dash.exceptions.PreventUpdate
    
#     # Analysis Leaderboard
#     analysis_leaderboard = html.Div([
#         html.H3("Top Performing Indicators by Ticker", className="text-lg font-semibold mb-3"),
        
#         # Overall metrics
#         html.Div([
#             html.Div([
#                 html.Div([
#                     html.Span("Best Ticker", className="block text-sm text-gray-500"),
#                     html.Span("BBCA.JK", className="block text-xl font-bold text-blue-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#             html.Div([
#                 html.Div([
#                     html.Span("Best Indicator", className="block text-sm text-gray-500"),
#                     html.Span("Bollinger Bands", className="block text-xl font-bold text-blue-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#             html.Div([
#                 html.Div([
#                     html.Span("Top Profit %", className="block text-sm text-gray-500"),
#                     html.Span("12.8%", className="block text-xl font-bold text-green-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#             html.Div([
#                 html.Div([
#                     html.Span("Top Win Rate", className="block text-sm text-gray-500"),
#                     html.Span("78.5%", className="block text-xl font-bold text-blue-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#         ], className="flex -mx-2 mb-6"),
        
#         # Leaderboard table
#         dash_table.DataTable(
#             # This would be populated with actual data from analysis results
#             data=[
#                 {
#                     'Rank': 1,
#                     'Ticker': 'BBCA.JK',
#                     'Indicator': 'Bollinger Bands',
#                     'Profit %': '12.8%',
#                     'Win Rate': '78.5%',
#                     'Trades': '14',
#                     'Signal Accuracy': '82.3%'
#                 },
#                 {
#                     'Rank': 2,
#                     'Ticker': 'TLKM.JK',
#                     'Indicator': 'RSI',
#                     'Profit %': '10.2%',
#                     'Win Rate': '73.1%',
#                     'Trades': '12',
#                     'Signal Accuracy': '79.8%'
#                 },
#                 # Add more rows with actual data
#             ],
#             columns=[
#                 {'name': 'Rank', 'id': 'Rank'},
#                 {'name': 'Ticker', 'id': 'Ticker'},
#                 {'name': 'Indicator', 'id': 'Indicator'},
#                 {'name': 'Profit %', 'id': 'Profit %'},
#                 {'name': 'Win Rate', 'id': 'Win Rate'},
#                 {'name': 'Trades', 'id': 'Trades'},
#                 {'name': 'Signal Accuracy', 'id': 'Signal Accuracy'}
#             ],
#             style_table={'overflowX': 'auto'},
#             style_cell={'textAlign': 'left', 'padding': '10px'},
#             style_data_conditional=[
#                 {
#                     'if': {'row_index': 0},
#                     'backgroundColor': 'rgba(0, 255, 0, 0.1)',
#                     'fontWeight': 'bold'
#                 },
#                 {
#                     'if': {'row_index': 1},
#                     'backgroundColor': 'rgba(0, 255, 0, 0.05)',
#                 }
#             ],
#             style_header={
#                 'backgroundColor': 'rgb(240, 240, 240)',
#                 'fontWeight': 'bold'
#             },
#             sort_action='native',
#             page_size=10
#         ),
        
#         # Visualization of top performers
#         html.Div([
#             html.H4("Top 10 Performers by Profit %", className="text-lg font-semibold mt-4 mb-3"),
#             dcc.Graph(
#                 figure=go.Figure(
#                     data=[
#                         go.Bar(
#                             x=['BBCA.JK (BB)', 'TLKM.JK (RSI)', 'ASII.JK (MACD)', 'UNVR.JK (MA)', 'BMRI.JK (BB)'],
#                             y=[12.8, 10.2, 8.7, 7.6, 6.9],  # Replace with actual data
#                             marker_color='green',
#                             text=['12.8%', '10.2%', '8.7%', '7.6%', '6.9%'],  # Replace with actual data
#                             textposition='auto'
#                         )
#                     ],
#                     layout=go.Layout(
#                         title='Top Performers by Profit %',
#                         xaxis_title='Ticker (Indicator)',
#                         yaxis_title='Profit %',
#                         height=400
#                     )
#                 )
#             )
#         ], className="mt-6")
#     ])
    
#     # Profit Leaderboard
#     profit_leaderboard = html.Div([
#         html.H3("Top Profitable Scenarios", className="text-lg font-semibold mb-3"),
        
#         # Overall metrics
#         html.Div([
#             html.Div([
#                 html.Div([
#                     html.Span("Most Profitable Ticker", className="block text-sm text-gray-500"),
#                     html.Span("BBCA.JK", className="block text-xl font-bold text-blue-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#             html.Div([
#                 html.Div([
#                     html.Span("Best Final Capital", className="block text-sm text-gray-500"),
#                     html.Span("11,280,000", className="block text-xl font-bold text-green-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#             html.Div([
#                 html.Div([
#                     html.Span("Best Total Profit", className="block text-sm text-gray-500"),
#                     html.Span("1,280,000", className="block text-xl font-bold text-green-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#             html.Div([
#                 html.Div([
#                     html.Span("Best Profit %", className="block text-sm text-gray-500"),
#                     html.Span("12.8%", className="block text-xl font-bold text-green-600")  # Replace with actual data
#                 ], className="p-4 border rounded bg-white shadow-sm")
#             ], className="w-1/4 px-2"),
#         ], className="flex -mx-2 mb-6"),
        
#         # Profit leaderboard table
#         dash_table.DataTable(
#             # This would be populated with actual data from profit results
#             data=[
#                 {
#                     'Rank': 1,
#                     'Ticker': 'BBCA.JK',
#                     'Initial Capital': '10,000,000',
#                     'Final Capital': '11,280,000',
#                     'Total Profit': '1,280,000',
#                     'Profit %': '12.8%',
#                     'Trades': '14',
#                     'Period': '2023-01-15 to 2023-06-15'
#                 },
#                 {
#                     'Rank': 2,
#                     'Ticker': 'TLKM.JK',
#                     'Initial Capital': '10,000,000',
#                     'Final Capital': '11,020,000',
#                     'Total Profit': '1,020,000',
#                     'Profit %': '10.2%',
#                     'Trades': '12',
#                     'Period': '2023-01-15 to 2023-06-15'
#                 },
#                 # Add more rows with actual data
#             ],
#             columns=[
#                 {'name': 'Rank', 'id': 'Rank'},
#                 {'name': 'Ticker', 'id': 'Ticker'},
#                 {'name': 'Initial Capital', 'id': 'Initial Capital'},
#                 {'name': 'Final Capital', 'id': 'Final Capital'},
#                 {'name': 'Total Profit', 'id': 'Total Profit'},
#                 {'name': 'Profit %', 'id': 'Profit %'},
#                 {'name': 'Trades', 'id': 'Trades'},
#                 {'name': 'Period', 'id': 'Period'}
#             ],
#             style_table={'overflowX': 'auto'},
#             style_cell={'textAlign': 'left', 'padding': '10px'},
#             style_data_conditional=[
#                 {
#                     'if': {'row_index': 0},
#                     'backgroundColor': 'rgba(0, 255, 0, 0.1)',
#                     'fontWeight': 'bold'
#                 },
#                 {
#                     'if': {'row_index': 1},
#                     'backgroundColor': 'rgba(0, 255, 0, 0.05)',
#                 }
#             ],
#             style_header={
#                 'backgroundColor': 'rgb(240, 240, 240)',
#                 'fontWeight': 'bold'
#             },
#             sort_action='native',
#             page_size=10
#         ),
        
#         # Visualization of profit distribution
#         html.Div([
#             html.H4("Profit Distribution Across Scenarios", className="text-lg font-semibold mt-4 mb-3"),
#             dcc.Graph(
#                 figure=go.Figure(
#                     data=[
#                         go.Bar(
#                             x=['BBCA.JK', 'TLKM.JK', 'ASII.JK', 'UNVR.JK', 'BMRI.JK'],  # Replace with actual tickers
#                             y=[12.8, 10.2, 8.7, 7.6, 6.9],  # Replace with actual profit %
#                             marker_color='green',
#                             text=['12.8%', '10.2%', '8.7%', '7.6%', '6.9%'],  # Replace with actual data
#                             textposition='auto'
#                         )
#                     ],
#                     layout=go.Layout(
#                         title='Profit % by Ticker',
#                         xaxis_title='Ticker',
#                         yaxis_title='Profit %',
#                         height=400
#                     )
#                 )
#             )
#         ], className="mt-6")
#     ])
    
#     return analysis_leaderboard, profit_leaderboard

@app.callback(
    Output("raw-data-explorer", "children"),
    [Input("run-bulk-analysis", "n_clicks")],
    [State("bulk-ticker-dropdown", "value")]
)
def update_raw_data_explorer(n_clicks, selected_tickers):
    """Create a raw data explorer with dropdown for ticker selection"""
    if not n_clicks or not selected_tickers:
        raise dash.exceptions.PreventUpdate
    
    return html.Div([
        html.Div([
            html.Label("Select Ticker:", className="mr-2 font-medium"),
            dcc.Dropdown(
                id="raw-data-ticker-selector",
                options=[{'label': ticker, 'value': ticker} for ticker in selected_tickers],
                value=selected_tickers[0] if selected_tickers else None,
                className="w-full"
            )
        ], className="mb-4"),
        
        # Search and filter controls
        html.Div([
            html.Div([
                html.Label("Search:", className="mr-2 font-medium"),
                dcc.Input(
                    id="raw-data-search",
                    type="text",
                    placeholder="Enter search term",
                    className="p-2 border rounded flex-grow"
                )
            ], className="flex items-center mb-3"),
            
            html.Div([
                html.Label("Filter by Signal:", className="mr-2 font-medium"),
                dcc.Dropdown(
                    id="raw-data-signal-filter",
                    options=[
                        {'label': 'All Signals', 'value': 'all'},
                        {'label': 'Buy Signals', 'value': 'Buy'},
                        {'label': 'Sell Signals', 'value': 'Sell'},
                        {'label': 'Hold Signals', 'value': 'Hold'}
                    ],
                    value='all',
                    clearable=False,
                    className="w-64"
                )
            ], className="flex items-center")
        ], className="mb-4 p-3 bg-gray-50 rounded"),
        
        # Tabs for different views
        dcc.Tabs([
            dcc.Tab(label="Data Table", children=[
                html.Div(id="selected-ticker-data", className="mt-4")
            ]),
            dcc.Tab(label="Price Chart", children=[
                html.Div(id="ticker-price-chart", className="mt-4")
            ]),
            dcc.Tab(label="Signal Distribution", children=[
                html.Div(id="ticker-signal-chart", className="mt-4")
            ]),
            dcc.Tab(label="Technical Indicators", children=[
                html.Div(id="ticker-indicators-chart", className="mt-4")
            ])
        ])
    ])










def register_backtesting_callbacks(app):
    """Register all callbacks for backtesting functionality, integrated with the bulk analysis page"""
    
    # DATE RANGE CALLBACKS
    @app.callback(
        [Output('bulk-start-year-dropdown', 'options'),
         Output('bulk-start-year-dropdown', 'value'),
         Output('bulk-end-year-dropdown', 'options'),
         Output('bulk-end-year-dropdown', 'value')],
        [Input('bulk-ticker-dropdown', 'value')]
    )
    def update_year_dropdowns(selected_tickers):
        # Get current date for default values
        now = datetime.now()
        one_year_ago = now - timedelta(days=365)
        
        # Set default values
        years = list(range(2015, now.year + 1))
        year_options = [{'label': str(year), 'value': year} for year in years]
        
        return year_options, one_year_ago.year, year_options, now.year

    @app.callback(
        [Output('bulk-start-month-dropdown', 'options'),
         Output('bulk-start-month-dropdown', 'value'),
         Output('bulk-end-month-dropdown', 'options'),
         Output('bulk-end-month-dropdown', 'value')],
        [Input('bulk-start-year-dropdown', 'value'),
         Input('bulk-end-year-dropdown', 'value')]
    )
    def update_month_dropdowns(start_year, end_year):
        now = datetime.now()
        one_year_ago = now - timedelta(days=365)
        
        months = [
            {'label': 'January', 'value': 1},
            {'label': 'February', 'value': 2},
            {'label': 'March', 'value': 3},
            {'label': 'April', 'value': 4},
            {'label': 'May', 'value': 5},
            {'label': 'June', 'value': 6},
            {'label': 'July', 'value': 7},
            {'label': 'August', 'value': 8},
            {'label': 'September', 'value': 9},
            {'label': 'October', 'value': 10},
            {'label': 'November', 'value': 11},
            {'label': 'December', 'value': 12}
        ]
        
        start_month = one_year_ago.month if start_year == one_year_ago.year else 1
        end_month = now.month if end_year == now.year else 12
        
        return months, start_month, months, end_month

    @app.callback(
        [Output('bulk-start-day-dropdown', 'options'),
         Output('bulk-start-day-dropdown', 'value'),
         Output('bulk-end-day-dropdown', 'options'),
         Output('bulk-end-day-dropdown', 'value')],
        [Input('bulk-start-year-dropdown', 'value'),
         Input('bulk-start-month-dropdown', 'value'),
         Input('bulk-end-year-dropdown', 'value'),
         Input('bulk-end-month-dropdown', 'value')]
    )
    def update_day_dropdowns(start_year, start_month, end_year, end_month):
        now = datetime.now()
        one_year_ago = now - timedelta(days=365)
        
        def get_days_in_month(year, month):
            if year and month:
                last_day = pd.Period(year=year, month=month, freq='M').days_in_month
                return [{'label': str(day), 'value': day} for day in range(1, last_day + 1)]
            return []
        
        start_days = get_days_in_month(start_year, start_month)
        end_days = get_days_in_month(end_year, end_month)
        
        start_day = one_year_ago.day if (start_year == one_year_ago.year and start_month == one_year_ago.month) else 1
        end_day = now.day if (end_year == now.year and end_month == now.month) else pd.Period(year=end_year, month=end_month, freq='M').days_in_month
        
        # Validate day values
        if start_days and start_day > len(start_days):
            start_day = len(start_days)
        if end_days and end_day > len(end_days):
            end_day = len(end_days)
            
        return start_days, start_day, end_days, end_day

    # Toggle advanced parameters
    # @app.callback(
    #     [Output("advanced-params-content", "className"),
    #      Output("advanced-params-content", "children")],
    #     [Input("advanced-params-toggle", "n_clicks")],
    #     [State("advanced-params-content", "className"),
    #      State("bulk-technical-checklist", "value")]
    # )
    # def toggle_advanced_parameters(n_clicks, current_class, selected_technicals):
    #     if not n_clicks:
    #         return "hidden mt-4", []
        
    #     # Show/hide based on current state
    #     new_class = "mt-4" if "hidden" in current_class else "hidden mt-4"
        
    #     # If hiding, return empty children
    #     if "hidden" not in current_class:
    #         return new_class, []
        
    #     # Create parameter controls based on selected technical indicators
    #     param_controls = []
        
    #     if selected_technicals:
    #         # Include parameters only for selected indicators
    #         if 'Bollinger_Signal' in selected_technicals:
    #             param_controls.append(html.Div([
    #                 html.H4("Bollinger Bands Parameters", className="text-md font-semibold mb-2"),
    #                 html.Div([
    #                     html.Label("Period", className="text-xs"),
    #                     dcc.Input(id='bulk-bb-period', type='number', value=20, min=1, 
    #                             className="w-full p-1 border rounded text-sm")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Label("Standard Deviation", className="text-xs"),
    #                     dcc.Input(id='bulk-bb-std', type='number', value=2, min=0.1, step=0.1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ])
    #             ], className="mb-4 p-3 border border-gray-200 rounded"))
            
    #         if 'MA_Signal' in selected_technicals:
    #             param_controls.append(html.Div([
    #                 html.H4("Moving Average Parameters", className="text-md font-semibold mb-2"),
    #                 html.Div([
    #                     html.Label("Short MA Period", className="text-xs"),
    #                     dcc.Input(id='bulk-ma-short', type='number', value=20, min=1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Label("Long MA Period", className="text-xs"),
    #                     dcc.Input(id='bulk-ma-long', type='number', value=50, min=1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ])
    #             ], className="mb-4 p-3 border border-gray-200 rounded"))
            
    #         # Add other indicator parameters similarly
    #         if 'RSI_Signal' in selected_technicals:
    #             param_controls.append(html.Div([
    #                 html.H4("RSI Parameters", className="text-md font-semibold mb-2"),
    #                 html.Div([
    #                     html.Label("Period", className="text-xs"),
    #                     dcc.Input(id='bulk-rsi-period', type='number', value=14, min=1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Label("Overbought Level", className="text-xs"),
    #                     dcc.Input(id='bulk-rsi-overbought', type='number', value=70, min=50, max=100,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Label("Oversold Level", className="text-xs"),
    #                     dcc.Input(id='bulk-rsi-oversold', type='number', value=30, min=0, max=50,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ])
    #             ], className="mb-4 p-3 border border-gray-200 rounded"))
            
    #         if 'MACD_Signal' in selected_technicals:
    #             param_controls.append(html.Div([
    #                 html.H4("MACD Parameters", className="text-md font-semibold mb-2"),
    #                 html.Div([
    #                     html.Label("Fast Period", className="text-xs"),
    #                     dcc.Input(id='bulk-macd-fast', type='number', value=12, min=1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Label("Slow Period", className="text-xs"),
    #                     dcc.Input(id='bulk-macd-slow', type='number', value=26, min=1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Label("Signal Period", className="text-xs"),
    #                     dcc.Input(id='bulk-macd-signal', type='number', value=9, min=1,
    #                             className="w-full p-1 border rounded text-sm")
    #                 ])
    #             ], className="mb-4 p-3 border border-gray-200 rounded"))
        
    #     return new_class, param_controls


    def create_bollinger_params():
        """Membuat blok kontrol parameter untuk Bollinger Bands."""
        return html.Div([
            html.H3("Bollinger Bands Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Period", className="text-xs"),
                dcc.Input(id='bb-period', type='number', value=20, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Jumlah periode (bar/hari) untuk menghitung Simple Moving Average (SMA) yang menjadi dasar pita Bollinger.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Standard Deviation", className="text-xs"),
                dcc.Input(id='bb-std', type='number', value=2, min=0.1, step=0.1, className="w-full p-1 border rounded text-sm"),
                html.P("Menentukan lebar pita atas dan bawah berdasarkan berapa deviasi standar dari SMA.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Signal Mode", className="text-xs"),
                dcc.RadioItems(
                    id='bb-signal-mode',
                    options=[
                        {'label': ' Touch Bands (Default)', 'value': 'touch'},
                        {'label': ' Cross Bands (Strict)', 'value': 'cross'}
                    ],
                    value='touch',
                    className="mt-1"
                ),
                html.P("Touch: Sinyal ketika harga menyentuh band. Cross: Sinyal ketika harga menembus band.", className="text-xs text-gray-500 mt-1")
            ])
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_ma_params():
        """Membuat blok kontrol parameter untuk Moving Average."""
        return html.Div([
            html.H3("Moving Average Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Number of MA Lines", className="text-xs"),
                dcc.RadioItems(
                    id='ma-lines-count',
                    options=[
                        {'label': ' 2 Lines (Fast & Slow)', 'value': '2'},
                        {'label': ' 3 Lines (Fast, Medium & Slow)', 'value': '3'}
                    ],
                    value='2',
                    className="mt-1 mb-2"
                ),
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Fast MA Period", className="text-xs"),
                dcc.Input(id='ma-short', type='number', value=20, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode rata-rata bergerak jangka pendek untuk mengukur tren harga yang lebih responsif.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Medium MA Period", className="text-xs"),
                dcc.Input(id='ma-medium', type='number', value=35, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode rata-rata bergerak menengah (hanya untuk mode 3 lines).", className="text-xs text-gray-500 mt-1")
            ], className="mb-2", id='ma-medium-container'),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Slow MA Period", className="text-xs"),
                dcc.Input(id='ma-long', type='number', value=50, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode rata-rata bergerak jangka panjang untuk mengidentifikasi tren jangka lebih luas dan mengurangi noise.", className="text-xs text-gray-500 mt-1")
            ])
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_rsi_params():
        """Membuat blok kontrol parameter untuk RSI."""
        return html.Div([
            html.H3("RSI Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Period", className="text-xs"),
                dcc.Input(id='rsi-period', type='number', value=14, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Jumlah periode untuk menghitung Relative Strength Index (RSI), biasanya 14 hari.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Overbought Level", className="text-xs"),
                dcc.Input(id='rsi-overbought', type='number', value=70, min=50, max=100, className="w-full p-1 border rounded text-sm"),
                html.P("Tingkat di atasnya dianggap overbought; potensi pembalikan turun.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Oversold Level", className="text-xs"),
                dcc.Input(id='rsi-oversold', type='number', value=30, min=0, max=50, className="w-full p-1 border rounded text-sm"),
                html.P("Tingkat di bawahnya dianggap oversold; potensi pembalikan naik.", className="text-xs text-gray-500 mt-1")
            ])
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_macd_params():
        """Membuat blok kontrol parameter untuk MACD."""
        return html.Div([
            html.H3("MACD Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Fast Period", className="text-xs"),
                dcc.Input(id='macd-fast', type='number', value=12, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode EMA cepat; respon lebih cepat terhadap perubahan harga.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Slow Period", className="text-xs"),
                dcc.Input(id='macd-slow', type='number', value=26, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode EMA lambat; membantu meredam noise dan mengonfirmasi tren.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Signal Period", className="text-xs"),
                dcc.Input(id='macd-signal', type='number', value=9, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode EMA untuk garis sinyal yang memicu sinyal beli/jual.", className="text-xs text-gray-500 mt-1")
            ])
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_adx_params():
        """Membuat blok kontrol parameter untuk ADX."""
        return html.Div([
            html.H3("ADX Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Period", className="text-xs"),
                dcc.Input(id='adx-period', type='number', value=14, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Jumlah periode untuk menghitung Average Directional Index (ADX) mengukur kekuatan tren.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Hr(className="my-2 border-gray-300"),
            html.Div([
                html.Label("Threshold", className="text-xs"),
                dcc.Input(id='adx-threshold', type='number', value=25, min=0, max=100, className="w-full p-1 border rounded text-sm"),
                html.P("Nilai ADX di atas threshold menunjukkan tren yang kuat.", className="text-xs text-gray-500 mt-1")
            ])
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_volume_params():
        """Membuat blok kontrol parameter untuk Volume."""
        return html.Div([
            html.H3("Volume Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("MA Period", className="text-xs"),
                dcc.Input(id='volume-period', type='number', value=20, min=1, className="w-full p-1 border rounded text-sm"),
                html.P("Periode rata-rata untuk menghitung rata-rata volume sebagai indikator konfirmasi tren.", className="text-xs text-gray-500 mt-1")
            ])
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_fibonacci_params():
        """Membuat blok kontrol parameter untuk Fibonacci Retracement."""
        return html.Div([
            html.H3("Fibonacci Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Lookback Period", className="text-xs"),
                dcc.Input(id='fibonacci-lookback', type='number', value=60, min=10, className="w-full p-1 border rounded text-sm"),
                html.P("Jumlah bar/hari terakhir untuk mencari high/low Fibonacci.", className="text-xs text-gray-500 mt-1")
            ], className="mb-2")
        ], className="border border-gray-200 rounded p-4 my-4")

    def create_candlestick_params():
        """Membuat blok kontrol parameter untuk Candlestick Patterns."""
        return html.Div([
            html.H3("Candlestick Pattern Parameters", className="text-sm font-semibold mb-2"),
            html.Div([
                html.Label("Confidence Threshold", className="text-xs"),
                dcc.Slider(
                    id='candlestick-confidence', min=0, max=100, step=5, value=50,
                    marks={i: f'{i}%' for i in range(0, 101, 25)}, className="w-full"
                ),
                html.P("Minimum confidence level required for candlestick signals (higher values mean fewer but stronger signals).", className="text-xs text-gray-500 mt-1")
            ], className="mb-2"),
            html.Div([
                html.Label("Pattern Categories", className="text-xs"),
                dcc.Checklist(
                    id='candlestick-categories',
                    options=[
                        {'label': ' Reversal Patterns', 'value': 'reversal'},
                        {'label': ' Continuation Patterns', 'value': 'continuation'},
                        {'label': ' Indecision Patterns', 'value': 'indecision'}
                    ],
                    value=['reversal', 'continuation'],
                    className="space-y-1"
                ),
                html.P("Select which types of candlestick patterns to include in analysis.", className="text-xs text-gray-500 mt-1")
            ]),
        ], className="border border-gray-200 rounded p-4 my-4")


    # ==============================================================================
    # 2. KAMUS PEMETAAN (MAPPING DICTIONARY)
    # ==============================================================================
    # Kamus ini menghubungkan nilai dari dropdown (selected_technicals) ke fungsi 
    # yang membuat komponen UI yang sesuai.
    # **Catatan**: Kunci di sini harus sama persis dengan 'value' di opsi dcc.Dropdown Anda.
    # Saya berasumsi kunci-kunci baru akan mengikuti pola yang sama (misalnya, 'ADX_Signal').

    PARAM_GENERATORS = {
        'Bollinger_Signal': create_bollinger_params,
        'MA_Signal': create_ma_params,
        'RSI_Signal': create_rsi_params,
        'MACD_Signal': create_macd_params,
        'ADX_Signal': create_adx_params,          # Asumsi kunci untuk ADX
        'Volume_Signal': create_volume_params,     # Asumsi kunci untuk Volume
        'Fibonacci_Signal': create_fibonacci_params, # Asumsi kunci untuk Fibonacci
        'Candlestick_Signal': create_candlestick_params # Asumsi kunci untuk Candlestick
    }


    # ==============================================================================
    # 3. FUNGSI CALLBACK UTAMA YANG DIPERBARUI
    # ==============================================================================

    @app.callback(
        [Output("advanced-params-content", "className"),
        Output("advanced-params-content", "children")],
        [Input("advanced-params-toggle", "n_clicks")],
        [State("advanced-params-content", "className"),
        State("bulk-technical-checklist", "value")]
    )
    def toggle_advanced_parameters(n_clicks, current_class, selected_technicals):
        """Toggle advanced parameters and generate UI based on selected indicators"""
        if not n_clicks:
            return "hidden mt-4", []
        
        # Show/hide based on current state
        new_class = "mt-4" if "hidden" in current_class else "hidden mt-4"
        
        # If hiding, return empty children
        if "hidden" not in current_class:
            return new_class, []
        
        # Generate parameter controls based on selected indicators
        param_controls = []
        if selected_technicals:
            for tech_signal in selected_technicals:
                if tech_signal in PARAM_GENERATORS:
                    generator_function = PARAM_GENERATORS[tech_signal]
                    param_controls.append(generator_function())
        
        if not param_controls:
            param_controls = [html.P("No parameters to configure for the selected indicators.", 
                                    className="text-sm text-gray-500")]
        
        return new_class, param_controls



    def parse_advanced_parameters(advanced_params_content, selected_technicals):
        """Parse parameters from advanced parameters UI content"""
        
        # Set default parameters first
        params = {
            'bb_period': 20,
            'bb_std': 2,
            'bb_signal_mode': 'touch',
            'ma_short': 20,
            'ma_long': 50,
            'ma_medium': 35,
            'ma_lines_count': '2',
            'rsi_period': 14,
            'rsi_overbought': 70,
            'rsi_oversold': 30,
            'macd_fast': 12,
            'macd_slow': 26,
            'macd_signal': 9,
            'adx_period': 14,
            'adx_threshold': 25,
            'volume_period': 20,
            'fibonacci_lookback': 60,
            'candlestick_confidence': 50,
            'candlestick_categories': ['reversal', 'continuation']
        }
        
        print(f"ðŸ”§ Parsing advanced parameters for indicators: {selected_technicals}")
        print(f"ðŸ“‹ Advanced params content type: {type(advanced_params_content)}")
        
        if not advanced_params_content:
            print("âš ï¸ No advanced parameters content, using defaults")
            return params
        
        try:
            # Extract parameter values from the UI components
            params_found = extract_parameters_from_components(advanced_params_content)
            
            # Update default params with found values
            for key, value in params_found.items():
                if value is not None:
                    params[key] = value
                    print(f"âœ… Updated parameter {key} = {value}")
            
            print(f"ðŸŽ¯ Final parameters: {params}")
            return params
            
        except Exception as e:
            print(f"âŒ Error parsing parameters: {e}")
            traceback.print_exc()
            return params

    def extract_parameters_from_components(components):
        """Extract parameter values from Dash components recursively"""
        params = {}
        
        if not components:
            return params
        
        try:
            # Handle list of components
            if isinstance(components, list):
                for component in components:
                    extracted = extract_parameters_from_components(component)
                    params.update(extracted)
            
            # Handle dict (component)
            elif isinstance(components, dict):
                # Check if this is an Input component with an ID we care about
                if 'props' in components:
                    props = components['props']
                    
                    # Extract ID and value
                    component_id = props.get('id', '')
                    component_value = props.get('value', None)
                    
                    # Map component IDs to parameter names
                    id_to_param = {
                        'bb-period': 'bb_period',
                        'bb-std': 'bb_std',
                        'bb-signal-mode': 'bb_signal_mode',
                        'ma-short': 'ma_short',
                        'ma-long': 'ma_long',
                        'ma-medium': 'ma_medium',
                        'ma-lines-count': 'ma_lines_count',
                        'rsi-period': 'rsi_period',
                        'rsi-overbought': 'rsi_overbought',
                        'rsi-oversold': 'rsi_oversold',
                        'macd-fast': 'macd_fast',
                        'macd-slow': 'macd_slow',
                        'macd-signal': 'macd_signal',
                        'adx-period': 'adx_period',
                        'adx-threshold': 'adx_threshold',
                        'volume-period': 'volume_period',
                        'fibonacci-lookback': 'fibonacci_lookback',
                        'candlestick-confidence': 'candlestick_confidence',
                        'candlestick-categories': 'candlestick_categories'
                    }
                    
                    if component_id in id_to_param and component_value is not None:
                        param_name = id_to_param[component_id]
                        
                        # Convert value to appropriate type
                        if param_name in ['bb_signal_mode', 'ma_lines_count']:
                            params[param_name] = str(component_value)
                        elif param_name == 'candlestick_categories':
                            params[param_name] = component_value if isinstance(component_value, list) else [component_value]
                        else:
                            # Convert to number
                            try:
                                params[param_name] = float(component_value) if '.' in str(component_value) else int(component_value)
                            except (ValueError, TypeError):
                                params[param_name] = component_value
                        
                        print(f"ðŸ” Found parameter: {param_name} = {params[param_name]} (from {component_id})")
                
                # Recursively search in children
                if 'props' in components and 'children' in components['props']:
                    children_params = extract_parameters_from_components(components['props']['children'])
                    params.update(children_params)
            
            return params
            
        except Exception as e:
            print(f"âŒ Error in extract_parameters_from_components: {e}")
            return params



    def calculate_signal_pairs_statistics(individual_pairs_data, combination_pairs_data):
        """
        Menghitung statistik komprehensif dari data signal pairs.
        
        Args:
            individual_pairs_data (dict): Dictionary {indicator_name: [list_of_trades]}
            combination_pairs_data (dict): Dictionary {indicator_name: [list_of_trades]}

        Returns:
            dict: Dictionary berisi statistik untuk individual, combination, dan overall.
        """
        
        def get_stats_from_group(group_data):
            """Helper function untuk menghitung statistik dari sekelompok indikator."""
            if not group_data:
                return {
                    'count': 0, 'total_trades': 0, 'avg_profit': 0.0, 'avg_win_rate': 0.0,
                    'best_profit': 0.0, 'worst_profit': 0.0, 'best_indicator': 'N/A', 'worst_indicator': 'N/A'
                }

            profits = []
            win_rates = []
            total_trades = 0
            indicator_performance = []

            for indicator, trades in group_data.items():
                if not trades:
                    continue
                
                num_trades = len(trades)
                total_trades += num_trades
                
                total_profit_pct = sum(trade['profit_pct'] for trade in trades)
                avg_profit_for_indicator = total_profit_pct / num_trades
                
                winning_trades = len([trade for trade in trades if trade['profit_pct'] > 0])
                win_rate = (winning_trades / num_trades) * 100 if num_trades > 0 else 0
                
                profits.append(avg_profit_for_indicator)
                win_rates.append(win_rate)
                indicator_performance.append({
                    'indicator': indicator,
                    'profit': avg_profit_for_indicator
                })

            if not indicator_performance:
                return get_stats_from_group(None) # Return empty stats if no trades found

            best_performer = max(indicator_performance, key=lambda x: x['profit'])
            worst_performer = min(indicator_performance, key=lambda x: x['profit'])
            
            return {
                'count': len(indicator_performance),
                'total_trades': total_trades,
                'avg_profit': np.mean(profits) if profits else 0.0,
                'avg_win_rate': np.mean(win_rates) if win_rates else 0.0,
                'best_profit': best_performer['profit'],
                'worst_profit': worst_performer['profit'],
                'best_indicator': best_performer['indicator'],
                'worst_indicator': worst_performer['indicator']
            }

        individual_stats = get_stats_from_group(individual_pairs_data)
        combination_stats = get_stats_from_group(combination_pairs_data)

        # Menghitung statistik keseluruhan
        all_data = {**individual_pairs_data, **combination_pairs_data}
        overall_stats = get_stats_from_group(all_data)

        return {
            'individual_stats': individual_stats,
            'combination_stats': combination_stats,
            'overall_stats': overall_stats
        }

    
    def count_signals_per_indicator(df):
        """
        Menghitung jumlah sinyal 'Buy', 'Sell', dan 'Hold' untuk setiap kolom sinyal dalam DataFrame.

        Args:
            df (pd.DataFrame): DataFrame yang berisi kolom-kolom sinyal (e.g., 'RSI_Signal').

        Returns:
            dict: Dictionary berisi hasil perhitungan. 
                Contoh: {'RSI': {'Buy': 10, 'Sell': 8, 'Hold': 232}, ...}
        """
        signal_counts = {}
        signal_columns = [col for col in df.columns if col.endswith('_Signal')]

        for col in signal_columns:
            # Menghitung nilai unik dan jumlahnya. Lebih cepat daripada iterasi.
            counts = df[col].value_counts().to_dict()
            
            # Standarisasi hasil
            buy_count = int(counts.get('Buy', 0))
            sell_count = int(counts.get('Sell', 0))
            
            # 'Hold' bisa jadi tidak ada secara eksplisit, bisa dihitung dari sisa baris
            # atau kita asumsikan 'Hold' adalah semua yang bukan 'Buy' atau 'Sell'.
            total_rows = len(df)
            hold_count = total_rows - (buy_count + sell_count)
            
            # Ambil nama dasar indikator
            indicator_name = col.replace('_Signal', '')
            
            signal_counts[indicator_name] = {
                'Buy': buy_count,
                'Sell': sell_count,
                'Hold': hold_count,
                'TotalData': total_rows
            }
            
        return signal_counts


    # MAIN BULK ANALYSIS CALLBACK new

    @app.callback(
        [Output("bulk-loading-output", "children"),
        Output("bulk-results-container", "className"),
        Output("backtesting-analysis-content", "children"),
        # Output("backtesting-profit-content", "children"),
        # Output("analysis-leaderboard", "children"),
        # Output("profit-leaderboard", "children"),
        Output("raw-data-explorer", "children"),
        Output("stored-results", "data")],
        [Input("run-bulk-analysis", "n_clicks")],
        [State("bulk-ticker-dropdown", "value"),
        State("bulk-technical-checklist", "value"),
        State("bulk-capital-input", "value"),
        State("bulk-start-year-dropdown", "value"),
        State("bulk-start-month-dropdown", "value"),
        State("bulk-start-day-dropdown", "value"),
        State("bulk-end-year-dropdown", "value"),
        State("bulk-end-month-dropdown", "value"),
        State("bulk-end-day-dropdown", "value"),
        State("advanced-params-content", "children")]
    )
    def run_bulk_analysis(n_clicks, selected_tickers, selected_technicals, capital,
                      start_year, start_month, start_day,
                      end_year, end_month, end_day,
                      advanced_params_content):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate

        if not selected_tickers or not selected_technicals:
            return html.Div("Please select at least one ticker and one technical indicator.",
                            className="p-4 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded"), \
                "hidden", None, None, None, None, None, None

        try:
            # FASE 1: PERSIAPAN PARAMETER DAN KONTAINER DATA (Tidak ada perubahan signifikan)
            print(f"ðŸš€ Starting bulk analysis for {len(selected_tickers)} tickers with {len(selected_technicals)} indicators")
            params = parse_advanced_parameters(advanced_params_content, selected_technicals)
            start_date = pd.Timestamp(year=start_year, month=start_month, day=start_day)
            end_date = pd.Timestamp(year=end_year, month=end_month, day=end_day)

            analysis_params = {
                'selected_tickers': selected_tickers,
                'selected_indicators': selected_technicals,
                'capital': float(capital),
                'date_range': {'start': start_date.strftime('%Y-%m-%d'), 'end': end_date.strftime('%Y-%m-%d')},
                'advanced_params': params,
                'analysis_timestamp': datetime.now().isoformat()
            }

            all_results_ui = {'leaderboard': [], 'ticker_details': {}, 'trade_details': {}}
            raw_data_with_signals = {}
            individual_results_db = []
            combination_results_db = []
            different_combination_results_db = [] # Ini akan menjadi sumber kebenaran kita
            all_signal_pairs_profit_db = {}
            all_signal_counts_db = {}

            # FASE 2: PROSES ANALISIS INTI (LOOP PER TICKER)
            for ticker in selected_tickers:
                print(f"\nðŸ“Š Processing ticker: {ticker}")
                ticker_data = fetch_ticker_data(ticker, start_date, end_date)
                if ticker_data.empty:
                    print(f"âš ï¸ WARNING: No data retrieved for {ticker}, skipping")
                    continue

                ticker_data_with_tech = apply_technical_indicators(ticker_data.copy(), selected_technicals, **params)
                
                # BLOK C: KALKULASI JUMLAH SINYAL (Tidak ada perubahan)
                print(f"   [BLOK C] Counting all signals for {ticker}...")
                signal_counts_for_ticker = count_signals_per_indicator(ticker_data_with_tech)
                all_signal_counts_db[ticker] = signal_counts_for_ticker
                print(f"   [BLOK C] âœ… Signal counts calculated.")

                # Simpan data mentah
                df_cleaned = ticker_data_with_tech.replace([np.inf, -np.inf], np.nan)
                df_sanitized = df_cleaned.where(pd.notnull(df_cleaned), None)
                df_for_store = df_sanitized.copy()
                if 'Datetime' in df_for_store.columns:
                    df_for_store['Datetime'] = pd.to_datetime(df_for_store['Datetime']).dt.strftime('%Y-%m-%d %H:%M:%S')
                raw_data_with_signals[ticker] = df_for_store.to_dict('records')

                # BLOK A: KALKULASI RINGKASAN BACKTESTING (Tidak ada perubahan)
                print(f"   [BLOK A] Calculating backtesting summaries for {ticker}...")
                ticker_results_list = []
                
                # Backtest Individual
                for indicator in selected_technicals:
                    result = run_backtest_for_indicator(ticker_data_with_tech, indicator, float(capital))
                    if result:
                        result_full = {'ticker': ticker, 'indicator': indicator, **result}
                        ticker_results_list.append(result_full)
                        individual_results_db.append(result_full)
                        all_results_ui['leaderboard'].append({'ticker': ticker, 'indicator': indicator, 'profit_percentage': result.get('profit_percentage', 0), 'total_profit': result.get('total_profit',0), 'win_rate': result.get('win_rate',0), 'num_trades': result.get('num_trades',0)})
                
                # Backtest Gabungan
                combined_signal_cols = [c for c in ticker_data_with_tech.columns if c.endswith('_Combined_Signal')]
                for combined_signal in combined_signal_cols:
                    result = run_backtest_for_indicator(ticker_data_with_tech, combined_signal, float(capital))
                    if result:
                        result_full = {'ticker': ticker, 'indicator': combined_signal, **result}
                        ticker_results_list.append(result_full)
                        combination_results_db.append(result_full)
                        all_results_ui['leaderboard'].append({'ticker': ticker, 'indicator': combined_signal, 'profit_percentage': result.get('profit_percentage', 0), 'total_profit': result.get('total_profit',0), 'win_rate': result.get('win_rate',0), 'num_trades': result.get('num_trades',0)})

                if ticker_results_list:
                    all_results_ui['ticker_details'][ticker] = ticker_results_list
                    all_results_ui['trade_details'][ticker] = {res['indicator']: res.get('trades', []) for res in ticker_results_list}
                print(f"   [BLOK A] âœ… Backtesting summaries calculated.")

                # BLOK B: KALKULASI DETAIL SIGNAL PAIRS (Tidak ada perubahan)
                print(f"   [BLOK B] Calculating detailed signal pairs and statistics for {ticker}...")
        
                # 1. Kumpulkan semua data pairs mentah
                individual_pairs_raw = {}
                combination_pairs_raw = {}
                
                all_signal_columns = [col for col in ticker_data_with_tech.columns if col.endswith('_Signal')]

                for signal_col in all_signal_columns:
                    # Panggil fungsi helper yang andal
                    pairs, _, _ = calculate_signal_pairs_profit(ticker_data_with_tech, signal_col)
                    if not pairs:
                        continue

                    # Kategorikan sebagai 'individual' atau 'combination'
                    if signal_col.endswith('_Combined_Signal'):
                        indicator_name = signal_col
                        combination_pairs_raw[indicator_name] = pairs
                    else:
                        indicator_name = signal_col.replace('_Signal', '')
                        individual_pairs_raw[indicator_name] = pairs
                
                total_pairs_found = sum(len(p) for p in individual_pairs_raw.values()) + sum(len(p) for p in combination_pairs_raw.values())
                print(f"   [BLOK B] Raw pairs collected. Found {len(individual_pairs_raw)} individual and {len(combination_pairs_raw)} combination sets. Total pairs: {total_pairs_found}")

                # 2. Hitung statistik komprehensif
                comprehensive_summary = calculate_signal_pairs_statistics(
                    individual_pairs_raw, 
                    combination_pairs_raw
                )
                print(f"   [BLOK B] âœ… Comprehensive statistics calculated for {ticker}.")

                # 3. Bangun struktur data akhir untuk disimpan di database
                ticker_signal_pairs_final = {
                    'individual': individual_pairs_raw,
                    'combination': combination_pairs_raw,
                    'summary': comprehensive_summary
                }
                
                # 4. Simpan hasil akhir ke dalam kontainer utama
                all_signal_pairs_profit_db[ticker] = ticker_signal_pairs_final
                print(f"   [BLOK B] âœ… Final signal pairs data structure for {ticker} is ready.")
                
                # =======================================================================================
                # BLOK D: ANALISIS KOMBINASI INDIKATOR BERBEDA (BUY/SELL TERPISAH)
                # Ini adalah kalkulasi "sumber kebenaran".
                # =======================================================================================
                print(f"\n   [BLOK D - PREP] Aggregating signals from all tickers for combined analysis...")
                processed_data_for_combinations = []
                for ticker in selected_tickers:
                    if ticker in raw_data_with_signals:
                        ticker_df_records = raw_data_with_signals[ticker]
                        # Pastikan ada data dan kolomnya
                        if not ticker_df_records: continue
                        all_signal_cols_for_diff_combo = [col for col in ticker_df_records[0].keys() if col.endswith('_Signal')]

                        for record in ticker_df_records:
                            for signal_col in all_signal_cols_for_diff_combo:
                                if record.get(signal_col) in ['Buy', 'Sell']:
                                    processed_data_for_combinations.append({
                                        'Title': ticker,
                                        'Analysis_info': signal_col,
                                        'Signal': record[signal_col],
                                        'Datetime': pd.to_datetime(record['Datetime']),
                                        'Price': record['Close'],
                                        'Volume': record.get('Volume', 0)
                                    })
                
                print(f"   [BLOK D - PREP] âœ… Aggregated {len(processed_data_for_combinations)} raw signals.")

                # =======================================================================================
                # Langkah 2: Panggil fungsi analisis HANYA SATU KALI dengan batas global.
                # =======================================================================================
                different_combination_results_db = [] # Pastikan list ini kosong sebelum diisi
                if processed_data_for_combinations:
                    print(f"   [BLOK D - EXEC] Analyzing different buy/sell indicator combinations (with global limit)...")
                    
                    # Panggil fungsi yang sudah dioptimalkan hanya satu kali
                    different_combination_results_db = analyze_indicator_combinations(
                        processed_data_for_combinations, {}, {}
                    )
                    print(f"   [BLOK D - EXEC] âœ… Found {len(different_combination_results_db)} 'different combination' strategies.")

            print(f"\nðŸŽ¯ Analysis completed for {len(all_results_ui['ticker_details'])} tickers.")
            all_results_ui['leaderboard'].sort(key=lambda x: x.get('profit_percentage', 0), reverse=True)
            
            # <<<--- PERUBAHAN KUNCI 1: Tambahkan hasil kalkulasi ke `all_results_ui` ---<<<
            # Ini akan diteruskan ke fungsi UI untuk ditampilkan, tanpa perlu kalkulasi ulang.
            all_results_ui['different_combination_results'] = different_combination_results_db
            print(f"ðŸ“¦ Packed {len(different_combination_results_db)} 'different combination' results for UI display.")

            # FASE 3: PENYIMPANAN KE DATABASE
            print("\nðŸ’¾ Saving analysis results to database...")
            saved_to_db = False
            try:
                # <<<--- PERUBAHAN KUNCI 2: Perbaiki bug variabel untuk penyimpanan DB ---<<<
                # Gunakan `different_combination_results_db` (global) bukan `_for_ticker` (lokal loop).
                saved_result = save_bulk_analysis_to_database(
                    tickers=selected_tickers,
                    analysis_params=analysis_params,
                    raw_data_with_signals=raw_data_with_signals,
                    individual_results=individual_results_db,
                    combination_results=combination_results_db,
                    different_combination_results=different_combination_results_db, # FIX: Gunakan variabel yang benar
                    all_results_ui=all_results_ui,
                    all_signal_pairs_profit=all_signal_pairs_profit_db,
                    all_signal_counts=all_signal_counts_db
                )
                saved_to_db = bool(saved_result)
                if saved_to_db:
                    print("âœ… Database save operation completed successfully.")
                else:
                    print("âš ï¸ Database save operation failed. Check logs for details.")
            except Exception as db_error:
                print(f"âŒ Critical error during database save call: {db_error}")
                traceback.print_exc()




            # FASE 4: PEMBUATAN KOMPONEN UI
            print("ðŸŽ¨ Generating UI components...")

            backtesting_analysis = generate_backtesting_analysis_results(all_results_ui)
            
            combined_signals_summary = []
            for ticker in selected_tickers:
                if ticker in raw_data_with_signals:
                    ticker_df = pd.DataFrame(raw_data_with_signals[ticker])
                    if 'Datetime' in ticker_df.columns:
                        ticker_df['Datetime'] = pd.to_datetime(ticker_df['Datetime'])
                    ticker_summary = create_enhanced_combined_signal_summary(ticker_df, selected_technicals)
                    for summary in ticker_summary:
                        summary['Ticker'] = ticker
                    combined_signals_summary.extend(ticker_summary)

            backtesting_analysis = generate_backtesting_analysis_results(all_results_ui)
            backtesting_profit = generate_backtesting_profit_results(all_results_ui)
            analysis_leaderboard_content = create_enhanced_leaderboard(all_results_ui['leaderboard'], combined_signals_summary)
            profit_leaderboard_content = create_profit_leaderboard(all_results_ui)
            raw_data_content = create_raw_data_explorer(raw_data_with_signals)
            
            # Siapkan data lengkap untuk disimpan di dcc.Store
            stored_data = {
                'analysis_params': analysis_params,
                'raw_data_with_signals': raw_data_with_signals,
                'individual_results': individual_results_db,
                'combination_results': combination_results_db,
                'different_combination_results': different_combination_results_db, # Tambahkan ini
                'all_results_ui': all_results_ui,
                'saved_to_database': saved_to_db
            }
            
            # Buat pesan status yang informatif untuk ditampilkan di UI
            success_message = html.Div([
                html.H3("âœ… Analysis Completed!", className="text-lg font-bold text-green-600 mb-2"),
                html.P(f"Processed {len(all_results_ui['ticker_details'])} of {len(selected_tickers)} selected tickers."),
                html.P(f"Found {len(individual_results_db)} individual and {len(combination_results_db)} combined strategies."),
                html.P(f"Database Save Status: {'âœ… Success' if saved_to_db else 'âš ï¸ Failed'}", className="font-bold mt-1"),
            ], className="p-4 bg-green-50 border border-green-200 rounded mb-4")

            return (
                success_message,
                "p-6 bg-white rounded shadow",
                backtesting_analysis,
                # backtesting_profit,
                # analysis_leaderboard_content,
                # profit_leaderboard_content,
                raw_data_content,
                stored_data
            )

        # FASE 5: PENANGANAN ERROR GLOBAL
        except Exception as e:
            print(f"âŒ A critical error occurred in bulk analysis: {e}")
            traceback.print_exc()
            error_msg_div = html.Div([
                html.H3("âŒ Analysis Failed", className="text-lg font-bold text-red-600 mb-2"),
                html.P(f"An unexpected error occurred: {str(e)}"),
                html.Details([
                    html.Summary("Show Error Details", className="cursor-pointer text-blue-600 mt-2"),
                    html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs mt-2 overflow-auto")
                ])
            ], className="p-4 bg-red-50 border border-red-200 rounded mb-4")
            
            return error_msg_div, "hidden", None, None, None, None, None, None








    # @app.callback(
    #     [Output("bulk-loading-output", "children"),
    #     Output("bulk-results-container", "className"),
    #     Output("backtesting-analysis-content", "children"),
    #     Output("backtesting-profit-content", "children"),
    #     Output("analysis-leaderboard", "children"),
    #     Output("profit-leaderboard", "children"),
    #     Output("raw-data-explorer", "children"),
    #     Output("stored-results", "data")],  
    #     [Input("run-bulk-analysis", "n_clicks")],
    #     [State("bulk-ticker-dropdown", "value"),
    #     State("bulk-technical-checklist", "value"),
    #     State("bulk-capital-input", "value"),
    #     State("bulk-start-year-dropdown", "value"),
    #     State("bulk-start-month-dropdown", "value"),
    #     State("bulk-start-day-dropdown", "value"),
    #     State("bulk-end-year-dropdown", "value"),
    #     State("bulk-end-month-dropdown", "value"),
    #     State("bulk-end-day-dropdown", "value"),
    #     State("advanced-params-content", "children")]
    # )
    # def run_bulk_analysis(n_clicks, selected_tickers, selected_technicals, capital,
    #                     start_year, start_month, start_day,
    #                     end_year, end_month, end_day,
    #                     advanced_params_content):
    #     if not n_clicks:
    #         raise dash.exceptions.PreventUpdate
        
    #     if not selected_tickers or not selected_technicals:
    #         return "Please select at least one ticker and one technical indicator", "hidden", None, None, None, None, None, None
        
    #     print(f"=== Starting bulk analysis with {len(selected_tickers)} ticker(s) and {len(selected_technicals)} indicator(s) ===")
        
    #     # # Set default parameters
    #     # params = {
    #     #     'bb_period': 20,
    #     #     'bb_std': 2,
    #     #     'ma_short': 20,
    #     #     'ma_long': 50,
    #     #     'rsi_period': 14,
    #     #     'rsi_overbought': 70,
    #     #     'rsi_oversold': 30,
    #     #     'macd_fast': 12,
    #     #     'macd_slow': 26,
    #     #     'macd_signal': 9
    #     # }

    #     params = parse_advanced_parameters(advanced_params_content, selected_technicals)
    
    #     print(f"ðŸ“‹ Using parameters: {params}")

        
    #     try:
    #         # Create date range
    #         start_date = pd.Timestamp(year=start_year, month=start_month, day=start_day)
    #         end_date = pd.Timestamp(year=end_year, month=end_month, day=end_day)
            
    #         # Dictionary to store all results
    #         all_results = {
    #             'leaderboard': [],
    #             'ticker_details': {},
    #             'trade_details': {},
    #             'raw_data': {},
    #             'technical_data': {}  # TAMBAHKAN untuk menyimpan data dengan technical analysis
    #         }
            
    #         # Process each ticker
    #         for ticker in selected_tickers:
    #             print(f"\n=== Processing ticker {ticker} ===")
    #             # Get data for this ticker
    #             ticker_data = fetch_ticker_data(ticker, start_date, end_date)
                
    #             if ticker_data.empty:
    #                 print(f"WARNING: No data retrieved for {ticker}, skipping")
    #                 continue
                
    #             print(f"Successfully loaded {len(ticker_data)} rows for {ticker}")
                
    #             # Apply technical indicators with custom parameters
    #             print(f"Applying technical indicators to {ticker} with params: {params}")
    #             ticker_data_with_tech = apply_technical_indicators(
    #                 ticker_data.copy(), 
    #                 selected_technicals,
    #                 **params
    #             )
                
    #             # Store data with technical analysis untuk raw data explorer
    #             ticker_data_store = ticker_data_with_tech.copy()
    #             if 'Datetime' in ticker_data_store.columns:
    #                 ticker_data_store['Datetime'] = ticker_data_store['Datetime'].dt.strftime('%Y-%m-%d %H:%M:%S')
                
    #             all_results['technical_data'][ticker] = ticker_data_store.to_dict('records')
                
    #             # Also store raw data tanpa technical analysis untuk keperluan lain
    #             ticker_data_raw = ticker_data.copy()
    #             if 'Datetime' in ticker_data_raw.columns:
    #                 ticker_data_raw['Datetime'] = ticker_data_raw['Datetime'].dt.strftime('%Y-%m-%d %H:%M:%S')
    #             all_results['raw_data'][ticker] = ticker_data_raw.to_dict('records')
                
    #             # Run backtest for each indicator (individual signals)
    #             ticker_results = []
    #             for indicator in selected_technicals:
    #                 if indicator in ticker_data_with_tech.columns:
    #                     indicator_result = run_backtest_for_indicator(
    #                         ticker_data_with_tech, 
    #                         indicator, 
    #                         float(capital)
    #                     )
                        
    #                     if indicator_result:
    #                         ticker_results.append({
    #                             'ticker': ticker,
    #                             'indicator': indicator,
    #                             'initial_capital': indicator_result['initial_capital'],
    #                             'final_capital': indicator_result['final_capital'],
    #                             'total_profit': indicator_result['total_profit'],
    #                             'profit_percentage': indicator_result['profit_percentage'],
    #                             'num_trades': indicator_result['num_trades'],
    #                             'win_rate': indicator_result['win_rate'],
    #                             'trades': indicator_result['trades'],
    #                             'volume_analysis_summary': indicator_result.get('volume_analysis_summary', 'N/A'),
    #                             # FIX: Tambahkan kunci ini untuk membawa data log detail
    #                             'all_possible_combinations': indicator_result.get('all_possible_combinations', [])
    #                         })
                            
    #                         all_results['leaderboard'].append({
    #                             'ticker': ticker,
    #                             'indicator': indicator,
    #                             'profit_percentage': indicator_result['profit_percentage'],
    #                             'total_profit': indicator_result['total_profit'],
    #                             'win_rate': indicator_result['win_rate'],
    #                             'num_trades': indicator_result['num_trades']
    #                         })
                
    #             # Run backtest for all combined signals (voting system)
    #             combined_signal_columns = [col for col in ticker_data_with_tech.columns 
    #                     if col.endswith('_Combined_Signal')]

    #             print(f"ðŸ—³ï¸ Found {len(combined_signal_columns)} combined signal columns for backtesting:")
    #             for col in combined_signal_columns:
    #                 print(f"   ðŸ“Š {col}")

    #             for combined_signal in combined_signal_columns:
    #                 print(f"ðŸ”„ Running backtest for {combined_signal}...")
    #                 combined_result = run_backtest_for_indicator(
    #                     ticker_data_with_tech,
    #                     combined_signal,
    #                     float(capital)
    #                 )
                    
    #                 if combined_result:
    #                     ticker_results.append({
    #                         'ticker': ticker,
    #                         'indicator': combined_signal,
    #                         'initial_capital': combined_result['initial_capital'],
    #                         'final_capital': combined_result['final_capital'],
    #                         'total_profit': combined_result['total_profit'],
    #                         'profit_percentage': combined_result['profit_percentage'],
    #                         'num_trades': combined_result['num_trades'],
    #                         'win_rate': combined_result['win_rate'],
    #                         'trades': combined_result['trades'],
    #                         'volume_analysis_summary': combined_result.get('volume_analysis_summary', 'N/A'),
    #                         # FIX: Tambahkan kunci ini juga di sini untuk konsistensi
    #                         'all_possible_combinations': combined_result.get('all_possible_combinations', [])
    #                     })
                        
    #                     all_results['leaderboard'].append({
    #                         'ticker': ticker,
    #                         'indicator': combined_signal,
    #                         'profit_percentage': combined_result['profit_percentage'],
    #                         'total_profit': combined_result['total_profit'],
    #                         'win_rate': combined_result['win_rate'],
    #                         'num_trades': combined_result['num_trades'],
    #                     })
                        
    #                     print(f"âœ… {combined_signal}: {combined_result['profit_percentage']:.2f}% return, {combined_result['num_trades']} trades")
                
    #             # Store ticker results
    #             if ticker_results:
    #                 all_results['ticker_details'][ticker] = ticker_results
                
    #             # Store trade details
    #             all_results['trade_details'][ticker] = {}
    #             for result in ticker_results:
    #                 all_results['trade_details'][ticker][result['indicator']] = result['trades']
            
    #         # Sort leaderboard by profit percentage
    #         all_results['leaderboard'].sort(key=lambda x: x['profit_percentage'], reverse=True)


    #         combined_signals_summary = []
    
    #         for ticker in selected_tickers:
    #             if ticker in all_results['technical_data']:
    #                 ticker_df = pd.DataFrame(all_results['technical_data'][ticker])
                    
    #                 # Convert datetime back for analysis
    #                 if 'Datetime' in ticker_df.columns:
    #                     ticker_df['Datetime'] = pd.to_datetime(ticker_df['Datetime'])
                    
    #                 # Create summary for this ticker
    #                 ticker_summary = create_enhanced_combined_signal_summary(ticker_df, selected_technicals)
                    
    #                 # Add ticker info to each summary
    #                 for summary in ticker_summary:
    #                     summary['Ticker'] = ticker
    #                     combined_signals_summary.append(summary)
    
            
    #         # Generate specialized results for each backtesting method
    #         backtesting_analysis = generate_backtesting_analysis_results(all_results)
    #         backtesting_profit = generate_backtesting_profit_results(all_results)
            
    #         # Generate content for the detailed tabs
    #         analysis_leaderboard_content = create_enhanced_leaderboard(
    #             all_results['leaderboard'], 
    #             combined_signals_summary
    #         )
    #         profit_leaderboard_content = create_profit_leaderboard(all_results)
            
    #         # GUNAKAN technical_data untuk raw data explorer yang memiliki hasil technical analysis
    #         raw_data_content = create_raw_data_explorer(all_results['technical_data'])
            
    #         return (
    #             "",  # loading output
    #             "p-6 bg-white rounded shadow",  # bulk-results-container className
    #             backtesting_analysis,  # backtesting analysis content
    #             backtesting_profit,  # backtesting profit content
    #             analysis_leaderboard_content,  # enhanced analysis leaderboard content
    #             profit_leaderboard_content,  # profit leaderboard content
    #             raw_data_content,  # raw data explorer content
    #             all_results  # store all results for further use
    #         )
            
    #     except Exception as e:
    #         error_msg = f"Error in bulk analysis: {str(e)}"
    #         print(error_msg)
    #         traceback.print_exc()
    #         return error_msg, "hidden", None, None, None, None, None, None
    


    def generate_all_signal_combinations(selected_technicals):
        """Generate all possible combinations of technical indicators for voting system"""
        from itertools import combinations
        
        # Filter out Volume_Signal from regular combinations since it's handled separately
        regular_indicators = [ind for ind in selected_technicals if ind != 'Volume_Signal']
        has_volume = 'Volume_Signal' in selected_technicals
        
        combinations_to_create = []
        
        # Generate combinations of 2 or more indicators
        for r in range(2, len(regular_indicators) + 1):
            for combo in combinations(regular_indicators, r):
                combo_indicators = list(combo)
                
                # Add volume if available for each combination
                if has_volume:
                    combo_name = f"{'_'.join([ind.replace('_Signal', '') for ind in combo_indicators])}_Volume_Combined_Signal"
                    combo_indicators_with_volume = combo_indicators + ['Volume_Signal']
                else:
                    combo_name = f"{'_'.join([ind.replace('_Signal', '') for ind in combo_indicators])}_Combined_Signal"
                    combo_indicators_with_volume = combo_indicators
                
                combinations_to_create.append({
                    'name': combo_name,
                    'indicators': combo_indicators_with_volume,
                    'base_indicators': combo_indicators,
                    'has_volume': has_volume
                })
        
        return combinations_to_create
    


    ## VOTING SYSTEM
    # def apply_enhanced_combined_signals(df, selected_technicals):
    #     """Apply enhanced combined signals dengan konfirmasi trend dan volume - SIMPLIFIED"""
    #     print(f"ðŸ—³ï¸ Applying enhanced combined signals for: {selected_technicals}")
        
    #     # Generate all combinations
    #     combinations_to_create = generate_all_signal_combinations(selected_technicals)
        
    #     print(f"ðŸ“ Creating {len(combinations_to_create)} combined signal combinations...")
        
    #     for combo in combinations_to_create:
    #         combo_name = combo['name']
    #         indicators = combo['indicators']
    #         has_volume_confirmation = combo['has_volume_confirmation']
    #         has_trend_confirmation = combo['has_trend_confirmation']
            
    #         print(f"ðŸ”„ Processing {combo_name} with indicators: {indicators}")
            
    #         # Apply voting system untuk indikator utama
    #         combined_signal = apply_voting_system_with_confirmations(
    #             df, indicators, has_volume_confirmation, has_trend_confirmation
    #         )
            
    #         df[combo_name] = combined_signal
            
    #         signal_counts = combined_signal.value_counts().to_dict()
    #         print(f"âœ… {combo_name} signal counts: {signal_counts}")
        
    #     return df
    

    
    

    # def apply_voting_system_with_confirmations(df, indicators, has_volume_confirmation, has_trend_confirmation):
    #     """Apply voting system dengan konfirmasi trend dan volume - SIMPLIFIED"""
    #     combined_signal = pd.Series('Hold', index=df.index)
        
    #     for idx in df.index:
    #         # Collect votes dari indikator utama
    #         votes = []
    #         for indicator in indicators:
    #             if indicator in df.columns and pd.notna(df.at[idx, indicator]):
    #                 votes.append(df.at[idx, indicator])
            
    #         if not votes:
    #             combined_signal.at[idx] = 'Hold'
    #             continue
            
    #         # Hitung voting
    #         buy_votes = votes.count('Buy')
    #         sell_votes = votes.count('Sell')
    #         hold_votes = votes.count('Hold')
    #         total_votes = len(votes)
            
    #         # Tentukan hasil voting awal
    #         preliminary_result = determine_voting_result(buy_votes, sell_votes, hold_votes, total_votes)
            
    #         # Apply konfirmasi trend dari candlestick (jika ada)
    #         if has_trend_confirmation and 'Candlestick_Trend' in df.columns:
    #             preliminary_result = apply_trend_confirmation(
    #                 preliminary_result, df.at[idx, 'Candlestick_Trend']
    #             )
            
    #         # Apply konfirmasi volume (jika ada)
    #         if has_volume_confirmation and 'Volume_Signal' in df.columns:
    #             preliminary_result = apply_volume_confirmation(
    #                 preliminary_result, df.at[idx, 'Volume_Signal']
    #             )
            
    #         combined_signal.at[idx] = preliminary_result
        
    #     return combined_signal

    # def apply_trend_confirmation(preliminary_signal, candlestick_trend):
    #     """Apply trend confirmation dari candlestick pattern"""
    #     if pd.isna(candlestick_trend):
    #         return preliminary_signal
        
    #     # Jika trend dan sinyal bertentangan, ubah ke Hold
    #     if preliminary_signal == 'Buy' and candlestick_trend == 'Downtrend':
    #         return 'Hold'  # Trend turun tapi sinyal buy -> Hold
    #     elif preliminary_signal == 'Sell' and candlestick_trend == 'Uptrend':
    #         return 'Hold'  # Trend naik tapi sinyal sell -> Hold
        
    #     # Jika trend dan sinyal sejalan atau neutral, lanjutkan sinyal
    #     return preliminary_signal

    # def apply_volume_confirmation(preliminary_signal, volume_signal):
    #     """Apply volume confirmation - hanya High Volume yang melanjutkan sinyal"""
    #     if pd.isna(volume_signal):
    #         return preliminary_signal
        
    #     # Hanya High Volume yang melanjutkan sinyal Buy/Sell
    #     if preliminary_signal in ['Buy', 'Sell']:
    #         if volume_signal == 'High Volume':
    #             return preliminary_signal  # Lanjutkan sinyal karena volume tinggi
    #         else:  # Low Volume
    #             return 'Hold'  # Ubah ke Hold karena volume rendah
        
    #     # Jika sinyal Hold, tetap Hold
    #     return preliminary_signal













    def apply_voting_system(df, indicators):
        """Apply voting system for indicator combinations with special volume handling"""
        combined_signal = pd.Series('Hold', index=df.index)
        
        for idx in df.index:
            # Collect all signals from the indicators
            signals = []
            volume_signal = None
            has_volume = False
            
            for indicator in indicators:
                if indicator in df.columns:
                    signal = df.loc[idx, indicator]
                    
                    if pd.notna(signal):
                        if indicator == 'Volume_Signal':
                            has_volume = True
                            volume_signal = signal
                            # Don't add volume to regular voting - handle separately
                        else:
                            signals.append(signal)
            
            if not signals:
                combined_signal.loc[idx] = 'Hold'
                continue
            
            # Count votes for each signal type
            buy_votes = signals.count('Buy')
            sell_votes = signals.count('Sell')
            hold_votes = signals.count('Hold')
            
            # Determine preliminary result based on voting
            preliminary_result = determine_voting_result(buy_votes, sell_votes, hold_votes, len(signals))
            
            # Apply volume filter if volume indicator is present
            if has_volume and volume_signal:
                final_result = apply_volume_filter(preliminary_result, volume_signal)
            else:
                final_result = preliminary_result
            
            combined_signal.loc[idx] = final_result
        
        return combined_signal

    def determine_voting_result(buy_votes, sell_votes, hold_votes, total_indicators):
        """Determine voting result based on majority rule"""
        
        # Find the maximum votes
        max_votes = max(buy_votes, sell_votes, hold_votes)
        
        # Check for clear majority
        if buy_votes == max_votes and buy_votes > sell_votes and buy_votes > hold_votes:
            return 'Buy'
        elif sell_votes == max_votes and sell_votes > buy_votes and sell_votes > hold_votes:
            return 'Sell'
        elif hold_votes == max_votes and hold_votes > buy_votes and hold_votes > sell_votes:
            return 'Hold'
        
        # Handle ties based on number of indicators
        if total_indicators == 2:
            # For 2 indicators: if tie, Hold
            return 'Hold'
        
        elif total_indicators == 3:
            # For 3 indicators: majority wins, if no clear majority then Hold
            if buy_votes >= 2:
                return 'Buy'
            elif sell_votes >= 2:
                return 'Sell'
            else:
                return 'Hold'
        
        elif total_indicators == 4:
            # For 4 indicators: majority wins
            if buy_votes >= 2 and buy_votes > sell_votes:
                return 'Buy'
            elif sell_votes >= 2 and sell_votes > buy_votes:
                return 'Sell'
            elif buy_votes == sell_votes and buy_votes >= 2:
                # Equal buy and sell votes (2-2), return Hold
                return 'Hold'
            else:
                return 'Hold'
        
        else:
            # For 5+ indicators: majority rule
            half_indicators = total_indicators // 2
            if buy_votes > half_indicators:
                return 'Buy'
            elif sell_votes > half_indicators:
                return 'Sell'
            else:
                return 'Hold'

    def apply_volume_filter(preliminary_result, volume_signal):
        """Apply volume filter to modify the preliminary result"""
        
        # If volume is low, force Hold regardless of other signals
        if volume_signal == 'Low Volume':
            return 'Hold'
        
        # If volume is high, let the preliminary result stand
        elif volume_signal == 'High Volume':
            return preliminary_result
        
        # For any other volume signal, use preliminary result
        else:
            return preliminary_result

    def apply_volume_analysis(df, **params):
        """Apply volume analysis with specific signal categories"""
        try:
            if 'Volume' not in df.columns:
                print("Volume column not found, skipping volume analysis")
                return df
            
            # Calculate Volume Moving Average
            volume_period = params.get('volume_period', 20)
            df['VMA'] = df['Volume'].rolling(window=volume_period).mean()
            
            # Generate Volume signals with specific categories
            df['Volume_Signal'] = 'Normal Volume'  # Default
            
            # High volume threshold (1.5x average)
            high_volume_threshold = 1.5
            df.loc[df['Volume'] > (df['VMA'] * high_volume_threshold), 'Volume_Signal'] = 'High Volume'
            
            # Low volume threshold (0.5x average)  
            low_volume_threshold = 0.5
            df.loc[df['Volume'] < (df['VMA'] * low_volume_threshold), 'Volume_Signal'] = 'Low Volume'
            
            print("Volume analysis applied successfully")
            
        except Exception as e:
            print(f"Error in volume analysis: {e}")
        
        return df

    def create_enhanced_combined_signal_summary(df, selected_technicals):
        """Create summary of all combined signals created with voting details"""
        combinations_info = generate_all_signal_combinations(selected_technicals)
        
        summary_data = []
        
        for combo in combinations_info:
            combo_name = combo['name']
            if combo_name in df.columns:
                signal_counts = df[combo_name].value_counts()
                
                # Calculate voting statistics
                voting_stats = calculate_voting_statistics(df, combo['indicators'], combo_name)
                
                summary_data.append({
                    'Combination': combo_name.replace('_Combined_Signal', ''),
                    'Indicators Used': ', '.join([ind.replace('_Signal', '') for ind in combo['indicators']]),
                    'Buy Signals': signal_counts.get('Buy', 0),
                    'Sell Signals': signal_counts.get('Sell', 0),
                    'Hold Signals': signal_counts.get('Hold', 0),
                    'Total Signals': len(df),
                    'Activity Rate': f"{((signal_counts.get('Buy', 0) + signal_counts.get('Sell', 0)) / len(df) * 100):.1f}%",
                    'Volume Override Rate': voting_stats.get('volume_override_rate', 'N/A'),
                    'Consensus Rate': voting_stats.get('consensus_rate', 'N/A')
                })
        
        return summary_data

    def calculate_voting_statistics(df, indicators, combo_name):
        """Calculate detailed voting statistics for a combination"""
        try:
            volume_override_count = 0
            consensus_count = 0
            total_signals = len(df)
            
            has_volume = 'Volume_Signal' in indicators
            
            for idx in df.index:
                signals = []
                volume_signal = None
                
                for indicator in indicators:
                    if indicator in df.columns:
                        signal = df.loc[idx, indicator]
                        if pd.notna(signal):
                            if indicator == 'Volume_Signal':
                                volume_signal = signal
                            else:
                                signals.append(signal)
                
                if signals:
                    # Count votes
                    buy_votes = signals.count('Buy')
                    sell_votes = signals.count('Sell')
                    hold_votes = signals.count('Hold')
                    
                    # Check for consensus (unanimous or near-unanimous)
                    total_votes = len(signals)
                    max_votes = max(buy_votes, sell_votes, hold_votes)
                    if max_votes >= (total_votes * 0.75):  # 75% agreement
                        consensus_count += 1
                    
                    # Check for volume override
                    if has_volume and volume_signal == 'Low Volume':
                        preliminary_result = determine_voting_result(buy_votes, sell_votes, hold_votes, len(signals))
                        if preliminary_result != 'Hold':
                            volume_override_count += 1
            
            volume_override_rate = f"{(volume_override_count / total_signals * 100):.1f}%" if has_volume else "N/A"
            consensus_rate = f"{(consensus_count / total_signals * 100):.1f}%"
            
            return {
                'volume_override_rate': volume_override_rate,
                'consensus_rate': consensus_rate
            }
            
        except Exception as e:
            print(f"Error calculating voting statistics: {e}")
            return {'volume_override_rate': 'N/A', 'consensus_rate': 'N/A'}


    def create_leaderboard_table(leaderboard_data, title):
        """Create a standard leaderboard table for any strategy type"""
        if not leaderboard_data:
            return html.Div("No data available", className="text-gray-500 text-center p-4")
        
        # Prepare data for table
        table_data = []
        for i, item in enumerate(leaderboard_data):
            table_data.append({
                'Rank': i + 1,
                'Ticker': item.get('ticker', 'N/A'),
                'Indicator': item.get('indicator', 'N/A').replace('_Signal', '').replace('_Combined_Signal', ''),
                'Profit %': f"{item.get('profit_percentage', 0):.2f}%",
                'Total Profit': f"{item.get('total_profit', 0):,.2f}",
                'Win Rate': f"{item.get('win_rate', 0):.2f}%",
                'Total Trades': item.get('num_trades', 0)
            })
        
        return html.Div([
            html.H4(title, className="text-lg font-semibold mb-3"),
            dash_table.DataTable(
                data=table_data,
                columns=[
                    {'name': '#', 'id': 'Rank'},
                    {'name': 'Ticker', 'id': 'Ticker'},
                    {'name': 'Strategy', 'id': 'Indicator'},
                    {'name': 'Profit %', 'id': 'Profit %'},
                    {'name': 'Total Profit', 'id': 'Total Profit'},
                    {'name': 'Win Rate', 'id': 'Win Rate'},
                    {'name': 'Total Trades', 'id': 'Total Trades'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                style_data_conditional=[
                    {
                        'if': {'row_index': 0},
                        'backgroundColor': 'rgba(255, 215, 0, 0.3)',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'row_index': 1},
                        'backgroundColor': 'rgba(192, 192, 192, 0.3)',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'row_index': 2},
                        'backgroundColor': 'rgba(205, 127, 50, 0.3)',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'filter_query': '{Profit %} contains "-"'},
                        'color': 'red'
                    },
                    {
                        'if': {'filter_query': '{Profit %} > "0"'},
                        'color': 'green'
                    }
                ],
                sort_action='native',
                page_size=15
            )
        ])




    def create_enhanced_leaderboard(leaderboard_data, combined_signals_summary):
        """Create enhanced leaderboard with voting system info"""
        
        # Separate individual and combined results
        individual_results = [item for item in leaderboard_data if not item['indicator'].endswith('_Combined_Signal')]
        combined_results = [item for item in leaderboard_data if item['indicator'].endswith('_Combined_Signal')]
        
        components = [
            html.H3("ðŸ† Enhanced Analysis Leaderboard (Voting System)", className="text-lg font-semibold mb-3"),
            
            # Summary stats with voting info
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Individual Strategies", className="block text-sm text-gray-500"),
                        html.Span(f"{len(individual_results)}", className="block text-xl font-bold text-blue-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Combined Strategies", className="block text-sm text-gray-500"),
                        html.Span(f"{len(combined_results)}", className="block text-xl font-bold text-green-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Total Combinations", className="block text-sm text-gray-500"),
                        html.Span(f"{len(combined_signals_summary)}", className="block text-xl font-bold text-purple-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Voting System", className="block text-sm text-gray-500"),
                        html.Span("Active", className="block text-xl font-bold text-orange-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2")
            ], className="flex -mx-2 mb-6"),
            
            # Voting system explanation
            html.Div([
                html.H4("ðŸ—³ï¸ Voting System Explanation", className="text-lg font-semibold mb-3"),
                html.Div([
                    html.P("ðŸ“Š Combined signals menggunakan sistem voting mayoritas:", className="mb-2"),
                    html.Ul([
                        html.Li("2 indikator: Jika sama â†’ gunakan sinyal, jika beda â†’ Hold", className="mb-1"),
                        html.Li("3 indikator: Mayoritas menang (â‰¥2 votes), contoh: Buy-Buy-Sell â†’ Buy", className="mb-1"),
                        html.Li("4+ indikator: Mayoritas menang, jika seimbang â†’ Hold", className="mb-1"),
                        html.Li("ðŸ”Š Volume khusus: Low Volume â†’ paksa Hold, High Volume â†’ lanjutkan hasil voting", className="mb-1 font-semibold text-orange-600")
                    ], className="list-disc list-inside")
                ], className="p-4 bg-blue-50 rounded-lg border border-blue-200")
            ], className="mb-6"),
            
            # Enhanced combined signals summary table with voting details
            html.Div([
                html.H4("ðŸ“Š Combined Signals Summary (Voting Details)", className="text-lg font-semibold mb-3"),
                dash_table.DataTable(
                    data=combined_signals_summary,
                    columns=[
                        {'name': 'Combination', 'id': 'Combination'},
                        {'name': 'Indicators Used', 'id': 'Indicators Used'},
                        {'name': 'Buy Signals', 'id': 'Buy Signals'},
                        {'name': 'Sell Signals', 'id': 'Sell Signals'},
                        {'name': 'Hold Signals', 'id': 'Hold Signals'},
                        {'name': 'Activity Rate', 'id': 'Activity Rate'},
                        {'name': 'Volume Override Rate', 'id': 'Volume Override Rate'},
                        {'name': 'Consensus Rate', 'id': 'Consensus Rate'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Buy Signals} > {Sell Signals}'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)'
                        },
                        {
                            'if': {'filter_query': '{Sell Signals} > {Buy Signals}'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)'
                        },
                        {
                            'if': {'filter_query': '{Volume Override Rate} contains "%"'},
                            'backgroundColor': 'rgba(255, 165, 0, 0.1)'
                        }
                    ],
                    sort_action='native',
                    page_size=10,
                    tooltip_data=[
                        {
                            'Volume Override Rate': 'Persentase sinyal yang diubah menjadi Hold karena Low Volume'
                        } for _ in combined_signals_summary
                    ]
                )
            ], className="mb-6"),
            
            # Main leaderboard with tabs
            dcc.Tabs([
                dcc.Tab(label="ðŸ¥‡ Top Performers (All)", children=[
                    create_leaderboard_table(leaderboard_data[:20], "All Strategies (Voting System)")
                ]),
                dcc.Tab(label="ðŸ’¡ Individual Strategies", children=[
                    create_leaderboard_table(individual_results[:15], "Individual Strategies")
                ]),
                dcc.Tab(label="ðŸ—³ï¸ Combined Strategies (Voting)", children=[
                    create_voting_leaderboard_table(combined_results[:15], combined_signals_summary)
                ])
            ])
        ]
        
        return html.Div(components)

    def create_voting_leaderboard_table(data, combined_signals_summary):
        """Create enhanced leaderboard table specifically for voting-based combined strategies"""
        
        # Merge data with voting statistics
        enhanced_data = []
        for item in data:
            # Find corresponding voting stats
            voting_stats = None
            for summary in combined_signals_summary:
                combo_name = f"{summary['Combination']}_Combined_Signal"
                if combo_name == item['indicator']:
                    voting_stats = summary
                    break
            
            enhanced_item = {
                'Rank': len(enhanced_data) + 1,
                'Ticker': item['ticker'],
                'Strategy': item['indicator'].replace('_Signal', '').replace('_Combined_Signal', ' (Voting)'),
                'Profit %': f"{item['profit_percentage']:.2f}%",
                'Win Rate': f"{item['win_rate']:.2f}%",
                'Trades': item['num_trades'],
                'Total Profit': f"{item['total_profit']:,.2f}",
                'Indicators': voting_stats['Indicators Used'] if voting_stats else 'N/A',
                'Volume Override': voting_stats['Volume Override Rate'] if voting_stats else 'N/A',
                'Consensus Rate': voting_stats['Consensus Rate'] if voting_stats else 'N/A'
            }
            enhanced_data.append(enhanced_item)
        
        return html.Div([
            html.H5("ðŸ—³ï¸ Combined Strategies with Voting Details", className="text-md font-semibold mb-3"),
            html.P("Strategi kombinasi menggunakan sistem voting mayoritas dengan filter volume khusus.", 
                className="text-sm text-gray-600 mb-3"),
            
            dash_table.DataTable(
                data=enhanced_data,
                columns=[
                    {'name': '#', 'id': 'Rank'},
                    {'name': 'Ticker', 'id': 'Ticker'},
                    {'name': 'Strategy', 'id': 'Strategy'},
                    {'name': 'Indicators', 'id': 'Indicators'},
                    {'name': 'Profit %', 'id': 'Profit %'},
                    {'name': 'Win Rate', 'id': 'Win Rate'},
                    {'name': 'Trades', 'id': 'Trades'},
                    {'name': 'Total Profit', 'id': 'Total Profit'},
                    {'name': 'Volume Override', 'id': 'Volume Override'},
                    {'name': 'Consensus Rate', 'id': 'Consensus Rate'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Strategy} contains "Voting"'},
                        'backgroundColor': 'rgba(147, 51, 234, 0.1)',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'filter_query': '{Profit %} contains "-"'},
                        'color': 'red'
                    },
                    {
                        'if': {'filter_query': '{Profit %} > "0"'},
                        'color': 'green'
                    },
                    {
                        'if': {'filter_query': '{Volume Override} contains "%"'},
                        'backgroundColor': 'rgba(255, 165, 0, 0.1)'
                    }
                ],
                sort_action='native',
                page_size=15,
                tooltip_data=[
                    {
                        'Volume Override': 'Persentase sinyal yang di-override menjadi Hold karena Low Volume',
                        'Consensus Rate': 'Persentase agreement antar indikator (â‰¥75%)'
                    } for _ in enhanced_data
                ]
            )
        ], className="mt-4")

    def create_voting_analysis_chart(df, selected_technicals):
        """Create analysis chart showing voting patterns"""
        
        # Find combined signal columns
        combined_cols = [col for col in df.columns if col.endswith('_Combined_Signal')]
        
        if not combined_cols:
            return html.Div("No combined signals to analyze", className="text-gray-500")
        
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Voting Distribution', 'Volume Override Impact', 
                        'Consensus vs Conflict Signals', 'Activity by Combination'),
            specs=[[{"type": "xy"}, {"type": "xy"}],
                [{"type": "xy"}, {"type": "xy"}]]
        )
        
        # 1. Voting Distribution
        for i, col in enumerate(combined_cols[:5]):  # Limit to 5 for readability
            signal_counts = df[col].value_counts()
            fig.add_trace(
                go.Bar(x=list(signal_counts.index), y=list(signal_counts.values), 
                    name=col.replace('_Combined_Signal', ''), 
                    legendgroup="voting"),
                row=1, col=1
            )
        
        # 2. Volume Override Impact (if volume is present)
        if 'Volume_Signal' in df.columns:
            volume_low_mask = df['Volume_Signal'] == 'Low Volume'
            volume_high_mask = df['Volume_Signal'] == 'High Volume'
            
            override_data = []
            for col in combined_cols[:3]:
                low_vol_holds = len(df[volume_low_mask & (df[col] == 'Hold')])
                high_vol_active = len(df[volume_high_mask & (df[col] != 'Hold')])
                override_data.append({'Combination': col.replace('_Combined_Signal', ''), 
                                    'Low Vol Holds': low_vol_holds, 
                                    'High Vol Active': high_vol_active})
            
            if override_data:
                override_df = pd.DataFrame(override_data)
                fig.add_trace(
                    go.Bar(x=override_df['Combination'], y=override_df['Low Vol Holds'], 
                        name='Low Vol â†’ Hold', marker_color='orange'),
                    row=1, col=2
                )
                fig.add_trace(
                    go.Bar(x=override_df['Combination'], y=override_df['High Vol Active'], 
                        name='High Vol â†’ Active', marker_color='blue'),
                    row=1, col=2
                )
        
        # 3. Consensus Analysis (simplified)
        consensus_data = []
        for col in combined_cols[:3]:
            total_signals = len(df)
            # This is a simplified consensus measure
            non_hold_signals = len(df[df[col] != 'Hold'])
            consensus_rate = (non_hold_signals / total_signals) * 100
            consensus_data.append({'Combination': col.replace('_Combined_Signal', ''), 
                                'Activity Rate': consensus_rate})
        
        if consensus_data:
            consensus_df = pd.DataFrame(consensus_data)
            fig.add_trace(
                go.Scatter(x=consensus_df['Combination'], y=consensus_df['Activity Rate'], 
                        mode='markers+lines', name='Activity %', marker_size=10),
                row=2, col=1
            )
        
        # 4. Total signal distribution
        all_signal_counts = {'Buy': 0, 'Sell': 0, 'Hold': 0}
        for col in combined_cols:
            counts = df[col].value_counts()
            for signal, count in counts.items():
                if signal in all_signal_counts:
                    all_signal_counts[signal] += count
        
        fig.add_trace(
            go.Pie(labels=list(all_signal_counts.keys()), values=list(all_signal_counts.values()),
                name="Overall Distribution"),
            row=2, col=2
        )
        
        fig.update_layout(
            height=600,
            title_text="Voting System Analysis Dashboard",
            showlegend=True
        )
        
        return dcc.Graph(figure=fig, config={'displayModeBar': True})


    

    

    def create_profit_leaderboard(all_results):
        """Create profit leaderboard components from the data"""
        if not all_results or 'leaderboard' not in all_results or not all_results['leaderboard']:
            return html.Div("No profit leaderboard data available", className="text-center text-gray-500 p-4")
        
        # Sort by profit percentage
        leaderboard_data = sorted(all_results['leaderboard'], key=lambda x: x['profit_percentage'], reverse=True)
        
        # Overall metrics
        best_ticker = leaderboard_data[0]['ticker'] if leaderboard_data else "N/A"
        best_final_capital = max([result['final_capital'] for result in 
                                [item for sublist in all_results['ticker_details'].values() for item in sublist]], 
                                default=0) if all_results.get('ticker_details') else 0
        best_total_profit = max([result['total_profit'] for result in 
                                [item for sublist in all_results['ticker_details'].values() for item in sublist]], 
                                default=0) if all_results.get('ticker_details') else 0
        best_profit_pct = max([result['profit_percentage'] for result in 
                            [item for sublist in all_results['ticker_details'].values() for item in sublist]], 
                            default=0) if all_results.get('ticker_details') else 0
        
        return html.Div([
            html.H3("Top Profitable Scenarios", className="text-lg font-semibold mb-3"),
            
            # Overall metrics
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Most Profitable Ticker", className="block text-sm text-gray-500"),
                        html.Span(best_ticker, className="block text-xl font-bold text-blue-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Best Final Capital", className="block text-sm text-gray-500"),
                        html.Span(f"{best_final_capital:,.2f}", className="block text-xl font-bold text-green-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Best Total Profit", className="block text-sm text-gray-500"),
                        html.Span(f"{best_total_profit:,.2f}", className="block text-xl font-bold text-green-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Best Profit %", className="block text-sm text-gray-500"),
                        html.Span(f"{best_profit_pct:.2f}%", className="block text-xl font-bold text-green-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
            ], className="flex -mx-2 mb-6"),
            
            # Profit leaderboard table
            dash_table.DataTable(
                data=[{
                    'Rank': idx + 1,
                    'Ticker': item['ticker'],
                    'Indicator': item['indicator'],
                    'Profit %': f"{item['profit_percentage']:.2f}%",
                    'Total Profit': f"{item['total_profit']:,.2f}",
                    'Win Rate': f"{item['win_rate']:.2f}%",
                    'Trades': item['num_trades']
                } for idx, item in enumerate(leaderboard_data)],
                columns=[
                    {'name': 'Rank', 'id': 'Rank'},
                    {'name': 'Ticker', 'id': 'Ticker'},
                    {'name': 'Indicator', 'id': 'Indicator'},
                    {'name': 'Profit %', 'id': 'Profit %'},
                    {'name': 'Total Profit', 'id': 'Total Profit'},
                    {'name': 'Win Rate', 'id': 'Win Rate'},
                    {'name': 'Trades', 'id': 'Trades'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_data_conditional=[
                    {
                        'if': {'row_index': 0},
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'row_index': 1},
                        'backgroundColor': 'rgba(0, 255, 0, 0.05)',
                    }
                ],
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                sort_action='native',
                page_size=10
            ),
            
            # Visualization of profit distribution
            html.Div([
                html.H4("Profit Distribution Across Scenarios", className="text-lg font-semibold mt-4 mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Bar(
                                x=[item['ticker'] for item in leaderboard_data[:10]],
                                y=[item['profit_percentage'] for item in leaderboard_data[:10]],
                                marker_color='green',
                                text=[f"{item['profit_percentage']:.2f}%" for item in leaderboard_data[:10]],
                                textposition='auto'
                            )
                        ],
                        layout=go.Layout(
                            title='Top 10 Profit % by Ticker',
                            xaxis_title='Ticker',
                            yaxis_title='Profit %',
                            height=400
                        )
                    )
                )
            ], className="mt-6")
        ])
    

    # Main results tabs structure
    def create_main_results_tabs(raw_data, backtesting_analysis, backtesting_profit):
        return dcc.Tabs(
            id="main-results-tabs", 
            className="mb-8",
            children=[
                # Raw Data Tab - Only showing general overview
                dcc.Tab(
                    label="Raw Data", 
                    className="font-semibold py-3 px-4",
                    selected_className="bg-blue-50 border-t-2 border-blue-600",
                    children=[
                        html.Div(id="raw-data-explorer", className="mt-4 p-4", children=raw_data)
                    ]
                ),
                # Backtesting Analysis Tab - Only showing general analysis
                dcc.Tab(
                    label="Backtesting Analysis", 
                    className="font-semibold py-3 px-4",
                    selected_className="bg-blue-50 border-t-2 border-blue-600",
                    children=[
                        html.Div(id="backtesting-analysis-content", className="mt-4 p-4", children=backtesting_analysis)
                    ]
                ),
                # Backtesting Profit Tab - Only showing general profit analysis
                # dcc.Tab(
                #     label="Backtesting Profit", 
                #     className="font-semibold py-3 px-4",
                #     selected_className="bg-blue-50 border-t-2 border-blue-600",
                #     children=[
                #         html.Div(id="backtesting-profit-content", className="mt-4 p-4", children=backtesting_profit)
                #     ]
                # )
            ]
        )




    # RAW DATA SECTION

    # def create_raw_data_explorer(raw_data):
    #     """Create a raw data explorer with dropdown for ticker selection and tabs"""
    #     if not raw_data:
    #         return html.Div("No raw data available", className="text-center text-gray-500 p-4")
        
    #     # Store raw data in a hidden div for access by callbacks
    #     stored_data = html.Div(id='stored-raw-data', style={'display': 'none'}, 
    #                         children=json.dumps(raw_data))
        
    #     return html.Div([
    #         # Hidden div to store the raw data
    #         stored_data,
            
    #         # Overview section
    #         html.Div([
    #             html.H3("Data Overview", className="text-xl font-semibold mb-3"),
    #             html.P(f"Total tickers analyzed: {len(raw_data)}", className="mb-2"),
    #             html.P("Select a ticker below to explore its data", className="mb-2 text-gray-600")
    #         ], className="mb-4"),
            
    #         # General vs Ticker-specific tab selector
    #         dcc.Tabs([
    #             # General Summary Tab
    #             dcc.Tab(
    #                 label="General Summary",
    #                 className="font-semibold py-3 px-4",
    #                 selected_className="bg-blue-50 border-b-2 border-blue-600",
    #                 children=[
    #                     html.Div([
    #                         # Summary metrics
    #                         html.Div([
    #                             html.Div([
    #                                 html.Div([
    #                                     html.Span("Total Tickers", className="block text-sm text-gray-500"),
    #                                     html.Span(f"{len(raw_data)}", className="block text-xl font-bold text-blue-600")
    #                                 ], className="p-4 border rounded bg-white shadow-sm")
    #                             ], className="w-1/3 px-2"),
    #                             html.Div([
    #                                 html.Div([
    #                                     html.Span("Avg Records/Ticker", className="block text-sm text-gray-500"),
    #                                     html.Span(
    #                                         f"{sum(len(data) for data in raw_data.values())/max(1, len(raw_data)):.0f}", 
    #                                         className="block text-xl font-bold text-blue-600")
    #                                 ], className="p-4 border rounded bg-white shadow-sm")
    #                             ], className="w-1/3 px-2"),
    #                             html.Div([
    #                                 html.Div([
    #                                     html.Span("Data Period", className="block text-sm text-gray-500"),
    #                                     html.Span("Jan 2022 - Jan 2023", className="block text-xl font-bold text-blue-600")
    #                                 ], className="p-4 border rounded bg-white shadow-sm")
    #                             ], className="w-1/3 px-2")
    #                         ], className="flex -mx-2 mb-6"),
                            
    #                         # Available tickers table
    #                         html.Div([
    #                             html.H4("Available Tickers", className="text-lg font-semibold mb-3"),
    #                             dash_table.DataTable(
    #                                 data=[{
    #                                     'Ticker': ticker, 
    #                                     'Records': len(data),
    #                                     'Signals': sum(1 for item in data if item.get('Combined_Signal', '') in ['Buy', 'Sell'])
    #                                 } for ticker, data in raw_data.items()],
    #                                 columns=[
    #                                     {'name': 'Ticker', 'id': 'Ticker'},
    #                                     {'name': 'Records', 'id': 'Records'},
    #                                     {'name': 'Signals', 'id': 'Signals'},
    #                                 ],
    #                                 style_table={'overflowX': 'auto'},
    #                                 style_cell={'textAlign': 'left', 'padding': '10px'},
    #                                 style_header={
    #                                     'backgroundColor': 'rgb(240, 240, 240)',
    #                                     'fontWeight': 'bold'
    #                                 },
    #                                 page_size=10,
    #                                 sort_action='native'
    #                             ),
    #                         ], className="mb-6"),
                            
    #                         # Data quality overview
    #                         html.Div([
    #                             html.H4("Data Quality Overview", className="text-lg font-semibold mb-3"),
    #                             html.P("The following chart shows the completeness of data across all tickers:"),
    #                             dcc.Graph(
    #                                 figure=generate_data_quality_chart(raw_data),
    #                                 config={'displayModeBar': True},
    #                                 style={'height': '400px'}
    #                             )
    #                         ])
    #                     ], className="mt-4")
    #                 ]
    #             ),
                
    #             # Ticker-Specific Tab
    #             dcc.Tab(
    #                 label="Ticker-Specific Data", 
    #                 className="font-semibold py-3 px-4",
    #                 selected_className="bg-blue-50 border-b-2 border-blue-600",
    #                 children=[
    #                     html.Div([
    #                         html.Div([
    #                             html.Label("Select Ticker:", className="mr-2 font-medium"),
    #                             dcc.Dropdown(
    #                                 id="raw-data-ticker-selector",
    #                                 options=[{'label': ticker, 'value': ticker} for ticker in raw_data.keys()],
    #                                 value=list(raw_data.keys())[0] if raw_data else None,
    #                                 className="w-full"
    #                             )
    #                         ], className="mb-4"),
                            
    #                         # Search and filter controls
    #                         html.Div([
    #                             html.Div([
    #                                 html.Label("Search:", className="mr-2 font-medium"),
    #                                 dcc.Input(
    #                                     id="raw-data-search",
    #                                     type="text",
    #                                     placeholder="Enter search term",
    #                                     className="p-2 border rounded flex-grow"
    #                                 )
    #                             ], className="flex items-center mb-3"),
                                
    #                             html.Div([
    #                                 html.Label("Filter by Signal:", className="mr-2 font-medium"),
    #                                 dcc.Dropdown(
    #                                     id="raw-data-signal-filter",
    #                                     options=[
    #                                         {'label': 'All Signals', 'value': 'all'},
    #                                         {'label': 'Buy Signals', 'value': 'Buy'},
    #                                         {'label': 'Sell Signals', 'value': 'Sell'},
    #                                         {'label': 'Hold Signals', 'value': 'Hold'}
    #                                     ],
    #                                     value='all',
    #                                     clearable=False,
    #                                     className="w-64"
    #                                 )
    #                             ], className="flex items-center")
    #                         ], className="mb-4 p-3 bg-gray-50 rounded"),
                            
    #                         # Tabs for different views of ticker data
    #                         dcc.Tabs([
    #                             dcc.Tab(label="Data Table", children=[
    #                                 html.Div(id="selected-ticker-data", className="mt-4")
    #                             ]),
    #                             dcc.Tab(label="Price Chart", children=[
    #                                 dcc.Loading(
    #                                     id="loading-price-chart",
    #                                     type="circle",
    #                                     children=html.Div(id="ticker-price-chart", className="mt-4")
    #                                 )
    #                             ]),
    #                             dcc.Tab(label="Signal Distribution", children=[
    #                                 dcc.Loading(
    #                                     id="loading-signal-chart",
    #                                     type="circle",
    #                                     children=html.Div(id="ticker-signal-chart", className="mt-4")
    #                                 )
    #                             ]),
    #                             dcc.Tab(label="Technical Indicators", children=[
    #                                 dcc.Loading(
    #                                     id="loading-indicators-chart",
    #                                     type="circle",
    #                                     children=html.Div(id="ticker-indicators-chart", className="mt-4")
    #                                 )
    #                             ])
    #                         ])
    #                     ], className="mt-4")
    #                 ]
    #             )
    #         ])
    #     ])
    


















    # def generate_data_quality_chart(raw_data):
    #     """Generate a chart showing data quality across tickers"""
    #     ticker_data = []
        
    #     for ticker, data in raw_data.items():
    #         if not data:
    #             continue
                
    #         df = pd.DataFrame(data)
    #         ticker_data.append({
    #             'ticker': ticker,
    #             'records': len(df),
    #             'signals': sum(1 for item in data if item.get('Combined_Signal', '') in ['Buy', 'Sell']),
    #             'data_completeness': sum(1 for col in df.columns if not df[col].isna().all()) / len(df.columns) * 100
    #         })
        
    #     fig = go.Figure()
    #     fig.add_trace(go.Bar(
    #         x=[item['ticker'] for item in ticker_data],
    #         y=[item['records'] for item in ticker_data],
    #         name='Total Records'
    #     ))
        
    #     fig.add_trace(go.Bar(
    #         x=[item['ticker'] for item in ticker_data],
    #         y=[item['signals'] for item in ticker_data],
    #         name='Signals'
    #     ))
        
    #     fig.update_layout(
    #         title="Data Availability by Ticker",
    #         xaxis_title="Ticker",
    #         yaxis_title="Records",
    #         barmode='group',
    #         height=400
    #     )
        
    #     return fig

    # def create_ticker_price_chart(df, ticker):
    #     """Create a price chart for a specific ticker"""
    #     fig = go.Figure()
        
    #     # Price candlesticks
    #     fig.add_trace(go.Candlestick(
    #         x=df['Datetime'],
    #         open=df['Open'],
    #         high=df['High'],
    #         low=df['Low'],
    #         close=df['Close'],
    #         name='Price'
    #     ))
        
    #     # Add signals if available
    #     indicators = [col for col in df.columns if col.endswith('_Signal')]
    #     for indicator in indicators:
    #         buy_signals = df[df[indicator] == 'Buy']
    #         sell_signals = df[df[indicator] == 'Sell']
            
    #         if not buy_signals.empty:
    #             fig.add_trace(go.Scatter(
    #                 x=buy_signals['Datetime'],
    #                 y=buy_signals['Low'] * 0.99,
    #                 mode='markers',
    #                 marker=dict(symbol='triangle-up', size=10, color='green'),
    #                 name=f'{indicator} Buy'
    #             ))
            
    #         if not sell_signals.empty:
    #             fig.add_trace(go.Scatter(
    #                 x=sell_signals['Datetime'],
    #                 y=sell_signals['High'] * 1.01,
    #                 mode='markers',
    #                 marker=dict(symbol='triangle-down', size=10, color='red'),
    #                 name=f'{indicator} Sell'
    #             ))
        
    #     fig.update_layout(
    #         title=f"{ticker} Price Chart with Signals",
    #         xaxis_title="Date",
    #         yaxis_title="Price",
    #         height=500,
    #         xaxis_rangeslider_visible=False
    #     )
        
    #     return fig

    # def create_indicator_analysis_tab(df, indicator, result, ticker):
    #     """Create an analysis tab for a specific indicator"""
    #     buy_signals = df[df[indicator] == 'Buy']
    #     sell_signals = df[df[indicator] == 'Sell']
        
    #     # Create metrics section
    #     metrics = html.Div([
    #         html.H4(f"{indicator} Performance", className="text-lg font-semibold mb-2"),
    #         html.Div([
    #             html.Div([
    #                 html.Div([
    #                     html.Span("Buy Signals", className="block text-sm text-gray-500"),
    #                     html.Span(f"{len(buy_signals)}", className="block text-xl font-bold text-green-600")
    #                 ], className="p-3 border rounded bg-white shadow-sm")
    #             ], className="w-1/4 px-2"),
    #             html.Div([
    #                 html.Div([
    #                     html.Span("Sell Signals", className="block text-sm text-gray-500"),
    #                     html.Span(f"{len(sell_signals)}", className="block text-xl font-bold text-red-600")
    #                 ], className="p-3 border rounded bg-white shadow-sm")
    #             ], className="w-1/4 px-2"),
    #             html.Div([
    #                 html.Div([
    #                     html.Span("Total Profit", className="block text-sm text-gray-500"),
    #                     html.Span(
    #                         f"{result['total_profit']:,.2f}", 
    #                         className=f"block text-xl font-bold {'text-green-600' if result['total_profit'] > 0 else 'text-red-600'}"
    #                     )
    #                 ], className="p-3 border rounded bg-white shadow-sm")
    #             ], className="w-1/4 px-2"),
    #             html.Div([
    #                 html.Div([
    #                     html.Span("Win Rate", className="block text-sm text-gray-500"),
    #                     html.Span(f"{result['win_rate']:.2f}%", className="block text-xl font-bold text-blue-600")
    #                 ], className="p-3 border rounded bg-white shadow-sm")
    #             ], className="w-1/4 px-2"),
    #         ], className="flex -mx-2 mb-4")
    #     ])
        
    #     # Create chart visualization
    #     fig = go.Figure()
        
    #     # Add price trace
    #     fig.add_trace(go.Scatter(
    #         x=df['Datetime'],
    #         y=df['Close'],
    #         mode='lines',
    #         name='Close Price',
    #         line=dict(color='blue')
    #     ))
        
    #     # Add indicator specific elements
    #     if 'Bollinger_Signal' in indicator:
    #         if 'Upper Band' in df.columns and 'Lower Band' in df.columns and 'Middle Band' in df.columns:
    #             fig.add_trace(go.Scatter(
    #                 x=df['Datetime'],
    #                 y=df['Upper Band'],
    #                 mode='lines',
    #                 name='Upper Band',
    #                 line=dict(color='red', dash='dot')
    #             ))
                
    #             fig.add_trace(go.Scatter(
    #                 x=df['Datetime'],
    #                 y=df['Lower Band'],
    #                 mode='lines',
    #                 name='Lower Band',
    #                 line=dict(color='green', dash='dot')
    #             ))
                
    #             fig.add_trace(go.Scatter(
    #                 x=df['Datetime'],
    #                 y=df['Middle Band'],
    #                 mode='lines',
    #                 name='Middle Band',
    #                 line=dict(color='purple', dash='dash')
    #             ))
        
    #     elif 'MA_Signal' in indicator:
    #         if 'short_MA' in df.columns and 'long_MA' in df.columns:
    #             fig.add_trace(go.Scatter(
    #                 x=df['Datetime'],
    #                 y=df['short_MA'],
    #                 mode='lines',
    #                 name='Short MA',
    #                 line=dict(color='orange')
    #             ))
                
    #             fig.add_trace(go.Scatter(
    #                 x=df['Datetime'],
    #                 y=df['long_MA'],
    #                 mode='lines',
    #                 name='Long MA',
    #                 line=dict(color='purple')
    #             ))
        
    #     # Add buy/sell markers
    #     fig.add_trace(go.Scatter(
    #         x=buy_signals['Datetime'],
    #         y=buy_signals['Close'],
    #         mode='markers',
    #         name='Buy Signal',
    #         marker=dict(symbol='triangle-up', size=12, color='green')
    #     ))
        
    #     fig.add_trace(go.Scatter(
    #         x=sell_signals['Datetime'],
    #         y=sell_signals['Close'],
    #         mode='markers',
    #         name='Sell Signal',
    #         marker=dict(symbol='triangle-down', size=12, color='red')
    #     ))
        
    #     fig.update_layout(
    #         title=f"{indicator} Analysis for {ticker}",
    #         xaxis_title="Date",
    #         yaxis_title="Price",
    #         height=600,
    #         legend=dict(
    #             yanchor="top",
    #             y=0.99,
    #             xanchor="left",
    #             x=0.01
    #         )
    #     )
        
    #     chart = dcc.Graph(figure=fig)
        
    #     # Create trade table with detailed information
    #     trades = result['trades']
    #     trade_table = dash_table.DataTable(
    #         data=[{
    #             'Date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
    #             'Type': t['type'],
    #             'Price': f"{t['price']:.2f}",
    #             'Shares': t['shares'],
    #             'Value': f"{t['value']:,.2f}",
    #             'Cash': f"{t['remaining_cash']:,.2f}"
    #         } for t in trades if hasattr(t['date'], 'strftime') or isinstance(t['date'], str)],
    #         columns=[
    #             {'name': 'Date', 'id': 'Date'},
    #             {'name': 'Type', 'id': 'Type'},
    #             {'name': 'Price', 'id': 'Price'},
    #             {'name': 'Shares', 'id': 'Shares'},
    #             {'name': 'Value', 'id': 'Value'},
    #             {'name': 'Cash', 'id': 'Cash'}
    #         ],
    #         style_table={'overflowX': 'auto'},
    #         style_cell={'textAlign': 'left', 'padding': '10px'},
    #         style_data_conditional=[
    #             {
    #                 'if': {'filter_query': '{Type} = "Buy"'},
    #                 'backgroundColor': 'rgba(0, 255, 0, 0.1)',
    #                 'color': 'green'
    #             },
    #             {
    #                 'if': {'filter_query': '{Type} = "Sell"'},
    #                 'backgroundColor': 'rgba(255, 0, 0, 0.1)',
    #                 'color': 'red'
    #             }
    #         ],
    #         style_header={
    #             'backgroundColor': 'rgb(240, 240, 240)',
    #             'fontWeight': 'bold'
    #         },
    #         page_size=10
    #     )
        
    #     return html.Div([
    #         metrics,
    #         chart,
    #         html.H4("Detailed Trade History", className="text-lg font-semibold mt-4 mb-3"),
    #         trade_table
    #     ], className="mt-4 p-3")

    

    # def create_signal_distribution_chart(df, ticker):
    #     """Create a signal distribution chart"""
    #     signal_cols = [col for col in df.columns if col.endswith('_Signal')]
    #     signal_data = []
        
    #     for col in signal_cols:
    #         if col not in df.columns:
    #             continue
                
    #         buy_count = len(df[df[col] == 'Buy'])
    #         sell_count = len(df[df[col] == 'Sell'])
    #         hold_count = len(df[df[col] == 'Hold'])
            
    #         signal_data.extend([
    #             {'Indicator': col, 'Signal': 'Buy', 'Count': buy_count},
    #             {'Indicator': col, 'Signal': 'Sell', 'Count': sell_count},
    #             {'Indicator': col, 'Signal': 'Hold', 'Count': hold_count}
    #         ])
        
    #     # Create figure
    #     fig = go.Figure()
        
    #     # Add traces for Buy, Sell and Hold signals
    #     indicators = list(set(item['Indicator'] for item in signal_data))
        
    #     for signal_type, color in [('Buy', 'green'), ('Sell', 'red'), ('Hold', 'gray')]:
    #         fig.add_trace(go.Bar(
    #             name=signal_type,
    #             x=indicators,
    #             y=[item['Count'] for item in signal_data if item['Signal'] == signal_type],
    #             marker_color=color
    #         ))
        
    #     fig.update_layout(
    #         title=f"Signal Distribution for {ticker}",
    #         xaxis_title="Indicator",
    #         yaxis_title="Count",
    #         barmode='group',
    #         height=400
    #     )
        
    #     return fig

    # def create_capital_growth_chart(result, ticker, indicator):
    #     """Create a capital growth chart for a specific result"""
    #     if not result or 'trades' not in result or not result['trades']:
    #         return go.Figure()
        
    #     # Get trade data
    #     trades = result['trades']
    #     initial_capital = result['initial_capital']
        
    #     # Create figure
    #     fig = go.Figure()
        
    #     # Add capital trace
    #     fig.add_trace(go.Scatter(
    #         x=list(range(len(trades))),
    #         y=[t['remaining_cash'] for t in trades],
    #         mode='lines+markers',
    #         name='Capital',
    #         line=dict(color='blue', width=2),
    #         marker=dict(
    #             size=10,
    #             color=['green' if t['type'] == 'Buy' else 'red' for t in trades],
    #             symbol=['triangle-up' if t['type'] == 'Buy' else 'triangle-down' for t in trades]
    #         )
    #     ))
        
    #     # Add initial capital reference line
    #     fig.add_shape(
    #         type="line",
    #         x0=0,
    #         y0=initial_capital,
    #         x1=len(trades)-1 if trades else 0,
    #         y1=initial_capital,
    #         line=dict(
    #             color="gray",
    #             width=1,
    #             dash="dash",
    #         )
    #     )
        
    #     fig.update_layout(
    #         title=f"Capital Growth for {ticker} using {indicator}",
    #         xaxis_title="Trade Number",
    #         yaxis_title="Capital Value",
    #         height=400,
    #         legend=dict(
    #             yanchor="top",
    #             y=0.99,
    #             xanchor="left",
    #             x=0.01
    #         )
    #     )
        
    #     return fig




    # RAW DATA SECTION


    def create_raw_data_explorer(raw_data):
        """Create a raw data explorer with comprehensive technical analysis results"""
        if not raw_data:
            return html.Div("No raw data available", className="text-center text-gray-500 p-4")
        
        # Store raw data in a hidden div for access by callbacks
        stored_data = html.Div(id='stored-raw-data', style={'display': 'none'}, 
                            children=json.dumps(raw_data))
        
        # Calculate comprehensive statistics from raw data
        total_tickers = len(raw_data)
        total_records = sum(len(data) for data in raw_data.values())
        avg_records_per_ticker = total_records / max(1, total_tickers)
        
        # Get date range from data
        all_dates = []
        for ticker_data in raw_data.values():
            for item in ticker_data:
                if 'Datetime' in item and item['Datetime']:
                    try:
                        all_dates.append(pd.to_datetime(item['Datetime']))
                    except:
                        continue
        
        date_range_text = "No valid dates"
        if all_dates:
            min_date = min(all_dates).strftime('%Y-%m-%d')
            max_date = max(all_dates).strftime('%Y-%m-%d')
            date_range_text = f"{min_date} to {max_date}"
        
        # Analyze technical indicators across all data - FIXED to include candlestick
        all_indicators = set()
        signal_summary = {}
        
        for ticker, ticker_data in raw_data.items():
            signal_summary[ticker] = {}
            for record in ticker_data:
                for key in record.keys():
                    # Tambahkan semua kolom yang berakhiran _Signal atau persis Combined_Signal, kecuali detected_patterns
                    if (key.endswith('_Signal') or key == 'Combined_Signal') and key != 'detected_patterns':
                        all_indicators.add(key)
                        if key not in signal_summary[ticker]:
                            signal_summary[ticker][key] = {'Buy': 0, 'Sell': 0, 'Hold': 0, 'High Volume': 0, 'Low Volume': 0}
                        signal_value = record.get(key, 'Hold')
                        if signal_value in signal_summary[ticker][key]:
                            signal_summary[ticker][key][signal_value] += 1
                        
                        # Count different signal types
                        # value = item.get(key, '')
                        # if value == 'Buy':
                        #     signal_summary[key]['buy'] += 1
                        # elif value == 'Sell':
                        #     signal_summary[key]['sell'] += 1
                        # elif value == 'Hold':
                        #     signal_summary[key]['hold'] += 1
                        # elif value == 'High Volume':
                        #     signal_summary[key]['high_volume'] += 1
                        # elif value == 'Low Volume':
                        #     signal_summary[key]['low_volume'] += 1
                        # elif value == 'Uptrend':
                        #     signal_summary[key]['uptrend'] += 1
                        # elif value == 'Downtrend':
                        #     signal_summary[key]['downtrend'] += 1
                        # elif value == 'Sideways':
                        #     signal_summary[key]['sideways'] += 1
        
        return html.Div([
            stored_data,
            html.Div([
                html.H3("ðŸ“Š Data Analysis Overview", className="text-xl font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Div([
                            html.Span("Total Tickers", className="block text-sm text-gray-500"),
                            html.Span(f"{total_tickers}", className="block text-xl font-bold text-blue-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Total Records", className="block text-sm text-gray-500"),
                            html.Span(f"{total_records:,}", className="block text-xl font-bold text-green-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Avg Records/Ticker", className="block text-sm text-gray-500"),
                            html.Span(f"{avg_records_per_ticker:.0f}", className="block text-xl font-bold text-purple-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Date Range", className="block text-sm text-gray-500"),
                            html.Span(date_range_text, className="block text-lg font-bold text-orange-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2")
                ], className="flex -mx-2 mb-6"),
                html.Div([
                    html.H4("ðŸ”§ Technical Indicators Detected", className="text-lg font-semibold mb-3"),
                    html.Div([
                        # html.Span(f"Found {len([ind for ind in all_indicators if ind != 'detected_patterns'])} indicators: ", className="font-medium"),
                        # html.Span(", ".join(sorted([ind for ind in all_indicators if ind != 'detected_patterns'])), className="text-blue-600")
                        html.Span(f"Found {len(all_indicators)} indicators: ", className="font-medium"),
                        html.Span(", ".join(sorted(all_indicators)), className="text-blue-600")
                    ], className="p-3 bg-blue-50 rounded-lg border border-blue-200")
                ], className="mb-6")
            ], className="mb-4"),
            dcc.Tabs([
                dcc.Tab(
                    label="ðŸ“ˆ General Summary & Analysis",
                    className="font-semibold py-3 px-4",
                    selected_className="bg-blue-50 border-b-2 border-blue-600",
                    children=[
                        html.Div([
                            html.Div([
                                html.H4("ðŸ“Š Signal Analysis Summary", className="text-lg font-semibold mb-3"),
                                create_global_signal_analysis_table(signal_summary, all_indicators)
                            ], className="mb-6"),
                            html.Div([
                                html.H4("ðŸ“‹ Ticker Analysis Summary", className="text-lg font-semibold mb-3"),
                                create_enhanced_ticker_summary_table(raw_data, signal_summary)
                            ], className="mb-6"),
                            html.Div([
                                html.H4("ðŸ“ˆ Data Quality & Signal Distribution Overview", className="text-lg font-semibold mb-3"),
                                html.P("The following charts show data completeness and signal distribution across all tickers:", 
                                    className="text-gray-600 mb-3"),
                                dcc.Graph(
                                    figure=generate_enhanced_data_quality_chart(raw_data, signal_summary),
                                    config={'displayModeBar': True},
                                    style={'height': '500px'}
                                )
                            ])
                        ], className="mt-4")
                    ]
                ),
                dcc.Tab(
                    label="ðŸŽ¯ Ticker-Specific Analysis", 
                    className="font-semibold py-3 px-4",
                    selected_className="bg-blue-50 border-b-2 border-blue-600",
                    children=[
                        html.Div([
                            html.Div([
                                html.Label("ðŸŽ¯ Select Ticker for Detailed Analysis:", className="mr-2 font-medium text-lg"),
                                dcc.Dropdown(
                                    id="raw-data-ticker-selector-unique",
                                    options=[{
                                        'label': f"{ticker} ({len(raw_data[ticker])} records, {len([r for r in raw_data[ticker] if any(r.get(ind, '') in ['Buy', 'Sell'] for ind in all_indicators)])} signals)",
                                        'value': ticker
                                    } for ticker in sorted(raw_data.keys())],
                                    value=list(raw_data.keys())[0] if raw_data else None,
                                    className="w-full"
                                )
                            ], className="mb-4"),
                            html.Div([
                                html.Div([
                                    html.Label("ðŸ” Search Data:", className="mr-2 font-medium"),
                                    dcc.Input(
                                        id="raw-data-search-unique",
                                        type="text",
                                        placeholder="Enter date (YYYY-MM-DD), price range, or indicator name...",
                                        className="p-2 border rounded flex-grow"
                                    )
                                ], className="flex items-center mb-3"),
                                
                                html.Div([
                                    html.Label("ðŸ“Š Filter by Signal Type:", className="mr-2 font-medium"),
                                    dcc.Dropdown(
                                        id="raw-data-signal-filter-unique",
                                        options=[
                                            {'label': 'All Signals', 'value': 'all'},
                                            {'label': 'Buy Signals Only', 'value': 'Buy'},
                                            {'label': 'Sell Signals Only', 'value': 'Sell'},
                                            {'label': 'Hold Signals Only', 'value': 'Hold'},
                                            {'label': 'High Volume Only', 'value': 'High Volume'},
                                            {'label': 'Low Volume Only', 'value': 'Low Volume'},
                                            {'label': 'Uptrend Only', 'value': 'Uptrend'},
                                            {'label': 'Downtrend Only', 'value': 'Downtrend'},
                                            {'label': 'Sideways Only', 'value': 'Sideways'}
                                        ],
                                        value='all',
                                        clearable=False,
                                        className="w-64"
                                    )
                                ], className="flex items-center mb-3"),
                                
                                html.Div([
                                    html.Label("ðŸ”§ Filter by Indicator:", className="mr-2 font-medium"),
                                    dcc.Dropdown(
                                        id="raw-data-indicator-filter-unique",
                                        options=[{'label': 'All Indicators', 'value': 'all'}] + 
                                            [{'label': ind.replace('_Signal', '').replace('candlestick_trend', 'Candlestick Trend'), 'value': ind} for ind in sorted(all_indicators)],
                                        value='all',
                                        clearable=False,
                                        className="w-64"
                                    )
                                ], className="flex items-center")
                            ], className="mb-4 p-3 bg-gray-50 rounded"),
                            dcc.Tabs([
                                dcc.Tab(label="ðŸ“Š Data Table & Analysis", children=[
                                    html.Div(id="selected-ticker-data-unique", className="mt-4")
                                ]),
                                dcc.Tab(label="ðŸ“ˆ Price Chart with Signals", children=[
                                    dcc.Loading(
                                        id="loading-price-chart-unique",
                                        type="circle",
                                        children=html.Div(id="ticker-price-chart-unique", className="mt-4")
                                    )
                                ]),
                                dcc.Tab(label="ðŸŽ¯ Signal Distribution Analysis", children=[
                                    dcc.Loading(
                                        id="loading-signal-chart-unique",
                                        type="circle",
                                        children=html.Div(id="ticker-signal-chart-unique", className="mt-4")
                                    )
                                ]),
                                # dcc.Tab(label="ðŸ”§ Technical Indicators Detail", children=[
                                #     dcc.Loading(
                                #         id="loading-indicators-chart-unique",
                                #         type="circle",
                                #         children=html.Div(id="ticker-indicators-chart-unique", className="mt-4")
                                #     )
                                # ])
                            ])
                        ], className="mt-4")
                    ]
                )
            ])
        ])

    # CALLBACK DENGAN NAMA UNIQUE - FIXED UNTUK ADVANCED SEARCH
    @app.callback(
        [Output("selected-ticker-data-unique", "children"),  
        Output("ticker-price-chart-unique", "children"),    
        Output("ticker-signal-chart-unique", "children")],   # REMOVED: ticker-indicators-chart-unique
        [Input("raw-data-ticker-selector-unique", "value"),     
        Input("raw-data-search-unique", "value"),              
        Input("raw-data-signal-filter-unique", "value"),       
        Input("raw-data-indicator-filter-unique", "value")],   
        [State("stored-raw-data", "children")]
    )
    def update_raw_data_ticker_specific_content_unique(selected_ticker, search_term, signal_filter, indicator_filter, stored_data):
        if not selected_ticker or not stored_data:
            return [html.Div("Please select a ticker", className="text-gray-500")] * 3  # Changed from 4 to 3
        
        try:
            # Parse stored raw data
            raw_data = json.loads(stored_data)
            ticker_data = raw_data.get(selected_ticker, [])
            
            if not ticker_data:
                return [html.Div("No data available for selected ticker", className="text-gray-500")] * 3  # Changed from 4 to 3
            
            # Convert to DataFrame
            df = pd.DataFrame(ticker_data)
            
            # Convert Datetime column
            if 'Datetime' in df.columns:
                df['Datetime'] = pd.to_datetime(df['Datetime'], errors='coerce')
            
            # Apply advanced search filter
            filtered_df = apply_advanced_search_filter(df, search_term, signal_filter, indicator_filter)
            
            # Generate content for each tab (removed indicators_chart)
            data_content = generate_ticker_data_content_unique(filtered_df, selected_ticker)
            price_chart = create_enhanced_price_chart_unique(filtered_df, selected_ticker)
            signal_chart = create_enhanced_signal_distribution_chart_unique(filtered_df, selected_ticker)
            
            return data_content, price_chart, signal_chart  # Removed indicators_chart return
            
        except Exception as e:
            error_msg = html.Div(f"Error processing data: {str(e)}", className="text-red-500")
            return [error_msg] * 3

    def apply_advanced_search_filter(df, search_term, signal_filter, indicator_filter):
        """Apply advanced search filtering with improved logic"""
        filtered_df = df.copy()
        
        # Apply search term filter
        if search_term and search_term.strip():
            search_term = search_term.strip().lower()
            
            # Initialize mask as False
            search_mask = pd.Series([False] * len(df))
            
            # Search in different columns based on search term
            if '-' in search_term and len(search_term) == 10:  # Date format YYYY-MM-DD
                try:
                    search_date = pd.to_datetime(search_term)
                    if 'Datetime' in df.columns:
                        search_mask |= df['Datetime'].dt.date == search_date.date()
                except:
                    pass
            
            # Search in price columns
            try:
                search_value = float(search_term)
                for price_col in ['Open', 'High', 'Low', 'Close']:
                    if price_col in df.columns:
                        search_mask |= (df[price_col] >= search_value * 0.95) & (df[price_col] <= search_value * 1.05)
            except ValueError:
                pass
            
            # Search in indicator names and signal values
            for col in df.columns:
                if df[col].dtype == 'object':
                    search_mask |= df[col].astype(str).str.lower().str.contains(search_term, na=False)
            
            # Search in column names (for indicator names)
            matching_columns = [col for col in df.columns if search_term in col.lower()]
            for col in matching_columns:
                search_mask |= df[col].notna()
            
            filtered_df = filtered_df[search_mask]
        
        # Apply signal filter
        if signal_filter != 'all':
            signal_mask = pd.Series([False] * len(filtered_df))
            
            for col in filtered_df.columns:
                if col.endswith('_Signal') or col == 'Combined_Signal' or col == 'candlestick_trend':
                    signal_mask |= (filtered_df[col] == signal_filter)
            
            filtered_df = filtered_df[signal_mask]
        
        # Apply indicator filter
        if indicator_filter != 'all':
            if indicator_filter in filtered_df.columns:
                # Show only rows where this indicator has a signal
                indicator_mask = filtered_df[indicator_filter].notna()
                if indicator_filter.endswith('_Signal') or indicator_filter == 'candlestick_trend':
                    indicator_mask &= filtered_df[indicator_filter] != 'Hold'
                filtered_df = filtered_df[indicator_mask]
        
        return filtered_df

    def create_ticker_summary_stats_unique(filtered_df, selected_ticker):
        """Create summary statistics for a selected ticker including ALL technical analysis"""
        if filtered_df.empty:
            return html.Div("No data available after filtering", className="text-gray-500 p-4")
        
        # Calculate basic statistics
        total_records = len(filtered_df)
        date_range = f"{filtered_df['Datetime'].min().strftime('%Y-%m-%d')} to {filtered_df['Datetime'].max().strftime('%Y-%m-%d')}" if 'Datetime' in filtered_df.columns else "N/A"
        
        # Price statistics
        if 'Close' in filtered_df.columns:
            price_current = filtered_df['Close'].iloc[-1] if not filtered_df['Close'].empty else 0
            price_min = filtered_df['Close'].min()
            price_max = filtered_df['Close'].max()
            price_avg = filtered_df['Close'].mean()
        else:
            price_current = price_min = price_max = price_avg = 0
        
        # ALL Technical indicator statistics
        all_tech_indicators = ['RSI', 'MACD', 'ADX', 'Upper Band', 'Lower Band', 'Middle Band', 
                            'short_MA', 'long_MA', '+DI', '-DI', 'Signal_Line', 'MACD_Hist', 'VMA']
        tech_stats = {}
        
        for indicator in all_tech_indicators:
            if indicator in filtered_df.columns and not filtered_df[indicator].isna().all():
                current_val = filtered_df[indicator].iloc[-1] if not filtered_df[indicator].empty else 0
                avg_val = filtered_df[indicator].mean()
                tech_stats[indicator] = {
                    'current': current_val,
                    'average': avg_val
                }
        
        # ALL Signal statistics
        all_signal_cols = [col for col in filtered_df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        signal_stats = {}
        
        for col in all_signal_cols:
            if col in filtered_df.columns:
                signal_counts = filtered_df[col].value_counts()
                signal_stats[col] = {
                    'Buy': signal_counts.get('Buy', 0),
                    'Sell': signal_counts.get('Sell', 0),
                    'Hold': signal_counts.get('Hold', 0)
                }
        
        # Volume analysis
        volume_stats = {}
        if 'Volume_Signal' in filtered_df.columns:
            volume_counts = filtered_df['Volume_Signal'].value_counts()
            volume_stats = {
                'High Volume': volume_counts.get('High Volume', 0),
                'Low Volume': volume_counts.get('Low Volume', 0)
            }
        
        # Candlestick analysis
        candlestick_stats = {}
        if 'candlestick_trend' in filtered_df.columns:
            trend_counts = filtered_df['candlestick_trend'].value_counts()
            candlestick_stats = {
                'Uptrend': trend_counts.get('Uptrend', 0),
                'Downtrend': trend_counts.get('Downtrend', 0),
                'Sideways': trend_counts.get('Sideways', 0)
            }
        
        # Pattern detection stats
        pattern_stats = {}
        if 'detected_patterns' in filtered_df.columns:
            pattern_data = filtered_df['detected_patterns'].dropna()
            total_patterns = len([p for p in pattern_data if p and p != ''])
            pattern_stats = {'Total Patterns Detected': total_patterns}
        
        return html.Div([
            html.H4(f"ðŸ“Š Technical Analysis Summary for {selected_ticker}", className="text-lg font-semibold mb-3"),
            html.Div([
                html.Div([
                    html.Span("Total Records: ", className="font-semibold"),
                    html.Span(f"{total_records:,}", className="text-blue-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Date Range: ", className="font-semibold"),
                    html.Span(date_range, className="text-gray-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Current Price: ", className="font-semibold"),
                    html.Span(f"{price_current:.2f}", className="text-green-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Price Range: ", className="font-semibold"),
                    html.Span(f"{price_min:.2f} - {price_max:.2f} (Avg: {price_avg:.2f})", className="text-gray-600")
                ], className="mb-2")
            ], className="mb-4"),
            
            # ALL Technical Indicators Section
            html.Div([
                html.H5("ðŸ”§ Technical Indicators:", className="font-semibold mb-2"),
                html.Div([
                    html.Div([
                        html.Strong(f"{indicator}: "),
                        html.Span(f"Current: {stats['current']:.2f}, ", className="text-blue-600"),
                        html.Span(f"Avg: {stats['average']:.2f}", className="text-gray-600"),
                        html.Span(
                            " (Overbought)" if indicator == 'RSI' and stats['current'] > 70 
                            else " (Oversold)" if indicator == 'RSI' and stats['current'] < 30 
                            else " (Strong Trend)" if indicator == 'ADX' and stats['current'] > 25
                            else " (Weak Trend)" if indicator == 'ADX' and stats['current'] < 25
                            else " (Bullish)" if indicator == 'MACD_Hist' and stats['current'] > 0
                            else " (Bearish)" if indicator == 'MACD_Hist' and stats['current'] < 0
                            else " (Normal)",
                            className="text-red-600" if (indicator == 'RSI' and stats['current'] > 70) or (indicator == 'MACD_Hist' and stats['current'] < 0)
                            else "text-green-600" if (indicator == 'RSI' and stats['current'] < 30) or (indicator == 'ADX' and stats['current'] > 25) or (indicator == 'MACD_Hist' and stats['current'] > 0)
                            else "text-gray-500"
                        )
                    ], className="mb-1")
                    for indicator, stats in tech_stats.items()
                ])
            ], className="mb-4"),
            
            # ALL Signal Distribution Section
            html.Div([
                html.H5("ðŸŽ¯ Signal Distribution:", className="font-semibold mb-2"),
                html.Div([
                    html.Div([
                        html.Strong(f"{col.replace('_Signal', '').replace('_Combined_Signal', ' Combined')}: "),
                        html.Span(f"Buy: {stats['Buy']}, ", className="text-green-600"),
                        html.Span(f"Sell: {stats['Sell']}, ", className="text-red-600"),
                        html.Span(f"Hold: {stats['Hold']}", className="text-blue-600"),
                        html.Span(f" | Win Rate: {(stats['Buy']/(stats['Buy']+stats['Sell'])*100):.1f}%" if (stats['Buy']+stats['Sell']) > 0 else " | Win Rate: 0%", 
                                className="text-purple-600 ml-2")
                    ], className="mb-1")
                    for col, stats in signal_stats.items()
                ])
            ], className="mb-4"),
            
            # Volume Analysis Section
            html.Div([
                html.H5("ðŸ”Š Volume Analysis:", className="font-semibold mb-2"),
                html.Div([
                    html.Div([
                        html.Strong("Volume Distribution: "),
                        html.Span(f"High Volume: {volume_stats.get('High Volume', 0)}, ", className="text-green-600"),
                        html.Span(f"Low Volume: {volume_stats.get('Low Volume', 0)}", className="text-red-600")
                    ], className="mb-1")
                ]) if volume_stats else html.Span("No volume data available", className="text-gray-500")
            ], className="mb-4"),
            
            # Candlestick Analysis Section
            html.Div([
                html.H5("ðŸ•¯ï¸ Candlestick Analysis:", className="font-semibold mb-2"),
                html.Div([
                    html.Div([
                        html.Strong("Trend Distribution: "),
                        html.Span(f"Uptrend: {candlestick_stats.get('Uptrend', 0)}, ", className="text-green-600"),
                        html.Span(f"Downtrend: {candlestick_stats.get('Downtrend', 0)}, ", className="text-red-600"),
                        html.Span(f"Sideways: {candlestick_stats.get('Sideways', 0)}", className="text-blue-600")
                    ], className="mb-1")
                ]) if candlestick_stats else html.Span("No candlestick data available", className="text-gray-500")
            ], className="mb-4") if candlestick_stats else html.Div(),
            
            # Pattern Detection Section
            html.Div([
                html.H5("ðŸ” Pattern Detection:", className="font-semibold mb-2"),
                html.Div([
                    html.Span(f"Total Patterns: {pattern_stats.get('Total Patterns Detected', 0)}", className="text-purple-600")
                ])
            ], className="mb-4") if pattern_stats else html.Div()
            
        ], className="p-4 bg-white rounded shadow-sm mb-4")







    # def create_raw_data_explorer(raw_data):
    #     """Create a raw data explorer with comprehensive technical analysis results"""
    #     if not raw_data:
    #         return html.Div("No raw data available", className="text-center text-gray-500 p-4")
        
    #     # Store raw data in a hidden div for access by callbacks
    #     stored_data = html.Div(id='stored-raw-data', style={'display': 'none'}, 
    #                         children=json.dumps(raw_data))
        
    #     # Calculate comprehensive statistics from raw data
    #     total_tickers = len(raw_data)
    #     total_records = sum(len(data) for data in raw_data.values())
    #     avg_records_per_ticker = total_records / max(1, total_tickers)
        
    #     # Get date range from data
    #     all_dates = []
    #     for ticker_data in raw_data.values():
    #         for record in ticker_data:
    #             if 'Datetime' in record and record['Datetime']:
    #                 try:
    #                     all_dates.append(pd.to_datetime(record['Datetime']))
    #                 except:
    #                     continue
        
    #     date_range_text = "No valid dates"
    #     if all_dates:
    #         min_date = min(all_dates)
    #         max_date = max(all_dates)
    #         date_range_text = f"{min_date.strftime('%Y-%m-%d')} to {max_date.strftime('%Y-%m-%d')}"
        
    #     # Analyze technical indicators across all data
    #     all_indicators = set()
    #     signal_summary = {}
        
    #     for ticker, ticker_data in raw_data.items():
    #         signal_summary[ticker] = {}
    #         for record in ticker_data:
    #             # Find all signal columns
    #             for key in record.keys():
    #                 if key.endswith('_Signal') or key == 'Combined_Signal':
    #                     all_indicators.add(key)
    #                     if key not in signal_summary[ticker]:
    #                         signal_summary[ticker][key] = {'Buy': 0, 'Sell': 0, 'Hold': 0, 'High Volume': 0, 'Low Volume': 0}
                        
    #                     signal_value = record.get(key, 'Hold')
    #                     if signal_value in signal_summary[ticker][key]:
    #                         signal_summary[ticker][key][signal_value] += 1
        
    #     return html.Div([
    #         # Hidden div to store the raw data
    #         stored_data,
            
    #         # Overview section with enhanced statistics
    #         html.Div([
    #             html.H3("ðŸ“Š Data Analysis Overview", className="text-xl font-semibold mb-3"),
    #             html.Div([
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Total Tickers", className="block text-sm text-gray-500"),
    #                         html.Span(f"{total_tickers}", className="block text-xl font-bold text-blue-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Total Records", className="block text-sm text-gray-500"),
    #                         html.Span(f"{total_records:,}", className="block text-xl font-bold text-green-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Avg Records/Ticker", className="block text-sm text-gray-500"),
    #                         html.Span(f"{avg_records_per_ticker:.0f}", className="block text-xl font-bold text-purple-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Date Range", className="block text-sm text-gray-500"),
    #                         html.Span(date_range_text, className="block text-lg font-bold text-orange-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2")
    #             ], className="flex -mx-2 mb-6"),
                
    #             # Technical Indicators Summary
    #             html.Div([
    #                 html.H4("ðŸ”§ Technical Indicators Detected", className="text-lg font-semibold mb-3"),
    #                 html.Div([
    #                     html.Span(f"Found {len(all_indicators)} indicators: ", className="font-medium"),
    #                     html.Span(", ".join(sorted(all_indicators)), className="text-blue-600")
    #                 ], className="p-3 bg-blue-50 rounded-lg border border-blue-200")
    #             ], className="mb-6")
    #         ], className="mb-4"),
            
    #         # General vs Ticker-specific tab selector
    #         dcc.Tabs([
    #             # General Summary Tab - Enhanced
    #             dcc.Tab(
    #                 label="ðŸ“ˆ General Summary & Analysis",
    #                 className="font-semibold py-3 px-4",
    #                 selected_className="bg-blue-50 border-b-2 border-blue-600",
    #                 children=[
    #                     html.Div([
    #                         # Enhanced summary metrics
    #                         html.Div([
    #                             html.H4("ðŸ“Š Signal Analysis Summary", className="text-lg font-semibold mb-3"),
    #                             create_global_signal_analysis_table(signal_summary, all_indicators)
    #                         ], className="mb-6"),
                            
    #                         # Available tickers table with enhanced information
    #                         html.Div([
    #                             html.H4("ðŸ“‹ Ticker Analysis Summary", className="text-lg font-semibold mb-3"),
    #                             create_enhanced_ticker_summary_table(raw_data, signal_summary)
    #                         ], className="mb-6"),
                            
    #                         # Data quality overview with enhanced visualization
    #                         html.Div([
    #                             html.H4("ðŸ“ˆ Data Quality & Signal Distribution Overview", className="text-lg font-semibold mb-3"),
    #                             html.P("The following charts show data completeness and signal distribution across all tickers:", 
    #                                 className="text-gray-600 mb-3"),
    #                             dcc.Graph(
    #                                 figure=generate_enhanced_data_quality_chart(raw_data, signal_summary),
    #                                 config={'displayModeBar': True},
    #                                 style={'height': '500px'}
    #                             )
    #                         ])
    #                     ], className="mt-4")
    #                 ]
    #             ),
                
    #             # Ticker-Specific Tab - Enhanced
    #             dcc.Tab(
    #                 label="ðŸŽ¯ Ticker-Specific Analysis", 
    #                 className="font-semibold py-3 px-4",
    #                 selected_className="bg-blue-50 border-b-2 border-blue-600",
    #                 children=[
    #                     html.Div([
    #                         # Enhanced ticker selection with additional info
    #                         html.Div([
    #                             html.Label("ðŸŽ¯ Select Ticker for Detailed Analysis:", className="mr-2 font-medium text-lg"),
    #                             dcc.Dropdown(
    #                                 id="raw-data-ticker-selector-unique",  # GANTI NAMA ID YANG UNIQUE
    #                                 options=[{
    #                                     'label': f"{ticker} ({len(raw_data[ticker])} records, {len([r for r in raw_data[ticker] if any(r.get(ind, '') in ['Buy', 'Sell'] for ind in all_indicators)])} signals)",
    #                                     'value': ticker
    #                                 } for ticker in sorted(raw_data.keys())],
    #                                 value=list(raw_data.keys())[0] if raw_data else None,
    #                                 className="w-full"
    #                             )
    #                         ], className="mb-4"),
                            
    #                         # Enhanced search and filter controls
    #                         html.Div([
    #                             html.Div([
    #                                 html.Label("ðŸ” Search Data:", className="mr-2 font-medium"),
    #                                 dcc.Input(
    #                                     id="raw-data-search-unique",  # GANTI NAMA ID YANG UNIQUE
    #                                     type="text",
    #                                     placeholder="Enter date (YYYY-MM-DD) or price range...",
    #                                     className="p-2 border rounded flex-grow"
    #                                 )
    #                             ], className="flex items-center mb-3"),
                                
    #                             html.Div([
    #                                 html.Label("ðŸ“Š Filter by Signal Type:", className="mr-2 font-medium"),
    #                                 dcc.Dropdown(
    #                                     id="raw-data-signal-filter-unique",  # GANTI NAMA ID YANG UNIQUE
    #                                     options=[
    #                                         {'label': 'All Signals', 'value': 'all'},
    #                                         {'label': 'Buy Signals Only', 'value': 'Buy'},
    #                                         {'label': 'Sell Signals Only', 'value': 'Sell'},
    #                                         {'label': 'Hold Signals Only', 'value': 'Hold'}
    #                                     ],
    #                                     value='all',
    #                                     clearable=False,
    #                                     className="w-64"
    #                                 )
    #                             ], className="flex items-center mb-3"),
                                
    #                             html.Div([
    #                                 html.Label("ðŸ”§ Filter by Indicator:", className="mr-2 font-medium"),
    #                                 dcc.Dropdown(
    #                                     id="raw-data-indicator-filter-unique",  # GANTI NAMA ID YANG UNIQUE
    #                                     options=[{'label': 'All Indicators', 'value': 'all'}] + 
    #                                         [{'label': ind.replace('_Signal', ''), 'value': ind} for ind in sorted(all_indicators)],
    #                                     value='all',
    #                                     clearable=False,
    #                                     className="w-64"
    #                                 )
    #                             ], className="flex items-center")
    #                         ], className="mb-4 p-3 bg-gray-50 rounded"),
                            
    #                         # Enhanced tabs for different views of ticker data
    #                         dcc.Tabs([
    #                             dcc.Tab(label="ðŸ“Š Data Table & Analysis", children=[
    #                                 html.Div(id="selected-ticker-data-unique", className="mt-4")  # GANTI ID UNIQUE
    #                             ]),
    #                             dcc.Tab(label="ðŸ“ˆ Price Chart with Signals", children=[
    #                                 dcc.Loading(
    #                                     id="loading-price-chart-unique",  # GANTI ID UNIQUE
    #                                     type="circle",
    #                                     children=html.Div(id="ticker-price-chart-unique", className="mt-4")  # GANTI ID UNIQUE
    #                                 )
    #                             ]),
    #                             dcc.Tab(label="ðŸŽ¯ Signal Distribution Analysis", children=[
    #                                 dcc.Loading(
    #                                     id="loading-signal-chart-unique",  # GANTI ID UNIQUE
    #                                     type="circle",
    #                                     children=html.Div(id="ticker-signal-chart-unique", className="mt-4")  # GANTI ID UNIQUE
    #                                 )
    #                             ]),
    #                             dcc.Tab(label="ðŸ”§ Technical Indicators Detail", children=[
    #                                 dcc.Loading(
    #                                     id="loading-indicators-chart-unique",  # GANTI ID UNIQUE
    #                                     type="circle",
    #                                     children=html.Div(id="ticker-indicators-chart-unique", className="mt-4")  # GANTI ID UNIQUE
    #                                 )
    #                             ])
    #                         ])
    #                     ], className="mt-4")
    #                 ]
    #             )
    #         ])
    #     ])

    # # CALLBACK BARU DENGAN NAMA UNIQUE - MENGGANTI CALLBACK YANG LAMA
    # @app.callback(
    #     [Output("selected-ticker-data-unique", "children"),  
    #     Output("ticker-price-chart-unique", "children"),    
    #     Output("ticker-signal-chart-unique", "children"),   
    #     Output("ticker-indicators-chart-unique", "children")],  
    #     [Input("raw-data-ticker-selector-unique", "value"),     
    #     Input("raw-data-search-unique", "value"),              
    #     Input("raw-data-signal-filter-unique", "value"),       
    #     Input("raw-data-indicator-filter-unique", "value")],   
    #     [State("stored-raw-data", "children")]
    # )
    # def update_raw_data_ticker_specific_content_unique(selected_ticker, search_term, signal_filter, indicator_filter, stored_data):
    #     """CALLBACK BARU DENGAN NAMA UNIQUE - Combined callback for all ticker-specific content updates with improved error handling"""
        
    #     # Default empty returns
    #     empty_div = html.Div("No ticker selected", className="text-gray-500 text-center p-4")
        
    #     if not selected_ticker or not stored_data:
    #         return empty_div, empty_div, empty_div, empty_div
        
    #     try:
    #         raw_data = json.loads(stored_data)
    #         ticker_data = raw_data.get(selected_ticker, [])
            
    #         if not ticker_data:
    #             error_div = html.Div(f"No data found for {selected_ticker}", className="text-red-500 text-center p-4")
    #             return error_div, error_div, error_div, error_div
            
    #         df = pd.DataFrame(ticker_data)
            
    #         # Convert datetime if it's string with improved error handling
    #         if 'Datetime' in df.columns:
    #             try:
    #                 df['Datetime'] = pd.to_datetime(df['Datetime'], errors='coerce')
    #                 # Remove rows with invalid datetime
    #                 df = df.dropna(subset=['Datetime'])
                    
    #                 if df.empty:
    #                     error_div = html.Div("No valid datetime data found", className="text-red-500 text-center p-4")
    #                     return error_div, error_div, error_div, error_div
    #             except Exception as dt_error:
    #                 print(f"Datetime conversion error: {dt_error}")
            
    #         # Apply filters with error handling
    #         filtered_df = df.copy()
            
    #         # Search filter
    #         if search_term:
    #             try:
    #                 search_term = search_term.lower()
    #                 if search_term:
    #                     # Search in multiple columns
    #                     mask = pd.Series([False] * len(df))
    #                     for col in df.columns:
    #                         if df[col].dtype == 'object':
    #                             try:
    #                                 mask |= df[col].astype(str).str.lower().str.contains(search_term, na=False)
    #                             except:
    #                                 continue
    #                         elif col in ['Close', 'Open', 'High', 'Low']:
    #                             try:
    #                                 # Try to search for price ranges like "100-200"
    #                                 if '-' in search_term and len(search_term.split('-')) == 2:
    #                                     try:
    #                                         min_price, max_price = map(float, search_term.split('-'))
    #                                         mask |= (df[col] >= min_price) & (df[col] <= max_price)
    #                                     except:
    #                                         continue
    #                                 else:
    #                                     try:
    #                                         search_price = float(search_term)
    #                                         mask |= abs(df[col] - search_price) < (search_price * 0.01)  # 1% tolerance
    #                                     except:
    #                                         continue
    #                             except:
    #                                 continue
                        
    #                     if mask.any():
    #                         filtered_df = df[mask]
    #             except Exception as search_error:
    #                 print(f"Search filter error: {search_error}")
            
    #         # Signal filter
    #         if signal_filter != 'all':
    #             try:
    #                 signal_columns = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
    #                 if signal_columns:
    #                     signal_mask = pd.Series([False] * len(filtered_df))
    #                     for col in signal_columns:
    #                         try:
    #                             signal_mask |= (filtered_df[col] == signal_filter)
    #                         except:
    #                             continue
                        
    #                     if signal_mask.any():
    #                         filtered_df = filtered_df[signal_mask]
    #             except Exception as signal_error:
    #                 print(f"Signal filter error: {signal_error}")
            
    #         # Indicator filter
    #         if indicator_filter != 'all':
    #             try:
    #                 # Show only rows where the specific indicator has signals
    #                 if indicator_filter in filtered_df.columns:
    #                     indicator_mask = (filtered_df[indicator_filter] != 'Hold') & (filtered_df[indicator_filter].notna())
    #                     if indicator_mask.any():
    #                         filtered_df = filtered_df[indicator_mask]
    #             except Exception as indicator_error:
    #                 print(f"Indicator filter error: {indicator_error}")
            
    #         # Generate all content with error handling
    #         try:
    #             ticker_data_content = generate_ticker_data_content_unique(filtered_df, selected_ticker)
    #         except Exception as e:
    #             ticker_data_content = html.Div(f"Error generating ticker data: {str(e)}", className="text-red-500")
            
    #         try:
    #             price_chart_content = create_enhanced_price_chart_unique(df, selected_ticker)
    #         except Exception as e:
    #             price_chart_content = html.Div(f"Error generating price chart: {str(e)}", className="text-red-500")
            
    #         try:
    #             signal_chart_content = create_enhanced_signal_distribution_chart_unique(df, selected_ticker)
    #         except Exception as e:
    #             signal_chart_content = html.Div(f"Error generating signal chart: {str(e)}", className="text-red-500")
            
    #         try:
    #             indicators_chart_content = create_technical_indicators_detail_unique(df, selected_ticker)
    #         except Exception as e:
    #             indicators_chart_content = html.Div(f"Error generating indicators chart: {str(e)}", className="text-red-500")
            
    #         return ticker_data_content, price_chart_content, signal_chart_content, indicators_chart_content
            
    #     except Exception as e:
    #         error_content = html.Div([
    #             html.P(f"Error processing data: {str(e)}", className="text-red-500"),
    #             html.Details([
    #                 html.Summary("Show Full Error Details", className="cursor-pointer text-blue-600"),
    #                 html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs")
    #             ])
    #         ])
    #         return error_content, error_content, error_content, error_content












    # FUNGSI HELPER DENGAN NAMA UNIQUE
    def generate_ticker_data_content_unique(filtered_df, selected_ticker):
        """Generate ticker data content with summary and table"""
        # Create summary statistics
        summary_stats = create_ticker_summary_stats_unique(filtered_df, selected_ticker)
        
        # Create detailed table
        detailed_table = create_enhanced_ticker_table_unique(filtered_df, selected_ticker)
        
        return html.Div([
            summary_stats,
            html.Hr(className="my-4"),
            detailed_table
        ])






    # Helper functions (sudah ada sebelumnya)
    def create_global_signal_analysis_table(signal_summary, all_indicators):
        """Create a comprehensive global signal analysis table"""
        summary_data = []
        
        for indicator in sorted(all_indicators):
            total_buy = sum(ticker_signals.get(indicator, {}).get('Buy', 0) for ticker_signals in signal_summary.values())
            total_sell = sum(ticker_signals.get(indicator, {}).get('Sell', 0) for ticker_signals in signal_summary.values())
            total_hold = sum(ticker_signals.get(indicator, {}).get('Hold', 0) for ticker_signals in signal_summary.values())
            total_high_vol = sum(ticker_signals.get(indicator, {}).get('High Volume', 0) for ticker_signals in signal_summary.values())
            total_low_vol = sum(ticker_signals.get(indicator, {}).get('Low Volume', 0) for ticker_signals in signal_summary.values())
            
            total_signals = total_buy + total_sell + total_hold + total_high_vol + total_low_vol
            active_tickers = len([t for t in signal_summary.keys() if indicator in signal_summary[t] and total_signals > 0])
            
            summary_data.append({
                'Indicator': indicator.replace('_Signal', ''),
                'Total Signals': total_signals,
                'Buy': total_buy,
                'Sell': total_sell,
                'Hold': total_hold,
                'High Volume': total_high_vol,
                'Low Volume': total_low_vol,
                'Active Tickers': active_tickers,
                'Buy %': f"{(total_buy/max(1, total_signals)*100):.1f}%",
                'Sell %': f"{(total_sell/max(1, total_signals)*100):.1f}%"
            })
        
        return dash_table.DataTable(
            data=summary_data,
            columns=[
                {'name': 'Indicator', 'id': 'Indicator'},
                {'name': 'Total Signals', 'id': 'Total Signals'},
                {'name': 'Buy', 'id': 'Buy'},
                {'name': 'Sell', 'id': 'Sell'},
                {'name': 'Hold', 'id': 'Hold'},
                {'name': 'High Vol', 'id': 'High Volume'},
                {'name': 'Low Vol', 'id': 'Low Volume'},
                {'name': 'Active Tickers', 'id': 'Active Tickers'},
                {'name': 'Buy %', 'id': 'Buy %'},
                {'name': 'Sell %', 'id': 'Sell %'}
            ],
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '10px'},
            style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
            style_data_conditional=[
                {
                    'if': {'filter_query': '{Buy} > {Sell}'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)'
                },
                {
                    'if': {'filter_query': '{Sell} > {Buy}'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)'
                }
            ],
            sort_action='native',
            page_size=10
        )



    # def create_ticker_summary_stats_unique(filtered_df, selected_ticker):
    #     """Create summary statistics for a selected ticker including technical analysis"""
    #     if filtered_df.empty:
    #         return html.Div("No data available", className="text-gray-500")
        
    #     # Calculate basic statistics
    #     total_records = len(filtered_df)
    #     date_range = f"{filtered_df['Datetime'].min().strftime('%Y-%m-%d')} to {filtered_df['Datetime'].max().strftime('%Y-%m-%d')}" if 'Datetime' in filtered_df.columns else "N/A"
        
    #     # Price statistics
    #     if 'Close' in filtered_df.columns:
    #         price_current = filtered_df['Close'].iloc[-1]
    #         price_min = filtered_df['Close'].min()
    #         price_max = filtered_df['Close'].max()
    #         price_avg = filtered_df['Close'].mean()
    #     else:
    #         price_current = price_min = price_max = price_avg = "N/A"
        
    #     # Technical indicator statistics
    #     tech_stats = {}
    #     tech_indicators = ['RSI', 'MACD', 'ADX']
    #     for indicator in tech_indicators:
    #         if indicator in filtered_df.columns:
    #             tech_stats[indicator] = {
    #                 'current': filtered_df[indicator].iloc[-1],
    #                 'average': filtered_df[indicator].mean()
    #             }
        
    #     # Signal statistics
    #     signal_cols = [col for col in filtered_df.columns if col.endswith('_Signal') and col != 'Candlestick_Signal']
    #     signal_stats = {}
        
    #     for col in signal_cols:
    #         signal_counts = filtered_df[col].value_counts()
    #         signal_stats[col] = {
    #             'Buy': signal_counts.get('Buy', 0),
    #             'Sell': signal_counts.get('Sell', 0),
    #             'Hold': signal_counts.get('Hold', 0)
    #         }

    #     # Candlestick trend information
    #     candlestick_info = []
    #     if 'candlestick_trend' in filtered_df.columns:
    #         trend_counts = filtered_df['candlestick_trend'].value_counts()
    #         uptrend_count = trend_counts.get('Uptrend', 0)
    #         downtrend_count = trend_counts.get('Downtrend', 0)
    #         sideways_count = trend_counts.get('Sideways', 0)
            
    #         total_days = len(filtered_df)
            
    #         candlestick_info.extend([
    #             html.P(f"ðŸ•¯ï¸ Candlestick Trend Analysis:", className="font-semibold mt-3 mb-1"),
    #             html.P(f"â€¢ Uptrend Days: {uptrend_count} ({uptrend_count/total_days*100:.1f}%)", 
    #                 className="ml-3 mb-1 text-green-600"),
    #             html.P(f"â€¢ Downtrend Days: {downtrend_count} ({downtrend_count/total_days*100:.1f}%)", 
    #                 className="ml-3 mb-1 text-red-600"),
    #             html.P(f"â€¢ Sideways Days: {sideways_count} ({sideways_count/total_days*100:.1f}%)", 
    #                 className="ml-3 mb-1 text-blue-600")
    #         ])
            
    #         # Add pattern frequency information if available
    #         if 'detected_patterns' in filtered_df.columns:
    #             # Count top patterns
    #             pattern_counts = {}
    #             for _, row in filtered_df.iterrows():
    #                 if pd.notna(row['detected_patterns']) and row['detected_patterns']:
    #                     patterns = row['detected_patterns'].split(', ')
    #                     for pattern in patterns:
    #                         pattern_counts[pattern] = pattern_counts.get(pattern, 0) + 1
                
    #             # Get top 3 patterns
    #             top_patterns = sorted(pattern_counts.items(), key=lambda x: x[1], reverse=True)[:3]
                
    #             if top_patterns:
    #                 candlestick_info.append(html.P(f"ðŸ“Š Top Patterns Detected:", className="font-semibold mt-3 mb-1"))
    #                 for pattern, count in top_patterns:
    #                     candlestick_info.append(html.P(f"â€¢ {pattern}: {count} times ({count/total_days*100:.1f}%)", 
    #                                                 className="ml-3 mb-1 text-purple-600"))
        
    #     return html.Div([
    #         html.H4(f"ðŸ“Š Technical Analysis Summary for {selected_ticker}", className="text-lg font-semibold mb-3"),
    #         html.Div([
    #             html.Div([
    #                 html.Span("Total Records: ", className="font-semibold"),
    #                 html.Span(f"{total_records:,}", className="text-blue-600")
    #             ], className="mb-2"),
    #             html.Div([
    #                 html.Span("Date Range: ", className="font-semibold"),
    #                 html.Span(date_range, className="text-gray-600")
    #             ], className="mb-2"),
    #             html.Div([
    #                 html.Span("Current Price: ", className="font-semibold"),
    #                 html.Span(f"{price_current:.2f}", className="text-green-600")
    #             ], className="mb-2"),
    #             html.Div([
    #                 html.Span("Price Range: ", className="font-semibold"),
    #                 html.Span(f"{price_min:.2f} - {price_max:.2f} (Avg: {price_avg:.2f})", className="text-gray-600")
    #             ], className="mb-2")
    #         ], className="mb-4"),
    #         html.Div([
    #             html.H5("ðŸ”§ Technical Indicators:", className="font-semibold mb-2"),
    #             html.Div([
    #                 html.Div([
    #                     html.Strong(f"{indicator}: "),
    #                     html.Span(f"Current: {stats['current']:.2f}, ", className="text-blue-600"),
    #                     html.Span(f"Avg: {stats['average']:.2f}", className="text-gray-600"),
    #                     html.Span(
    #                         " (Overbought)" if indicator == 'RSI' and stats['current'] > 70 
    #                         else " (Oversold)" if indicator == 'RSI' and stats['current'] < 30 
    #                         else " (Neutral)",
    #                         className="text-red-600" if indicator == 'RSI' and stats['current'] > 70 
    #                         else "text-green-600" if indicator == 'RSI' and stats['current'] < 30 
    #                         else "text-gray-500"
    #                     )
    #                 ], className="mb-1")
    #                 for indicator, stats in tech_stats.items()
    #             ])
    #         ], className="mb-4"),
    #         html.Div([
    #             html.H5("ðŸŽ¯ Signal Distribution:", className="font-semibold mb-2"),
    #             html.Div([
    #                 html.Div([
    #                     html.Strong(f"{col.replace('_Signal', '')}: "),
    #                     html.Span(f"Buy: {stats['Buy']}, ", className="text-green-600"),
    #                     html.Span(f"Sell: {stats['Sell']}, ", className="text-red-600"),
    #                     html.Span(f"Hold: {stats['Hold']}", className="text-blue-600"),
    #                     html.Span(f" | Win Rate: {(stats['Buy']/(stats['Buy']+stats['Sell'])*100):.1f}%" if (stats['Buy']+stats['Sell']) > 0 else " | Win Rate: 0%", 
    #                             className="text-purple-600 ml-2")
    #                 ], className="mb-1")
    #                 for col, stats in signal_stats.items()
    #             ])
    #         ], className="mb-4"),
    #         html.Div(candlestick_info)  # Add the candlestick trend info
    #     ], className="p-4 bg-white rounded shadow-sm mb-4")


    # def create_enhanced_ticker_table_unique(filtered_df, selected_ticker):
    #     """Create enhanced data table with signal analysis dropdown"""
    #     if filtered_df.empty:
    #         return html.Div("No data to display", className="text-gray-500")
        
    #     # Get all signal columns
    #     individual_signal_cols = [col for col in filtered_df.columns 
    #                             if col.endswith('_Signal') and not col.endswith('_Combined_Signal')]
    #     voting_signal_cols = [col for col in filtered_df.columns 
    #                         if col.endswith('_Combined_Signal') and col != 'Combined_Signal']
    #     simple_combined = ['Combined_Signal'] if 'Combined_Signal' in filtered_df.columns else []
        
    #     all_signal_cols = individual_signal_cols + simple_combined + voting_signal_cols
        
    #     # Create dropdown options for signal analysis
    #     signal_analysis_options = [
    #         {'label': 'All Signals Overview', 'value': 'all'},
    #         {'label': '--- Individual Signals ---', 'value': 'separator1', 'disabled': True}
    #     ]
        
    #     # Add individual signals
    #     for col in individual_signal_cols:
    #         readable_name = col.replace('_Signal', '').replace('_', ' ')
    #         signal_analysis_options.append({
    #             'label': f"ðŸ“Š {readable_name}",
    #             'value': col
    #         })
        
    #     # Add simple combined
    #     if simple_combined:
    #         signal_analysis_options.append({'label': '--- Simple Combined ---', 'value': 'separator2', 'disabled': True})
    #         signal_analysis_options.append({
    #             'label': 'ðŸ”— Combined Signal (Simple)',
    #             'value': 'Combined_Signal'
    #         })
        
    #     # Add voting-based combined
    #     if voting_signal_cols:
    #         signal_analysis_options.append({'label': '--- Voting-Based Combined ---', 'value': 'separator3', 'disabled': True})
    #         for col in voting_signal_cols:
    #             readable_name = extract_indicators_from_combined_name(col)
    #             signal_analysis_options.append({
    #                 'label': f"ðŸ—³ï¸ {readable_name}",
    #                 'value': col
    #             })
        
    #     return html.Div([
    #         html.H4(f"ðŸ“‹ Enhanced Technical Analysis Data for {selected_ticker}", className="text-lg font-semibold mb-3"),
    #         html.P(f"Showing {len(filtered_df)} records with {len(individual_signal_cols)} individual indicators, "
    #             f"{len(simple_combined)} simple combined, and {len(voting_signal_cols)} voting-based signals.", 
    #             className="text-sm text-gray-600 mb-3"),
            
    #         # Signal Analysis Dropdown
    #         html.Div([
    #             html.Label("ðŸ” Select Signal for Detailed Analysis:", className="block text-sm font-medium text-gray-700 mb-2"),
    #             dcc.Dropdown(
    #                 id=f'signal-analysis-dropdown-{selected_ticker.replace(".", "-")}',
    #                 options=signal_analysis_options,
    #                 value='all',
    #                 className="w-full mb-4",
    #                 placeholder="Choose a signal to analyze..."
    #             )
    #         ], className="mb-6 p-4 bg-gray-50 rounded-lg border"),
            
    #         # Dynamic content based on dropdown selection
    #         html.Div(id=f'signal-analysis-content-{selected_ticker.replace(".", "-")}', className="mb-6"),
            
    #         # Complete data table
    #         html.H5("ðŸ“Š Complete Data Table (All Signals)", className="text-md font-semibold mt-6 mb-3"),
    #         create_complete_data_table(filtered_df, all_signal_cols)
    #     ])

    # TICKER DETAIL RESULT TABLE
    def create_enhanced_ticker_table_unique(filtered_df, selected_ticker):
        """Create enhanced data table with signal analysis dropdown - RESTORED TO 9 JUNI VERSION"""
        
        print(f"ðŸ—ï¸ Creating enhanced ticker table for: {selected_ticker}")
        print(f"ðŸ“Š DataFrame shape: {filtered_df.shape}")
        
        if filtered_df.empty:
            print("âŒ DataFrame is empty")
            return html.Div("No data to display", className="text-gray-500")
        
        try:
            # Get all signal columns with error handling
            individual_signal_cols = [col for col in filtered_df.columns 
                                    if col.endswith('_Signal') and not col.endswith('_Combined_Signal')]
            voting_signal_cols = [col for col in filtered_df.columns 
                                if col.endswith('_Combined_Signal') and col != 'Combined_Signal']
            simple_combined = ['Combined_Signal'] if 'Combined_Signal' in filtered_df.columns else []
            
            all_signal_cols = individual_signal_cols + simple_combined + voting_signal_cols
            
            print(f"ðŸŽ¯ Found signal columns:")
            print(f"   Individual: {individual_signal_cols}")
            print(f"   Simple combined: {simple_combined}")
            print(f"   Voting combined: {voting_signal_cols}")
            print(f"   Total: {len(all_signal_cols)} signals")
            
            # Select relevant columns for display dengan urutan yang lebih baik
            display_columns = ['Datetime']
            
            # Add price columns if available
            price_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
            for col in price_cols:
                if col in filtered_df.columns:
                    display_columns.append(col)
            
            # Add technical indicator values
            tech_cols = ['RSI', 'MACD', 'Signal_Line', 'MACD_Hist', 'ADX', '+DI', '-DI', 
                        'Upper Band', 'Middle Band', 'Lower Band', 'short_MA', 'long_MA', 'VMA']
            for col in tech_cols:
                if col in filtered_df.columns:
                    display_columns.append(col)
            
            # Add signal columns at the end
            display_columns.extend(all_signal_cols)
            
            # Filter DataFrame to display columns
            display_df = filtered_df[display_columns].copy()
            
            # Format datetime for display
            if 'Datetime' in display_df.columns:
                display_df['Datetime'] = display_df['Datetime'].dt.strftime('%Y-%m-%d %H:%M')
            
            # Format numeric columns
            for col in display_df.columns:
                if col in ['Open', 'High', 'Low', 'Close']:
                    try:
                        display_df[col] = display_df[col].round(2)
                    except:
                        pass
                elif col in ['RSI', 'MACD', 'Signal_Line', 'MACD_Hist', 'ADX', '+DI', '-DI', 
                            'Upper Band', 'Middle Band', 'Lower Band', 'short_MA', 'long_MA', 'VMA']:
                    try:
                        display_df[col] = display_df[col].round(4)
                    except:
                        pass
            
            # Generate technical analysis breakdown tables (LIKE 9 JUNI VERSION)
            tech_analysis_breakdown = create_technical_analysis_breakdown_tables(filtered_df, all_signal_cols)
            
            # Create dropdown options for signal analysis (RESTORED FROM BACKUP)
            signal_analysis_options = [
                {'label': 'All Signals Overview', 'value': 'all'},
                {'label': '--- Individual Signals ---', 'value': 'separator1', 'disabled': True}
            ]
            
            # Add individual signals
            for col in individual_signal_cols:
                readable_name = col.replace('_Signal', '').replace('_', ' ')
                signal_analysis_options.append({
                    'label': f"ðŸ“Š {readable_name}",
                    'value': col
                })
            
            # Add simple combined
            if simple_combined:
                signal_analysis_options.append({'label': '--- Simple Combined ---', 'value': 'separator2', 'disabled': True})
                signal_analysis_options.append({
                    'label': 'ðŸ”— Combined Signal (Simple)',
                    'value': 'Combined_Signal'
                })
            
            # Add voting-based combined
            if voting_signal_cols:
                signal_analysis_options.append({'label': '--- Voting-Based Combined ---', 'value': 'separator3', 'disabled': True})
                for col in voting_signal_cols:
                    try:
                        readable_name = extract_indicators_from_combined_name(col)
                        signal_analysis_options.append({
                            'label': f"ðŸ—³ï¸ {readable_name}",
                            'value': col
                        })
                    except Exception as name_error:
                        print(f"âš ï¸ Error extracting name for {col}: {name_error}")
                        signal_analysis_options.append({
                            'label': f"ðŸ—³ï¸ {col.replace('_Combined_Signal', '')}",
                            'value': col
                        })
            
            # Create safe ticker ID for pattern matching
            ticker_safe = selected_ticker.replace(".", "-").replace(" ", "-").replace("/", "-")
            print(f"ðŸŽ« Using ticker ID: {ticker_safe}")
            
            # Prepare data for storage
            data_for_storage = filtered_df.copy()
            if 'Datetime' in data_for_storage.columns:
                data_for_storage['Datetime'] = data_for_storage['Datetime'].astype(str)
            
            # Convert to JSON safely
            try:
                json_data = data_for_storage.to_json(date_format='iso', orient='split')
                print(f"âœ… Data converted to JSON successfully, length: {len(json_data)}")
            except Exception as json_error:
                print(f"âŒ JSON conversion error: {json_error}")
                json_data = "{}"
            
            # CREATE THE MAIN LAYOUT - RESTORED 9 JUNI STRUCTURE
            return html.Div([
                html.H4(f"ðŸ“‹ Enhanced Technical Analysis Data for {selected_ticker}", className="text-lg font-semibold mb-3"),
                html.P(f"Showing {len(filtered_df)} records with {len(individual_signal_cols)} individual indicators, "
                    f"{len(simple_combined)} simple combined, and {len(voting_signal_cols)} voting-based signals.", 
                    className="text-sm text-gray-600 mb-3"),
                
                # DEBUG INFO
                html.Div([
                    html.P(f"ðŸ” DEBUG: Ticker={ticker_safe}, Signals={len(all_signal_cols)}", className="text-xs text-blue-600 mb-2"),
                    html.P(f"ðŸ“Š Dropdown options: {len(signal_analysis_options)}", className="text-xs text-blue-600 mb-2")
                ], className="p-2 bg-blue-50 rounded border mb-3"),
                
                # TECHNICAL ANALYSIS BREAKDOWN TABLES FIRST (LIKE 9 JUNI)
                tech_analysis_breakdown,
                
                # THEN SIGNAL ANALYSIS DROPDOWN SECTION
                html.Div([
                    html.H5("ðŸ” Advanced Signal Analysis", className="text-md font-semibold mt-6 mb-3"),
                    html.P("Select a specific signal for detailed analysis and effectiveness calculation:", 
                        className="text-sm text-gray-600 mb-3"),
                    
                    # Signal Analysis Dropdown
                    html.Div([
                        html.Label("Select Signal for Detailed Analysis:", className="block text-sm font-medium text-gray-700 mb-2"),
                        dcc.Dropdown(
                            id={'type': 'signal-dropdown', 'ticker': ticker_safe},
                            options=signal_analysis_options,
                            value='all',
                            className="w-full mb-4",
                            placeholder="Choose a signal to analyze...",
                            clearable=False
                        )
                    ], className="mb-6 p-4 bg-gray-50 rounded-lg border"),
                    
                    # Dynamic content container
                    html.Div(
                        id={'type': 'signal-content', 'ticker': ticker_safe}, 
                        className="mb-6",
                        children=[
                            html.Div("â³ Loading analysis...", className="text-gray-500 p-4 text-center")
                        ]
                    ),
                    
                    # Hidden store for ticker data
                    html.Div(
                        id={'type': 'ticker-store', 'ticker': ticker_safe},
                        style={'display': 'none'},
                        children=json_data
                    )
                ]),
                
                # COMPLETE RAW DATA TABLE AT THE BOTTOM (LIKE 9 JUNI)
                html.H5("ðŸ“Š Complete Raw Data Table", className="text-md font-semibold mt-6 mb-3"),
                html.P(f"Showing {len(display_df)} records with {len([col for col in display_columns if col in tech_cols])} technical indicators and {len(all_signal_cols)} signal columns.", 
                    className="text-sm text-gray-600 mb-3"),
                
                dash_table.DataTable(
                    data=display_df.to_dict('records'),
                    columns=[{'name': col, 'id': col} for col in display_df.columns],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '11px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        # Signal column styling
                        {
                            'if': {'filter_query': '{' + col + '} = "Buy"'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        } for col in all_signal_cols
                    ] + [
                        {
                            'if': {'filter_query': '{' + col + '} = "Sell"'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        } for col in all_signal_cols
                    ] + [
                        {
                            'if': {'filter_query': '{' + col + '} = "Hold"'},
                            'backgroundColor': 'rgba(128, 0, 128, 0.1)',
                            'color': 'purple'
                        } for col in all_signal_cols
                    ] + [
                        # RSI specific styling
                        {
                            'if': {'filter_query': '{RSI} > 70', 'column_id': 'RSI'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{RSI} < 30', 'column_id': 'RSI'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                            'color': 'green'
                        }
                    ],
                    page_size=20,
                    sort_action='native',
                    filter_action='native',
                    tooltip_data=[
                        {
                            column: {'value': f'{column}: {value}', 'type': 'markdown'}
                            for column, value in row.items()
                        } for row in display_df.to_dict('records')
                    ],
                    tooltip_duration=None
                )
            ])
            
            print("âœ… Enhanced ticker table created successfully")
            
        except Exception as e:
            print(f"ðŸ’¥ ERROR in create_enhanced_ticker_table_unique: {e}")
            traceback.print_exc()
            return html.Div([
                html.H4(f"ðŸ“‹ Basic Data Table for {selected_ticker}", className="text-lg font-semibold mb-3"),
                html.P(f"Error creating enhanced table: {str(e)}", className="text-red-500 mb-3"),
                html.P(f"DEBUG: DataFrame shape = {filtered_df.shape}", className="text-xs text-gray-600"),
                # Fallback to basic table
                create_basic_ticker_table(filtered_df, selected_ticker)
            ])

    # def create_technical_analysis_breakdown_tables(df, signal_cols):
    #     """Create breakdown tables for each technical analysis indicator - RESTORED 9 JUNI VERSION"""
    #     if df.empty or not signal_cols:
    #         return html.Div("No technical analysis data available", className="text-gray-500")
        
    #     # Group signal columns by indicator type
    #     indicator_groups = {}
        
    #     for col in signal_cols:
    #         if col == 'Combined_Signal':
    #             indicator_groups['Combined_Signal'] = ['Combined_Signal']
    #         elif 'Bollinger' in col:
    #             if 'Bollinger Bands' not in indicator_groups:
    #                 indicator_groups['Bollinger Bands'] = []
    #             indicator_groups['Bollinger Bands'].append(col)
    #         elif 'MA_Signal' in col:
    #             if 'Moving Average' not in indicator_groups:
    #                 indicator_groups['Moving Average'] = []
    #             indicator_groups['Moving Average'].append(col)
    #         elif 'RSI' in col:
    #             if 'RSI' not in indicator_groups:
    #                 indicator_groups['RSI'] = []
    #             indicator_groups['RSI'].append(col)
    #         elif 'MACD' in col:
    #             if 'MACD' not in indicator_groups:
    #                 indicator_groups['MACD'] = []
    #             indicator_groups['MACD'].append(col)
    #         elif 'ADX' in col:
    #             if 'ADX' not in indicator_groups:
    #                 indicator_groups['ADX'] = []
    #             indicator_groups['ADX'].append(col)
    #         elif 'Volume' in col:
    #             if 'Volume Analysis' not in indicator_groups:
    #                 indicator_groups['Volume Analysis'] = []
    #             indicator_groups['Volume Analysis'].append(col)
    #         elif 'Fibonacci' in col:
    #             if 'Fibonacci' not in indicator_groups:
    #                 indicator_groups['Fibonacci'] = []
    #             indicator_groups['Fibonacci'].append(col)
    #         elif 'Candlestick' in col:
    #             if 'Candlestick Patterns' not in indicator_groups:
    #                 indicator_groups['Candlestick Patterns'] = []
    #             indicator_groups['Candlestick Patterns'].append(col)
    #         else:
    #             # Other indicators or combined signals
    #             indicator_name = col.replace('_Signal', '').replace('_Combined_Signal', ' Combined')
    #             if indicator_name not in indicator_groups:
    #                 indicator_groups[indicator_name] = []
    #             indicator_groups[indicator_name].append(col)
        
    #     breakdown_components = []
        
    #     breakdown_components.append(html.H5("ðŸ”§ Technical Analysis Breakdown", className="text-md font-semibold mb-4"))
        
    #     for indicator_name, signal_columns in indicator_groups.items():
    #         # Create summary table for this indicator
    #         summary_table = create_indicator_summary_table(df, indicator_name, signal_columns)
            
    #         # Create detailed breakdown table for this indicator
    #         detailed_table = create_indicator_detailed_table(df, indicator_name, signal_columns)
            
    #         # Create collapsible section for each indicator
    #         breakdown_components.append(html.Div([
    #             # Summary section (always visible)
    #             html.Div([
    #                 html.H6(f"ðŸ“Š {indicator_name} Analysis", className="text-sm font-semibold mb-2"),
    #                 summary_table
    #             ], className="mb-3"),
                
    #             # Collapsible detailed section
    #             html.Details([
    #                 html.Summary(f"ðŸ“‹ View Detailed {indicator_name} Signals & Values", 
    #                         className="cursor-pointer text-sm font-medium text-blue-600 hover:text-blue-800 mb-2"),
    #                 html.Div([
    #                     detailed_table
    #                 ], className="mt-3")
    #             ], className="mb-4")
    #         ], className="p-3 border border-gray-200 rounded-lg bg-gray-50 mb-3"))
        
    #     return html.Div(breakdown_components, className="mb-6")


    def create_technical_analysis_breakdown_tables(df, signal_cols):
        """Create breakdown tables with separate sections for individual and combination indicators - COMPLETELY SEPARATED"""
        if df.empty or not signal_cols:
            return html.Div("No technical analysis data available", className="text-gray-500")
        
        # Separate signal columns by type
        individual_signal_cols = [col for col in signal_cols 
                                if col.endswith('_Signal') and not col.endswith('_Combined_Signal')]
        simple_combined = ['Combined_Signal'] if 'Combined_Signal' in signal_cols else []
        voting_combined_cols = [col for col in signal_cols 
                            if col.endswith('_Combined_Signal') and col != 'Combined_Signal']
        
        # Group individual signals by indicator type
        individual_groups = categorize_individual_signals(individual_signal_cols)
        
        # Group voting combinations by indicators used
        combination_groups = categorize_combination_signals(voting_combined_cols)
        
        breakdown_components = []
        
        # Add main header
        breakdown_components.append(html.H5("ðŸ”§ Technical Analysis Breakdown", className="text-lg font-semibold mb-4 text-blue-700"))
        
        # === SECTION 1: INDIVIDUAL TECHNICAL INDICATORS ===
        if individual_signal_cols or simple_combined:
            breakdown_components.append(html.Div([
                html.H4("ðŸ’¡ Individual Technical Indicators", className="text-xl font-bold mb-4 text-green-700"),
                html.P(f"Analysis of {len(individual_signal_cols + simple_combined)} individual technical indicators and their signals.", 
                    className="text-gray-600 mb-6"),
                
                # Individual indicators breakdown
                html.Div([
                    create_individual_indicator_section(df, indicator_name, signal_columns, i)
                    for i, (indicator_name, signal_columns) in enumerate(individual_groups.items())
                ]),
                
                # Simple combined signal if exists
                html.Div([
                    create_simple_combined_section(df, simple_combined)
                ] if simple_combined else [])
            ], className="mb-8 p-4 bg-green-50 rounded-lg border border-green-200"))
        
        # === SECTION 2: COMBINATION SIGNALS (VOTING SYSTEM) ===
        if voting_combined_cols:
            breakdown_components.append(html.Div([
                html.H4("ðŸ—³ï¸ Combination Signals (Voting System)", className="text-xl font-bold mb-4 text-purple-700"),
                html.P(f"Analysis of {len(voting_combined_cols)} combination strategies using multiple indicators with voting system.", 
                    className="text-gray-600 mb-6"),
                
                # Voting system explanation
                html.Div([
                    html.H5("ðŸ“‹ How Voting System Works", className="text-lg font-semibold mb-3"),
                    html.Ul([
                        html.Li("Each combination uses multiple indicators to make trading decisions", className="mb-2"),
                        html.Li("Majority vote determines the final signal (Buy/Sell/Hold)", className="mb-2"),
                        html.Li("Volume indicator acts as a filter: Low Volume â†’ Force Hold", className="mb-2"),
                        html.Li("Detailed breakdown shows individual indicator signals and final result", className="mb-2")
                    ], className="list-disc list-inside")
                ], className="p-4 bg-purple-100 rounded-lg border border-purple-300 mb-6"),
                
                # Combination indicators breakdown
                html.Div([
                    create_combination_indicator_section(df, combo_name, combo_data, i)
                    for i, (combo_name, combo_data) in enumerate(combination_groups.items())
                ])
            ], className="mb-8 p-4 bg-purple-50 rounded-lg border border-purple-200"))
        
        return html.Div(breakdown_components, className="mb-6")
    


    def categorize_individual_signals(individual_signal_cols):
        """Categorize individual signals by indicator type"""
        indicator_groups = {}
        
        for col in individual_signal_cols:
            if 'Bollinger' in col or 'BB' in col:
                if 'Bollinger Bands' not in indicator_groups:
                    indicator_groups['Bollinger Bands'] = []
                indicator_groups['Bollinger Bands'].append(col)
            elif 'MA_Signal' in col or ('MA' in col and 'Signal' in col):
                if 'Moving Average' not in indicator_groups:
                    indicator_groups['Moving Average'] = []
                indicator_groups['Moving Average'].append(col)
            elif 'RSI' in col:
                if 'RSI (Relative Strength Index)' not in indicator_groups:
                    indicator_groups['RSI (Relative Strength Index)'] = []
                indicator_groups['RSI (Relative Strength Index)'].append(col)
            elif 'MACD' in col:
                if 'MACD (Moving Average Convergence Divergence)' not in indicator_groups:
                    indicator_groups['MACD (Moving Average Convergence Divergence)'] = []
                indicator_groups['MACD (Moving Average Convergence Divergence)'].append(col)
            elif 'ADX' in col:
                if 'ADX (Average Directional Index)' not in indicator_groups:
                    indicator_groups['ADX (Average Directional Index)'] = []
                indicator_groups['ADX (Average Directional Index)'].append(col)
            elif 'Volume' in col:
                if 'Volume Analysis' not in indicator_groups:
                    indicator_groups['Volume Analysis'] = []
                indicator_groups['Volume Analysis'].append(col)
            elif 'Fibonacci' in col or 'FIBO' in col:
                if 'Fibonacci Retracement' not in indicator_groups:
                    indicator_groups['Fibonacci Retracement'] = []
                indicator_groups['Fibonacci Retracement'].append(col)
            elif 'Candlestick' in col or 'CANDLE' in col:
                if 'Candlestick Patterns' not in indicator_groups:
                    indicator_groups['Candlestick Patterns'] = []
                indicator_groups['Candlestick Patterns'].append(col)
            else:
                # Other individual indicators
                indicator_name = col.replace('_Signal', '').replace('_', ' ').title()
                if indicator_name not in indicator_groups:
                    indicator_groups[indicator_name] = []
                indicator_groups[indicator_name].append(col)
        
        return indicator_groups

    def categorize_combination_signals(voting_combined_cols):
        """Categorize combination signals by indicators used"""
        combination_groups = {}
        
        for col in voting_combined_cols:
            try:
                # Extract indicators from combination name
                indicators_used = extract_indicators_from_combined_name(col)
                base_indicators = extract_base_indicators_list(col)
                
                combo_key = f"{indicators_used}"
                combination_groups[combo_key] = {
                    'signal_column': col,
                    'indicators_used': indicators_used,
                    'base_indicators': base_indicators,
                    'full_name': col
                }
            except Exception as e:
                print(f"Error processing combination {col}: {e}")
                # Fallback
                combo_key = col.replace('_Combined_Signal', '').replace('_', ' + ')
                combination_groups[combo_key] = {
                    'signal_column': col,
                    'indicators_used': combo_key,
                    'base_indicators': [],
                    'full_name': col
                }
        
        return combination_groups


    def extract_base_indicators_list(combined_signal_name):
        """Extract list of base indicator column names from combined signal name"""
        try:
            base_name = combined_signal_name.replace('_Combined_Signal', '')
            parts = base_name.split('_')
            
            # Map parts to actual column names
            indicator_mapping = {
                'Bollinger': 'Bollinger_Signal',
                'BB': 'Bollinger_Signal',
                'MA': 'MA_Signal',
                'RSI': 'RSI_Signal',
                'MACD': 'MACD_Signal',
                'ADX': 'ADX_Signal',
                'Volume': 'Volume_Signal',
                'Fibonacci': 'Fibonacci_Signal',
                'FIBO': 'Fibonacci_Signal',
                'Candlestick': 'Candlestick_Signal',
                'CANDLE': 'Candlestick_Signal'
            }
            
            base_indicators = []
            for part in parts:
                if part in indicator_mapping:
                    base_indicators.append(indicator_mapping[part])
                else:
                    # Try to find partial matches or construct signal name
                    base_indicators.append(f"{part}_Signal")
            
            return base_indicators
        except Exception as e:
            print(f"Error extracting base indicators: {e}")
            return []



    def create_individual_indicator_section(df, indicator_name, signal_columns, index):
        """Create section for individual indicator with enhanced analysis"""
        try:
            # Determine color scheme and icon based on indicator type
            color_schemes = {
                'Bollinger Bands': ('green', 'ðŸ“Š'),
                'Moving Average': ('orange', 'ðŸ“ˆ'),
                'RSI (Relative Strength Index)': ('red', 'âš¡'),
                'MACD (Moving Average Convergence Divergence)': ('indigo', 'ðŸ“‰'),
                'ADX (Average Directional Index)': ('blue', 'ðŸŽ¯'),
                'Volume Analysis': ('cyan', 'ðŸ”Š'),
                'Fibonacci Retracement': ('yellow', 'ðŸ“'),
                'Candlestick Patterns': ('pink', 'ðŸ•¯ï¸')
            }
            
            color_scheme, icon = color_schemes.get(indicator_name, ('gray', 'ðŸ”§'))
            
            # Create summary table
            summary_table = create_enhanced_individual_summary_table(df, indicator_name, signal_columns)
            
            # Create detailed breakdown table
            detailed_table = create_enhanced_individual_detailed_table(df, indicator_name, signal_columns)
            
            return html.Div([
                # Section Header
                html.Div([
                    html.Div([
                        html.H5(f"{icon} {indicator_name}", className=f"text-lg font-bold text-{color_scheme}-700 mb-2"),
                        html.P(f"Signals: {', '.join([col.replace('_Signal', '') for col in signal_columns])}", 
                            className="text-sm text-gray-600 mb-2"),
                        html.P(f"Signal columns: {len(signal_columns)}", className="text-xs text-gray-500")
                    ], className="flex-1"),
                    html.Div([
                        html.Span(f"#{index+1}", className=f"inline-block px-3 py-1 bg-{color_scheme}-100 text-{color_scheme}-800 rounded-full text-sm font-semibold")
                    ])
                ], className=f"flex justify-between items-center p-4 bg-{color_scheme}-50 rounded-t-lg border-l-4 border-{color_scheme}-500"),
                
                # Summary Table Section
                html.Div([
                    html.H6("ðŸ“‹ Signal Distribution Summary", className="text-md font-semibold mb-3 text-gray-700"),
                    summary_table
                ], className="p-4 bg-white border-l-4 border-gray-200"),
                
                # Detailed Analysis Section (Collapsible)
                html.Details([
                    html.Summary(f"ðŸ” View Detailed Analysis & Values for {indicator_name}", 
                                className="cursor-pointer text-sm font-medium text-blue-600 hover:text-blue-800 p-3 bg-gray-50 rounded"),
                    html.Div([
                        html.H6("ðŸ“Š Detailed Signal Analysis with Technical Values", className="text-md font-semibold mb-3 text-gray-700"),
                        detailed_table
                    ], className="p-4 bg-gray-50 border-l-4 border-gray-300")
                ], className="border-l-4 border-gray-200"),
                
                # Separator
                html.Hr(className="my-4 border-gray-300")
                
            ], className="mb-6 border rounded-lg shadow-sm bg-white")
            
        except Exception as e:
            print(f"Error creating individual indicator section for {indicator_name}: {e}")
            return html.Div([
                html.H6(f"âŒ Error: {indicator_name}", className="text-lg font-bold text-red-600 mb-2"),
                html.P(f"Could not process signals: {signal_columns}", className="text-red-500 text-sm"),
                html.P(f"Error: {str(e)}", className="text-red-400 text-xs")
            ], className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg")




    def create_combination_indicator_section(df, combo_name, combo_data, index):
        """Create section for combination indicator with detailed breakdown of individual signals"""
        try:
            signal_column = combo_data['signal_column']
            base_indicators = combo_data['base_indicators']
            indicators_used = combo_data['indicators_used']
            
            # Create summary table for combination
            combination_summary = create_combination_summary_table(df, combo_name, signal_column, base_indicators)
            
            # Create detailed breakdown showing individual signals + combination result
            detailed_breakdown = create_combination_detailed_table(df, combo_name, signal_column, base_indicators)
            
            # Create voting analysis
            voting_analysis = create_voting_analysis_table(df, signal_column, base_indicators)
            
            return html.Div([
                # Section Header
                html.Div([
                    html.Div([
                        html.H5(f"ðŸ—³ï¸ {combo_name}", className="text-lg font-bold text-purple-700 mb-2"),
                        html.P(f"Combination of: {indicators_used}", className="text-sm text-gray-600 mb-2"),
                        html.P(f"Base indicators: {len(base_indicators)}", className="text-xs text-gray-500")
                    ], className="flex-1"),
                    html.Div([
                        html.Span(f"#{index+1}", className="inline-block px-3 py-1 bg-purple-100 text-purple-800 rounded-full text-sm font-semibold")
                    ])
                ], className="flex justify-between items-center p-4 bg-purple-50 rounded-t-lg border-l-4 border-purple-500"),
                
                # Combination Summary Section
                html.Div([
                    html.H6("ðŸ“Š Combination Signal Summary", className="text-md font-semibold mb-3 text-gray-700"),
                    combination_summary
                ], className="p-4 bg-white border-l-4 border-gray-200"),
                
                # Voting Analysis Section
                html.Div([
                    html.H6("ðŸ—³ï¸ Voting System Analysis", className="text-md font-semibold mb-3 text-gray-700"),
                    html.P("Shows how individual indicators voted and how the final decision was made.", 
                        className="text-sm text-gray-600 mb-3"),
                    voting_analysis
                ], className="p-4 bg-purple-25 border-l-4 border-purple-200"),
                
                # Detailed Breakdown Section (Collapsible)
                html.Details([
                    html.Summary(f"ðŸ” View Detailed Combination Breakdown for {combo_name}", 
                                className="cursor-pointer text-sm font-medium text-blue-600 hover:text-blue-800 p-3 bg-gray-50 rounded"),
                    html.Div([
                        html.H6("ðŸ“‹ Individual Signals + Combination Result", className="text-md font-semibold mb-3 text-gray-700"),
                        html.P("This table shows the individual signal from each indicator and the final combination result.", 
                            className="text-sm text-gray-600 mb-3"),
                        detailed_breakdown
                    ], className="p-4 bg-gray-50 border-l-4 border-gray-300")
                ], className="border-l-4 border-gray-200"),
                
                # Separator
                html.Hr(className="my-4 border-gray-300")
                
            ], className="mb-6 border rounded-lg shadow-sm bg-white")
            
        except Exception as e:
            print(f"Error creating combination indicator section for {combo_name}: {e}")
            return html.Div([
                html.H6(f"âŒ Error: {combo_name}", className="text-lg font-bold text-red-600 mb-2"),
                html.P(f"Could not process combination: {signal_column}", className="text-red-500 text-sm"),
                html.P(f"Error: {str(e)}", className="text-red-400 text-xs")
            ], className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg")




    def create_simple_combined_section(df, simple_combined):
        """Create section for simple combined signal if exists"""
        if not simple_combined:
            return html.Div()
        
        return html.Div([
            html.Div([
                html.H5("ðŸ”— Simple Combined Signal", className="text-lg font-bold text-blue-700 mb-2"),
                html.P("Basic combination of all individual indicators", className="text-sm text-gray-600 mb-2")
            ], className="p-4 bg-blue-50 rounded-t-lg border-l-4 border-blue-500"),
            
            html.Div([
                html.H6("ðŸ“‹ Simple Combined Summary", className="text-md font-semibold mb-3 text-gray-700"),
                create_enhanced_individual_summary_table(df, "Simple Combined", simple_combined)
            ], className="p-4 bg-white border-l-4 border-gray-200"),
            
            html.Hr(className="my-4 border-gray-300")
        ], className="mb-6 border rounded-lg shadow-sm bg-white")




    def create_combination_summary_table(df, combo_name, signal_column, base_indicators):
        """Create summary table for combination signal showing overall statistics"""
        summary_data = []
        
        if signal_column not in df.columns:
            return html.Div("Signal column not found", className="text-red-500")
        
        try:
            signal_counts = df[signal_column].value_counts()
            total_records = len(df)
            
            buy_count = signal_counts.get('Buy', 0)
            sell_count = signal_counts.get('Sell', 0)
            hold_count = signal_counts.get('Hold', 0)
            
            total_signals = buy_count + sell_count + hold_count
            active_signals = buy_count + sell_count
            
            if total_signals > 0:
                buy_pct = (buy_count / total_signals * 100)
                sell_pct = (sell_count / total_signals * 100)
                hold_pct = (hold_count / total_signals * 100)
                activity_rate = (active_signals / total_signals * 100)
                
                buy_sell_ratio = (buy_count / max(1, sell_count))
                
                summary_data.append({
                    'Combination': combo_name,
                    'Base Indicators': f"{len(base_indicators)} indicators",
                    'Buy Signals': buy_count,
                    'Buy %': f"{buy_pct:.1f}%",
                    'Sell Signals': sell_count,
                    'Sell %': f"{sell_pct:.1f}%",
                    'Hold Signals': hold_count,
                    'Hold %': f"{hold_pct:.1f}%",
                    'Activity Rate': f"{activity_rate:.1f}%",
                    'Buy/Sell Ratio': f"{buy_sell_ratio:.2f}",
                    'Signal Strength': 'High' if activity_rate > 25 else 'Medium' if activity_rate > 10 else 'Low'
                })
        except Exception as e:
            print(f"Error creating combination summary: {e}")
            return html.Div(f"Error processing combination summary: {str(e)}", className="text-red-500")
        
        if not summary_data:
            return html.Div("No valid combination data", className="text-gray-500")
        
        return dash_table.DataTable(
            data=summary_data,
            columns=[
                {'name': 'Combination', 'id': 'Combination'},
                {'name': 'Base Indicators', 'id': 'Base Indicators'},
                {'name': 'Buy', 'id': 'Buy Signals'},
                {'name': 'Buy %', 'id': 'Buy %'},
                {'name': 'Sell', 'id': 'Sell Signals'},
                {'name': 'Sell %', 'id': 'Sell %'},
                {'name': 'Hold', 'id': 'Hold Signals'},
                {'name': 'Hold %', 'id': 'Hold %'},
                {'name': 'Activity Rate', 'id': 'Activity Rate'},
                {'name': 'Buy/Sell Ratio', 'id': 'Buy/Sell Ratio'},
                {'name': 'Signal Strength', 'id': 'Signal Strength'}
            ],
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'center', 'padding': '8px', 'fontSize': '12px'},
            style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
            style_data_conditional=[
                {
                    'if': {'column_id': 'Buy Signals'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sell Signals'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{Signal Strength} = High'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.15)',
                    'fontWeight': 'bold'
                }
            ]
        )



    def create_voting_analysis_table(df, signal_column, base_indicators):
        """Create voting analysis showing consensus and override statistics"""
        try:
            voting_stats = calculate_detailed_voting_statistics(df, signal_column, base_indicators)
            
            voting_data = [{
                'Metric': 'Consensus Rate',
                'Value': voting_stats.get('consensus_rate', 'N/A'),
                'Description': 'Percentage of times indicators agreed (â‰¥75% agreement)'
            }, {
                'Metric': 'Volume Override Rate', 
                'Value': voting_stats.get('volume_override_rate', 'N/A'),
                'Description': 'Percentage of signals changed to Hold due to Low Volume'
            }, {
                'Metric': 'Majority Buy',
                'Value': f"{voting_stats.get('majority_buy_count', 0)} times",
                'Description': 'Times when majority voted Buy'
            }, {
                'Metric': 'Majority Sell',
                'Value': f"{voting_stats.get('majority_sell_count', 0)} times", 
                'Description': 'Times when majority voted Sell'
            }, {
                'Metric': 'Tie Situations',
                'Value': f"{voting_stats.get('tie_count', 0)} times",
                'Description': 'Times when voting resulted in tie (â†’ Hold)'
            }]
            
            return dash_table.DataTable(
                data=voting_data,
                columns=[
                    {'name': 'Metric', 'id': 'Metric'},
                    {'name': 'Value', 'id': 'Value'},
                    {'name': 'Description', 'id': 'Description'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '12px'},
                style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Metric} contains "Override"'},
                        'backgroundColor': 'rgba(255, 165, 0, 0.1)',
                        'color': 'orange'
                    },
                    {
                        'if': {'filter_query': '{Metric} contains "Consensus"'},
                        'backgroundColor': 'rgba(0, 0, 255, 0.1)',
                        'color': 'blue'
                    }
                ]
            )
        except Exception as e:
            return html.Div(f"Error creating voting analysis: {str(e)}", className="text-red-500")

    def calculate_detailed_voting_statistics(df, signal_column, base_indicators):
        """Calculate detailed voting statistics for combination signal"""
        try:
            if signal_column not in df.columns:
                return {}
            
            consensus_count = 0
            volume_override_count = 0
            majority_buy_count = 0
            majority_sell_count = 0
            tie_count = 0
            total_records = len(df)
            
            has_volume = 'Volume_Signal' in base_indicators
            regular_indicators = [ind for ind in base_indicators if ind != 'Volume_Signal']
            
            for idx in df.index:
                try:
                    # Get signals from regular indicators
                    signals = []
                    volume_signal = None
                    
                    for indicator in regular_indicators:
                        if indicator in df.columns:
                            signal = df.loc[idx, indicator]
                            if pd.notna(signal):
                                signals.append(signal)
                    
                    # Get volume signal if available
                    if has_volume and 'Volume_Signal' in df.columns:
                        volume_signal = df.loc[idx, 'Volume_Signal']
                    
                    if not signals:
                        continue
                    
                    # Count votes
                    buy_votes = signals.count('Buy')
                    sell_votes = signals.count('Sell')
                    hold_votes = signals.count('Hold')
                    
                    # Check for consensus (â‰¥75% agreement)
                    total_votes = len(signals)
                    max_votes = max(buy_votes, sell_votes, hold_votes)
                    if max_votes >= (total_votes * 0.75):
                        consensus_count += 1
                    
                    # Determine voting result
                    if buy_votes > sell_votes and buy_votes > hold_votes:
                        majority_buy_count += 1
                    elif sell_votes > buy_votes and sell_votes > hold_votes:
                        majority_sell_count += 1
                    elif buy_votes == sell_votes or (buy_votes == hold_votes and buy_votes > 0):
                        tie_count += 1
                    
                    # Check for volume override
                    if has_volume and volume_signal == 'Low Volume':
                        preliminary_result = 'Buy' if buy_votes > max(sell_votes, hold_votes) else 'Sell' if sell_votes > max(buy_votes, hold_votes) else 'Hold'
                        if preliminary_result != 'Hold':
                            volume_override_count += 1
                            
                except Exception as row_error:
                    continue
            
            return {
                'consensus_rate': f"{(consensus_count / total_records * 100):.1f}%" if total_records > 0 else "0%",
                'volume_override_rate': f"{(volume_override_count / total_records * 100):.1f}%" if has_volume and total_records > 0 else "N/A",
                'majority_buy_count': majority_buy_count,
                'majority_sell_count': majority_sell_count,
                'tie_count': tie_count
            }
            
        except Exception as e:
            print(f"Error calculating voting statistics: {e}")
            return {}




    def create_combination_detailed_table(df, combo_name, signal_column, base_indicators):
        """Create detailed table showing individual indicator signals + combination result - FIXED TO SHOW ALL DATA"""
        try:
            if signal_column not in df.columns:
                return html.Div("Signal column not available", className="text-gray-500")
            
            # Get all signals: base indicators + combined signal
            signal_columns = []
            for indicator in base_indicators:
                # For Candlestick_Signal, use candlestick_trend if available
                if indicator == 'Candlestick_Signal' and 'candlestick_trend' in df.columns:
                    signal_columns.append('candlestick_trend')
                elif indicator in df.columns:
                    signal_columns.append(indicator)
            
            # Add the combination signal at the end
            if signal_column in df.columns:
                signal_columns.append(signal_column)
            
            if not signal_columns:
                return html.Div("No signal columns available", className="text-gray-500")
            
            # Create relevant display columns
            display_columns = ['Datetime', 'Close'] + signal_columns
            
            # For candlestick patterns, add pattern information if it's one of the base indicators
            if 'Candlestick_Signal' in base_indicators and 'detected_patterns' in df.columns:
                display_columns.insert(2, 'detected_patterns')
                
            # MODIFIED: Show all data, not just active signals
            display_df = df[display_columns].copy()
            
            if 'Datetime' in display_df.columns:
                display_df['Datetime'] = display_df['Datetime'].dt.strftime('%Y-%m-%d %H:%M')
            
            # Format numeric columns
            if 'Close' in display_df.columns:
                display_df['Close'] = display_df['Close'].apply(lambda x: f"{x:.2f}" if pd.notna(x) else "")
            
            # Conditional formatting for all signal columns
            conditional_formatting = []
            
            # For each signal column, add specific formatting
            for col in signal_columns:
                if col == 'candlestick_trend':
                    # Special formatting for candlestick trend
                    conditional_formatting.extend([
                        {
                            'if': {'filter_query': '{candlestick_trend} = "Uptrend"', 'column_id': 'candlestick_trend'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                            'color': 'green',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{candlestick_trend} = "Downtrend"', 'column_id': 'candlestick_trend'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                            'color': 'red',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{candlestick_trend} = "Sideways"', 'column_id': 'candlestick_trend'},
                            'backgroundColor': 'rgba(128, 128, 128, 0.2)',
                            'color': 'gray',
                            'fontWeight': 'bold'
                        }
                    ])
                else:
                    # Regular signal formatting
                    conditional_formatting.extend([
                        {
                            'if': {'filter_query': '{' + col + '} = "Buy"', 'column_id': col},
                            'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                            'color': 'green',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{' + col + '} = "Sell"', 'column_id': col},
                            'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                            'color': 'red',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{' + col + '} = "Hold"', 'column_id': col},
                            'backgroundColor': 'rgba(128, 0, 128, 0.1)',
                            'color': 'purple'
                        },
                        {
                            'if': {'filter_query': '{' + col + '} = "High Volume"', 'column_id': col},
                            'backgroundColor': 'rgba(0, 191, 255, 0.2)',
                            'color': 'blue',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{' + col + '} = "Low Volume"', 'column_id': col},
                            'backgroundColor': 'rgba(255, 165, 0, 0.2)',
                            'color': 'orange',
                            'fontWeight': 'bold'
                        }
                    ])
            
            # Add special highlighting for the combined signal
            if signal_column in display_df.columns:
                conditional_formatting.append({
                    'if': {'column_id': signal_column},
                    'backgroundColor': 'rgba(66, 135, 245, 0.1)',
                    'border': '1px solid rgba(66, 135, 245, 0.5)'
                })
            
            # Get nice column headers
            column_mapping = {
                'Datetime': 'Date/Time',
                'Close': 'Price',
                signal_column: 'Combined Signal'
            }
            
            for ind in base_indicators:
                if ind == 'Candlestick_Signal':
                    column_mapping['candlestick_trend'] = 'Candlestick Trend'
                else:
                    column_mapping[ind] = ind.replace('_Signal', '')
            
            display_columns = [{'name': column_mapping.get(col, col), 'id': col} for col in display_df.columns]
            
            return html.Div([
                html.P([
                    f"Showing all {len(display_df)} records with base signals and combined signal result. ",
                    html.Strong("Highlighted blue border"),
                    " indicates the final combined signal.",
                ], className="text-xs text-gray-600 mb-2"),
                
                dash_table.DataTable(
                    data=display_df.to_dict('records'),
                    columns=display_columns,
                    style_table={'overflowX': 'auto', 'maxHeight': '600px'},
                    style_cell={
                        'textAlign': 'left',
                        'padding': '6px',
                        'fontSize': '11px',
                        'minWidth': '80px',
                        'maxWidth': '180px'
                    },
                    style_header={
                        'backgroundColor': 'rgb(230, 230, 230)',
                        'fontWeight': 'bold',
                        'fontSize': '11px'
                    },
                    style_data_conditional=conditional_formatting,
                    page_size=15,
                    sort_action='native',
                    filter_action='native',
                )
            ])
        except Exception as e:
            print(f"Error creating combination detailed table: {e}")
            return html.Div([
                html.P(f"Error creating signal detail table: {str(e)}", className="text-red-500 text-xs")
            ], className="p-2 bg-red-50 border border-red-200 rounded")



    def create_enhanced_individual_summary_table(df, indicator_name, signal_columns):
        """Enhanced version of individual summary table - FIXED for CANDLESTICK TREND"""
        summary_data = []
        
        for col in signal_columns:
            if col in df.columns:
                if col == 'Candlestick_Signal' and 'candlestick_trend' in df.columns:
                    # Use candlestick_trend instead of Candlestick_Signal
                    trend_counts = df['candlestick_trend'].value_counts()
                    uptrend_count = trend_counts.get('Uptrend', 0)
                    downtrend_count = trend_counts.get('Downtrend', 0)
                    sideways_count = trend_counts.get('Sideways', 0)
                    
                    total_counts = uptrend_count + downtrend_count + sideways_count
                    uptrend_pct = (uptrend_count / total_counts * 100) if total_counts > 0 else 0
                    downtrend_pct = (downtrend_count / total_counts * 100) if total_counts > 0 else 0
                    sideways_pct = (sideways_count / total_counts * 100) if total_counts > 0 else 0
                    
                    summary_data.append({
                        'Signal Type': 'Candlestick Trend',
                        'Uptrend': uptrend_count,
                        'Uptrend %': f"{uptrend_pct:.1f}%",
                        'Downtrend': downtrend_count,
                        'Downtrend %': f"{downtrend_pct:.1f}%",
                        'Sideways': sideways_count,
                        'Sideways %': f"{sideways_pct:.1f}%",
                        'Total': total_counts
                    })
                elif col == 'Volume_Signal':
                    # Special case for volume
                    signal_counts = df[col].value_counts()
                    high_volume = signal_counts.get('High Volume', 0)
                    low_volume = signal_counts.get('Low Volume', 0)
                    
                    total_signals = high_volume + low_volume
                    high_pct = (high_volume / total_signals * 100) if total_signals > 0 else 0
                    low_pct = (low_volume / total_signals * 100) if total_signals > 0 else 0
                    
                    summary_data.append({
                        'Signal Type': 'Volume Analysis',
                        'High Volume': high_volume,
                        'High %': f"{high_pct:.1f}%",
                        'Low Volume': low_volume,
                        'Low %': f"{low_pct:.1f}%",
                        'Total': total_signals
                    })
                else:
                    # Regular signals
                    signal_counts = df[col].value_counts()
                    buy_count = signal_counts.get('Buy', 0)
                    sell_count = signal_counts.get('Sell', 0)
                    hold_count = signal_counts.get('Hold', 0)
                    
                    total_signals = buy_count + sell_count + hold_count
                    buy_pct = (buy_count / total_signals * 100) if total_signals > 0 else 0
                    sell_pct = (sell_count / total_signals * 100) if total_signals > 0 else 0
                    hold_pct = (hold_count / total_signals * 100) if total_signals > 0 else 0
                    
                    summary_data.append({
                        'Signal Type': col.replace('_Signal', ''),
                        'Buy': buy_count,
                        'Buy %': f"{buy_pct:.1f}%",
                        'Sell': sell_count,
                        'Sell %': f"{sell_pct:.1f}%",
                        'Hold': hold_count,
                        'Hold %': f"{hold_pct:.1f}%",
                        'Total': total_signals
                    })
        
        if not summary_data:
            return html.Div("No signal data available", className="text-gray-500 text-sm")
        
        # Determine table structure based on data type
        if any('Uptrend' in item for item in summary_data):
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Type'},
                {'name': 'Uptrend', 'id': 'Uptrend'},
                {'name': 'Uptrend %', 'id': 'Uptrend %'},
                {'name': 'Downtrend', 'id': 'Downtrend'},
                {'name': 'Downtrend %', 'id': 'Downtrend %'},
                {'name': 'Sideways', 'id': 'Sideways'},
                {'name': 'Sideways %', 'id': 'Sideways %'},
                {'name': 'Total', 'id': 'Total'}
            ]
            
            conditional_style = [
                # Uptrend columns - green
                {
                    'if': {'column_id': 'Uptrend'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Uptrend %'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                # Downtrend columns - red
                {
                    'if': {'column_id': 'Downtrend'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Downtrend %'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                },
                # Sideways columns - blue/gray
                {
                    'if': {'column_id': 'Sideways'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.2)',
                    'color': 'gray',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sideways %'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.1)',
                    'color': 'gray'
                }
            ]
        elif any('High Volume' in item for item in summary_data):
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Type'},
                {'name': 'High Volume', 'id': 'High Volume'},
                {'name': 'High %', 'id': 'High %'},
                {'name': 'Low Volume', 'id': 'Low Volume'},
                {'name': 'Low %', 'id': 'Low %'},
                {'name': 'Total', 'id': 'Total'}
            ]
            
            conditional_style = [
                # High volume columns - green
                {
                    'if': {'column_id': 'High Volume'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'High %'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                # Low volume columns - red
                {
                    'if': {'column_id': 'Low Volume'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Low %'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                }
            ]
        else:
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Type'},
                {'name': 'Buy', 'id': 'Buy'},
                {'name': 'Buy %', 'id': 'Buy %'},
                {'name': 'Sell', 'id': 'Sell'},
                {'name': 'Sell %', 'id': 'Sell %'},
                {'name': 'Hold', 'id': 'Hold'},
                {'name': 'Hold %', 'id': 'Hold %'},
                {'name': 'Total', 'id': 'Total'}
            ]
            
            conditional_style = [
                # Buy columns - green
                {
                    'if': {'column_id': 'Buy'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Buy %'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                # Sell columns - red
                {
                    'if': {'column_id': 'Sell'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sell %'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                },
                # Hold columns - purple
                {
                    'if': {'column_id': 'Hold'},
                    'backgroundColor': 'rgba(128, 0, 128, 0.2)',
                    'color': 'purple',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Hold %'},
                    'backgroundColor': 'rgba(128, 0, 128, 0.1)',
                    'color': 'purple'
                }
            ]
        
        return dash_table.DataTable(
            data=summary_data,
            columns=columns,
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'center', 'padding': '8px', 'fontSize': '12px'},
            style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold', 'fontSize': '12px'},
            style_data_conditional=conditional_style,
            tooltip_data=[
                {
                    column: {'value': f'This shows the {column.lower()} for {indicator_name}', 'type': 'markdown'}
                    for column in [col['id'] for col in columns]
                } for _ in summary_data
            ],
            tooltip_duration=None
        )


    # INDIVIDUAL DETAIL TABLE
    def create_enhanced_individual_detailed_table(df, indicator_name, signal_columns):
        """Enhanced version of individual detailed table with improved data handling - FIXED FOR CANDLESTICK AND SHOWS ALL DATA"""
        if not signal_columns or df.empty:
            return html.Div("No data available", className="text-gray-500")
        
        # Determine technical value columns based on indicator
        tech_value_cols = []
        
        if 'Bollinger' in indicator_name:
            tech_value_cols = ['Upper Band', 'Middle Band', 'Lower Band', 'Close']
        elif 'Moving Average' in indicator_name:
            tech_value_cols = ['short_MA', 'long_MA', 'Close']
        elif 'RSI' in indicator_name:
            tech_value_cols = ['RSI', 'Close']
        elif 'MACD' in indicator_name:
            tech_value_cols = ['MACD', 'Signal_Line', 'MACD_Hist', 'Close']
        elif 'ADX' in indicator_name:
            tech_value_cols = ['ADX', '+DI', '-DI', 'Close']
        elif 'Volume' in indicator_name:
            tech_value_cols = ['Volume', 'VMA', 'Close']
        elif 'Candlestick' in indicator_name:
            tech_value_cols = ['Open', 'High', 'Low', 'Close'] # Add OHLC for candlestick
        else:
            tech_value_cols = ['Close']
        
        # Filter to existing columns
        available_tech_cols = [col for col in tech_value_cols if col in df.columns]
        available_signal_cols = [col for col in signal_columns if col in df.columns]
        
        if not available_signal_cols:
            return html.Div("No signal columns available", className="text-gray-500")
        
        # Create display columns with special handling for candlestick patterns
        display_columns = ['Datetime'] + available_tech_cols
        
        # For candlestick, add pattern and trend columns
        if 'Candlestick' in indicator_name:
            pattern_cols = []
            if 'detected_patterns' in df.columns:
                pattern_cols.append('detected_patterns')
            if 'candlestick_trend' in df.columns:
                pattern_cols.append('candlestick_trend')
            if 'candlestick_confidence' in df.columns:
                pattern_cols.append('candlestick_confidence')
            
            display_columns.extend(pattern_cols)
            
            # For candlestick patterns, remove Candlestick_Signal if candlestick_trend is available
            if 'candlestick_trend' in df.columns and 'Candlestick_Signal' in available_signal_cols:
                available_signal_cols = [col for col in available_signal_cols if col != 'Candlestick_Signal']
        
        # Add remaining signal columns
        display_columns.extend([col for col in available_signal_cols if col not in display_columns])
        
        # MODIFIED: Show all data, not just active signals
        display_df = df[display_columns].copy()
        
        # Format datetime
        if 'Datetime' in display_df.columns:
            display_df['Datetime'] = display_df['Datetime'].dt.strftime('%Y-%m-%d %H:%M')
        
        # Format numeric columns
        for col in available_tech_cols:
            if col in display_df.columns:
                if col in ['Open', 'High', 'Low', 'Close', 'Upper Band', 'Lower Band', 'Middle Band', 'short_MA', 'long_MA']:
                    display_df[col] = display_df[col].apply(lambda x: f"{x:.2f}" if pd.notna(x) else "")
                else:
                    display_df[col] = display_df[col].apply(lambda x: f"{x:.4f}" if pd.notna(x) else "")
        
        # Format confidence percentage if exists
        if 'candlestick_confidence' in display_df.columns:
            display_df['candlestick_confidence'] = display_df['candlestick_confidence'].apply(
                lambda x: f"{x:.1f}%" if pd.notna(x) else "")
        
        # Create conditional formatting
        conditional_formatting = []
        
        # Add formatting for candlestick trend
        if 'candlestick_trend' in display_df.columns:
            conditional_formatting.extend([
                {
                    'if': {'filter_query': '{candlestick_trend} = "Uptrend"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{candlestick_trend} = "Downtrend"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{candlestick_trend} = "Sideways"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.2)',
                    'color': 'gray',
                    'fontWeight': 'bold'
                }
            ])
        
        # Add formatting for signal columns
        for col in available_signal_cols:
            conditional_formatting.extend([
                {
                    'if': {'filter_query': '{' + col + '} = "Buy"', 'column_id': col},
                    'backgroundColor': 'rgba(0, 255, 0, 0.3)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{' + col + '} = "Sell"', 'column_id': col},
                    'backgroundColor': 'rgba(255, 0, 0, 0.3)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{' + col + '} = "Hold"', 'column_id': col},
                    'backgroundColor': 'rgba(128, 0, 128, 0.3)',
                    'color': 'purple',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{' + col + '} = "High Volume"', 'column_id': col},
                    'backgroundColor': 'rgba(0, 191, 255, 0.3)',
                    'color': 'blue',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{' + col + '} = "Low Volume"', 'column_id': col},
                    'backgroundColor': 'rgba(255, 165, 0, 0.3)',
                    'color': 'orange',
                    'fontWeight': 'bold'
                }
            ])
        
        # Add special formatting for technical indicators based on values
        if 'RSI' in display_df.columns:
            conditional_formatting.extend([
                {
                    'if': {'filter_query': '{RSI} > 70', 'column_id': 'RSI'},
                    'backgroundColor': 'rgba(255, 165, 0, 0.3)',
                    'color': 'darkorange',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{RSI} < 30', 'column_id': 'RSI'},
                    'backgroundColor': 'rgba(0, 100, 0, 0.3)',
                    'color': 'darkgreen',
                    'fontWeight': 'bold'
                }
            ])
        
        # Format price increases/decreases
        if 'Open' in display_df.columns and 'Close' in display_df.columns:
            conditional_formatting.extend([
                {
                    'if': {'filter_query': '{Close} > {Open}', 'column_id': 'Close'},
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{Close} < {Open}', 'column_id': 'Close'},
                    'color': 'red',
                    'fontWeight': 'bold'
                }
            ])

        return html.Div([
            html.P([
                f"Showing detailed data for ",
                html.Strong(indicator_name),
                f" with {len(available_signal_cols)} signal column(s) and {len(available_tech_cols)} technical indicator(s). ",
                f"Displaying all {len(display_df)} records."
            ], className="text-sm text-gray-600 mb-3"),
            
            html.P("ðŸŽ¨ Color Legend: Green = Buy/Uptrend, Red = Sell/Downtrend, Purple = Hold, Gray = Sideways", 
                className="text-xs text-gray-500 mb-3"),
            
            dash_table.DataTable(
                data=display_df.to_dict('records'),
                columns=[{'name': col, 'id': col} for col in display_df.columns],
                style_table={'overflowX': 'auto', 'maxHeight': '600px'},
                style_cell={'textAlign': 'left', 'padding': '6px', 'fontSize': '11px'},
                style_header={
                    'backgroundColor': 'rgb(230, 230, 230)',
                    'fontWeight': 'bold',
                    'fontSize': '11px'
                },
                style_data_conditional=conditional_formatting,
                page_size=20,
                sort_action='native',
                filter_action='native',
                tooltip_data=[
                    {
                        column: {'value': f'{column}: {value}', 'type': 'markdown'}
                        for column, value in row.items()
                    } for row in display_df.to_dict('records')
                ],
                tooltip_duration=None
            )
        ])











    def create_enhanced_indicator_summary_table(df, indicator_name, signal_columns):
        """Create enhanced summary table with proper data validation and no zero values"""
        summary_data = []
        
        print(f"Creating summary for {indicator_name} with columns: {signal_columns}")
        
        for col in signal_columns:
            if col not in df.columns:
                print(f"Warning: Column {col} not found in DataFrame")
                continue
                
            try:
                # Get signal counts with proper validation
                signal_counts = df[col].value_counts()
                total_records = len(df)
                
                print(f"Signal counts for {col}: {signal_counts.to_dict()}")
                
                # Handle different signal types based on column content
                if 'Volume' in col:
                    # Volume signals have different categories
                    high_vol_count = signal_counts.get('High Volume', 0)
                    low_vol_count = signal_counts.get('Low Volume', 0)
                    normal_vol_count = signal_counts.get('Normal Volume', 0)
                    
                    total_signals = high_vol_count + low_vol_count + normal_vol_count
                    
                    if total_signals > 0:  # Only add if we have actual signals
                        summary_data.append({
                            'Signal Column': col.replace('_Signal', '').replace('_Combined_Signal', ' Combined'),
                            'High Volume': high_vol_count,
                            'Low Volume': low_vol_count,
                            'Normal Volume': normal_vol_count,
                            'Total Records': total_records,
                            'Signal Rate': f"{(total_signals/total_records*100):.1f}%" if total_records > 0 else "0%",
                            'High Vol %': f"{(high_vol_count/total_signals*100):.1f}%" if total_signals > 0 else "0%",
                            'Low Vol %': f"{(low_vol_count/total_signals*100):.1f}%" if total_signals > 0 else "0%"
                        })
                else:
                    # Standard Buy/Sell/Hold signals
                    buy_count = signal_counts.get('Buy', 0)
                    sell_count = signal_counts.get('Sell', 0)
                    hold_count = signal_counts.get('Hold', 0)
                    
                    total_signals = buy_count + sell_count + hold_count
                    active_signals = buy_count + sell_count  # Exclude Hold from active signals
                    
                    if total_signals > 0:  # Only add if we have actual data
                        buy_pct = (buy_count / total_signals * 100) if total_signals > 0 else 0
                        sell_pct = (sell_count / total_signals * 100) if total_signals > 0 else 0
                        hold_pct = (hold_count / total_signals * 100) if total_signals > 0 else 0
                        activity_rate = (active_signals / total_signals * 100) if total_signals > 0 else 0
                        
                        # Calculate effectiveness metrics
                        buy_sell_ratio = (buy_count / max(1, sell_count)) if sell_count > 0 else (buy_count if buy_count > 0 else 0)
                        
                        summary_data.append({
                            'Signal Column': col.replace('_Signal', '').replace('_Combined_Signal', ' Combined'),
                            'Buy': buy_count,
                            'Buy %': f"{buy_pct:.1f}%",
                            'Sell': sell_count,
                            'Sell %': f"{sell_pct:.1f}%",
                            'Hold': hold_count,
                            'Hold %': f"{hold_pct:.1f}%",
                            'Total Records': total_records,
                            'Activity Rate': f"{activity_rate:.1f}%",
                            'Buy/Sell Ratio': f"{buy_sell_ratio:.2f}",
                            'Signal Strength': 'High' if activity_rate > 25 else 'Medium' if activity_rate > 10 else 'Low'
                        })
                        
            except Exception as col_error:
                print(f"Error processing column {col}: {col_error}")
                continue
        
        if not summary_data:
            return html.Div([
                html.P(f"No valid signal data found for {indicator_name}", className="text-gray-500 text-sm p-4"),
                html.P(f"Attempted to process: {signal_columns}", className="text-gray-400 text-xs")
            ], className="border border-gray-200 rounded")
        
        # Determine table structure based on data type
        if any('High Volume' in item for item in summary_data):
            # Volume analysis table
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Column'},
                {'name': 'High Volume', 'id': 'High Volume'},
                {'name': 'Low Volume', 'id': 'Low Volume'},
                {'name': 'Normal Volume', 'id': 'Normal Volume'},
                {'name': 'Total Records', 'id': 'Total Records'},
                {'name': 'Signal Rate', 'id': 'Signal Rate'},
                {'name': 'High Vol %', 'id': 'High Vol %'},
                {'name': 'Low Vol %', 'id': 'Low Vol %'}
            ]
            conditional_style = [
                {
                    'if': {'column_id': 'High Volume'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Low Volume'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Normal Volume'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.1)',
                    'color': 'gray',
                    'fontWeight': 'bold'
                }
            ]
        else:
            # Standard signal analysis table
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Column'},
                {'name': 'Buy', 'id': 'Buy'},
                {'name': 'Buy %', 'id': 'Buy %'},
                {'name': 'Sell', 'id': 'Sell'},
                {'name': 'Sell %', 'id': 'Sell %'},
                {'name': 'Hold', 'id': 'Hold'},
                {'name': 'Hold %', 'id': 'Hold %'},
                {'name': 'Activity Rate', 'id': 'Activity Rate'},
                {'name': 'Buy/Sell Ratio', 'id': 'Buy/Sell Ratio'},
                {'name': 'Signal Strength', 'id': 'Signal Strength'}
            ]
            conditional_style = [
                {
                    'if': {'column_id': 'Buy'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Buy %'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                {
                    'if': {'column_id': 'Sell'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sell %'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                },
                {
                    'if': {'column_id': 'Hold'},
                    'backgroundColor': 'rgba(128, 0, 128, 0.2)',
                    'color': 'purple',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Hold %'},
                    'backgroundColor': 'rgba(128, 0, 128, 0.1)',
                    'color': 'purple'
                },
                {
                    'if': {'filter_query': '{Signal Strength} = High'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.15)',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{Signal Strength} = Low'},
                    'backgroundColor': 'rgba(255, 165, 0, 0.15)',
                    'color': 'orange'
                }
            ]
        
        return dash_table.DataTable(
            data=summary_data,
            columns=columns,
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'center', 'padding': '8px', 'fontSize': '12px'},
            style_header={
                'backgroundColor': 'rgb(240, 240, 240)',
                'fontWeight': 'bold',
                'fontSize': '12px'
            },
            style_data_conditional=conditional_style,
            tooltip_data=[
                {
                    column: {'value': f'This shows the {column.lower()} for {indicator_name}', 'type': 'markdown'}
                    for column in [col['id'] for col in columns]
                } for _ in summary_data
            ],
            tooltip_duration=None
        )

    def create_enhanced_indicator_detailed_table(df, indicator_name, signal_columns):
        """Create detailed table with technical values and improved data handling"""
        if not signal_columns or df.empty:
            return html.Div("No data available for detailed analysis", className="text-gray-500")
        
        # Determine which technical value columns to include based on indicator
        tech_value_cols = []
        
        if 'Bollinger' in indicator_name:
            tech_value_cols = ['Upper Band', 'Middle Band', 'Lower Band', 'Close']
        elif 'Moving Average' in indicator_name:
            tech_value_cols = ['short_MA', 'long_MA', 'Close']
        elif 'RSI' in indicator_name:
            tech_value_cols = ['RSI', 'Close']
        elif 'MACD' in indicator_name:
            tech_value_cols = ['MACD', 'Signal_Line', 'MACD_Hist', 'Close']
        elif 'ADX' in indicator_name:
            tech_value_cols = ['ADX', '+DI', '-DI', 'Close']
        elif 'Volume' in indicator_name:
            tech_value_cols = ['Volume', 'VMA', 'Close']
        elif 'Fibonacci' in indicator_name:
            tech_value_cols = ['Close']  # Fibonacci levels are usually calculated dynamically
        elif 'Candlestick' in indicator_name:
            tech_value_cols = ['Open', 'High', 'Low', 'Close']
        else:
            tech_value_cols = ['Close']  # Default for unknown indicators
        
        # Filter to include only existing columns
        available_tech_cols = [col for col in tech_value_cols if col in df.columns]
        available_signal_cols = [col for col in signal_columns if col in df.columns]
        
        if not available_signal_cols:
            return html.Div([
                html.P(f"No signal columns available for {indicator_name}", className="text-gray-500"),
                html.P(f"Searched for: {signal_columns}", className="text-gray-400 text-xs")
            ])
        
        # Create display columns with date and technical values first, then signals
        display_columns = ['Datetime'] + available_tech_cols + available_signal_cols
        
        # Filter dataframe to only include rows with actual signals (not just Hold)
        signal_mask = pd.Series([False] * len(df))
        for col in available_signal_cols:
            signal_mask |= df[col].isin(['Buy', 'Sell', 'High Volume', 'Low Volume'])
        
        if signal_mask.any():
            display_df = df[signal_mask][display_columns].copy()
        else:
            # If no active signals, show last 20 records
            display_df = df[display_columns].tail(20).copy()
        
        if display_df.empty:
            return html.Div([
                html.P(f"No active signals found for {indicator_name}", className="text-gray-500"),
                html.P(f"Total records: {len(df)}, Signal columns: {len(available_signal_cols)}", className="text-gray-400 text-xs")
            ])
        
        # Format datetime
        if 'Datetime' in display_df.columns:
            display_df['Datetime'] = pd.to_datetime(display_df['Datetime'], errors='coerce').dt.strftime('%Y-%m-%d %H:%M')
        
        # Format numeric columns with proper rounding
        for col in available_tech_cols:
            if col in display_df.columns:
                try:
                    if col in ['Close', 'Open', 'High', 'Low', 'Upper Band', 'Middle Band', 'Lower Band', 'short_MA', 'long_MA']:
                        display_df[col] = pd.to_numeric(display_df[col], errors='coerce').round(2)
                    elif col in ['Volume']:
                        display_df[col] = pd.to_numeric(display_df[col], errors='coerce').astype('Int64')  # Integer with NA support
                    else:
                        display_df[col] = pd.to_numeric(display_df[col], errors='coerce').round(4)
                except Exception as format_error:
                    print(f"Error formatting column {col}: {format_error}")
                    continue
        
        # Create comprehensive conditional formatting for signals
        signal_conditional_formatting = []
        
        for col in available_signal_cols:
            # Buy signals - green
            signal_conditional_formatting.append({
                'if': {'filter_query': '{' + col + '} = "Buy"', 'column_id': col},
                'backgroundColor': 'rgba(0, 255, 0, 0.3)',
                'color': 'green',
                'fontWeight': 'bold'
            })
            # Sell signals - red
            signal_conditional_formatting.append({
                'if': {'filter_query': '{' + col + '} = "Sell"', 'column_id': col},
                'backgroundColor': 'rgba(255, 0, 0, 0.3)',
                'color': 'red',
                'fontWeight': 'bold'
            })
            # Hold signals - purple
            signal_conditional_formatting.append({
                'if': {'filter_query': '{' + col + '} = "Hold"', 'column_id': col},
                'backgroundColor': 'rgba(128, 0, 128, 0.3)',
                'color': 'purple',
                'fontWeight': 'bold'
            })
            # Volume signals
            signal_conditional_formatting.append({
                'if': {'filter_query': '{' + col + '} = "High Volume"', 'column_id': col},
                'backgroundColor': 'rgba(0, 255, 0, 0.3)',
                'color': 'green',
                'fontWeight': 'bold'
            })
            signal_conditional_formatting.append({
                'if': {'filter_query': '{' + col + '} = "Low Volume"', 'column_id': col},
                'backgroundColor': 'rgba(255, 0, 0, 0.3)',
                'color': 'red',
                'fontWeight': 'bold'
            })
        
        # Add special formatting for technical indicators based on their values
        if 'RSI' in available_tech_cols:
            signal_conditional_formatting.extend([
                {
                    'if': {'filter_query': '{RSI} > 70', 'column_id': 'RSI'},
                    'backgroundColor': 'rgba(255, 165, 0, 0.3)',
                    'color': 'darkorange',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{RSI} < 30', 'column_id': 'RSI'},
                    'backgroundColor': 'rgba(0, 100, 0, 0.3)',
                    'color': 'darkgreen',
                    'fontWeight': 'bold'
                }
            ])
        
        if 'MACD_Hist' in available_tech_cols:
            signal_conditional_formatting.extend([
                {
                    'if': {'filter_query': '{MACD_Hist} > 0', 'column_id': 'MACD_Hist'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                {
                    'if': {'filter_query': '{MACD_Hist} < 0', 'column_id': 'MACD_Hist'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                }
            ])
        
        return html.Div([
            html.P([
                f"Showing detailed analysis for ",
                html.Strong(indicator_name),
                f" with {len(available_signal_cols)} signal column(s) and {len(available_tech_cols)} technical indicator(s). ",
                f"Filtered to {len(display_df)} records with active signals."
            ], className="text-sm text-gray-600 mb-3"),
            
            html.P("ðŸŽ¨ Color Legend: Green = Buy/High Volume, Red = Sell/Low Volume, Purple = Hold, Orange = Overbought/Oversold", 
                className="text-xs text-gray-500 mb-3"),
            
            dash_table.DataTable(
                data=display_df.to_dict('records'),
                columns=[{'name': col, 'id': col} for col in display_df.columns],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '6px', 'fontSize': '11px'},
                style_header={
                    'backgroundColor': 'rgb(230, 230, 230)',
                    'fontWeight': 'bold',
                    'fontSize': '11px'
                },
                style_data_conditional=signal_conditional_formatting,
                page_size=20,
                sort_action='native',
                filter_action='native',
                tooltip_data=[
                    {
                        column: {'value': f'{column}: {value}', 'type': 'markdown'}
                        for column, value in row.items()
                    } for row in display_df.to_dict('records')
                ],
                tooltip_duration=None
            )
        ])



    # SUMMARY GLOBAL TABLE
    def create_indicator_summary_table(df, indicator_name, signal_columns):
        """Create summary table showing signal distribution for an indicator - Modified for candlestick trend"""
        summary_data = []
        
        for col in signal_columns:
            if col in df.columns:
                if col == 'Candlestick_Signal' and 'candlestick_trend' in df.columns:
                    # Use candlestick_trend instead of Candlestick_Signal
                    trend_counts = df['candlestick_trend'].value_counts()
                    uptrend_count = trend_counts.get('Uptrend', 0)
                    downtrend_count = trend_counts.get('Downtrend', 0)
                    sideways_count = trend_counts.get('Sideways', 0)
                    
                    total_trends = uptrend_count + downtrend_count + sideways_count
                    uptrend_pct = (uptrend_count / total_trends * 100) if total_trends > 0 else 0
                    downtrend_pct = (downtrend_count / total_trends * 100) if total_trends > 0 else 0
                    sideways_pct = (sideways_count / total_trends * 100) if total_trends > 0 else 0
                    
                    summary_data.append({
                        'Signal Column': 'Candlestick Trend',
                        'Uptrend': uptrend_count,
                        'Uptrend %': f"{uptrend_pct:.1f}%",
                        'Downtrend': downtrend_count,
                        'Downtrend %': f"{downtrend_pct:.1f}%",
                        'Sideways': sideways_count,
                        'Sideways %': f"{sideways_pct:.1f}%",
                        'Total': total_trends
                    })
                else:
                    # Regular signal summary
                    signal_counts = df[col].value_counts()
                    buy_count = signal_counts.get('Buy', 0)
                    sell_count = signal_counts.get('Sell', 0)
                    hold_count = signal_counts.get('Hold', 0)
                    
                    total_signals = buy_count + sell_count + hold_count
                    buy_pct = (buy_count / total_signals * 100) if total_signals > 0 else 0
                    sell_pct = (sell_count / total_signals * 100) if total_signals > 0 else 0
                    hold_pct = (hold_count / total_signals * 100) if total_signals > 0 else 0
                    
                    summary_data.append({
                        'Signal Column': col.replace('_Signal', ''),
                        'Buy': buy_count,
                        'Buy %': f"{buy_pct:.1f}%",
                        'Sell': sell_count,
                        'Sell %': f"{sell_pct:.1f}%",
                        'Hold': hold_count,
                        'Hold %': f"{hold_pct:.1f}%",
                        'Total': total_signals
                    })
        
        if not summary_data:
            return html.Div("No signal data available", className="text-gray-500 text-sm")
        
        # Determine columns based on data type
        if any(item.get('Uptrend', None) is not None for item in summary_data):
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Column'},
                {'name': 'Uptrend', 'id': 'Uptrend'},
                {'name': 'Uptrend %', 'id': 'Uptrend %'},
                {'name': 'Downtrend', 'id': 'Downtrend'},
                {'name': 'Downtrend %', 'id': 'Downtrend %'},
                {'name': 'Sideways', 'id': 'Sideways'},
                {'name': 'Sideways %', 'id': 'Sideways %'},
                {'name': 'Total', 'id': 'Total'}
            ]
            
            conditional_style = [
                # Uptrend columns - green
                {
                    'if': {'column_id': 'Uptrend'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Uptrend %'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                # Downtrend columns - red
                {
                    'if': {'column_id': 'Downtrend'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Downtrend %'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                },
                # Sideways columns - blue/gray
                {
                    'if': {'column_id': 'Sideways'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.2)',
                    'color': 'gray',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sideways %'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.1)',
                    'color': 'gray'
                }
            ]
        else:
            columns = [
                {'name': 'Signal Type', 'id': 'Signal Column'},
                {'name': 'Buy', 'id': 'Buy'},
                {'name': 'Buy %', 'id': 'Buy %'},
                {'name': 'Sell', 'id': 'Sell'},
                {'name': 'Sell %', 'id': 'Sell %'},
                {'name': 'Hold', 'id': 'Hold'},
                {'name': 'Hold %', 'id': 'Hold %'},
                {'name': 'Total', 'id': 'Total'}
            ]
            
            conditional_style = [
                # Buy columns - green
                {
                    'if': {'column_id': 'Buy'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Buy %'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'color': 'green'
                },
                # Sell columns - red
                {
                    'if': {'column_id': 'Sell'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sell %'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                    'color': 'red'
                },
                # Hold columns - purple
                {
                    'if': {'column_id': 'Hold'},
                    'backgroundColor': 'rgba(128, 0, 128, 0.2)',
                    'color': 'purple',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Hold %'},
                    'backgroundColor': 'rgba(128, 0, 128, 0.1)',
                    'color': 'purple'
                }
            ]
        
        return dash_table.DataTable(
            data=summary_data,
            columns=columns,
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'center', 'padding': '8px', 'fontSize': '12px'},
            style_header={
                'backgroundColor': 'rgb(240, 240, 240)',
                'fontWeight': 'bold',
                'fontSize': '12px'
            },
            style_data_conditional=conditional_style
        )

    def create_indicator_detailed_table(df, indicator_name, signal_columns):
        """Create detailed table showing signals with corresponding technical values including candlestick patterns"""
        if not signal_columns or df.empty:
            return html.Div("No data available", className="text-gray-500")
        
        # Determine which technical value columns to include based on indicator
        tech_value_cols = []
        
        if indicator_name == 'Bollinger Bands':
            tech_value_cols = ['Upper Band', 'Middle Band', 'Lower Band', 'Close']
        elif indicator_name == 'Moving Average':
            tech_value_cols = ['short_MA', 'long_MA', 'Close']
        elif indicator_name == 'RSI':
            tech_value_cols = ['RSI', 'Close']
        elif indicator_name == 'MACD':
            tech_value_cols = ['MACD', 'Signal_Line', 'MACD_Hist', 'Close']
        elif indicator_name == 'ADX':
            tech_value_cols = ['ADX', '+DI', '-DI', 'Close']
        elif indicator_name == 'Candlestick Patterns':
            tech_value_cols = ['Open', 'High', 'Low', 'Close']  # Include OHLC for context
        else:
            tech_value_cols = ['Close']
        
        # Filter to include only existing columns
        available_tech_cols = [col for col in tech_value_cols if col in df.columns]
        available_signal_cols = [col for col in signal_columns if col in df.columns]
        
        # Create display columns - always include Open, High, Low, Close for context
        base_columns = ['Datetime']
        if all(col in df.columns for col in ['Open', 'High', 'Low', 'Close']):
            base_columns.extend(['Open', 'High', 'Low', 'Close'])
        
        # Always include detected_patterns and candlestick_trend if available
        pattern_cols = []
        if 'detected_patterns' in df.columns:
            pattern_cols.append('detected_patterns')
        if 'candlestick_trend' in df.columns:
            pattern_cols.append('candlestick_trend')
        if 'candlestick_confidence' in df.columns:
            pattern_cols.append('candlestick_confidence')
        
        # Combine all columns, removing duplicates
        all_cols = base_columns + pattern_cols + [col for col in available_tech_cols if col not in base_columns and col not in pattern_cols]
        
        # For candlestick patterns, use candlestick_trend instead of signal column
        if indicator_name == 'Candlestick Patterns' and 'candlestick_trend' in df.columns:
            # Remove any Candlestick_Signal from available_signal_cols
            available_signal_cols = [col for col in available_signal_cols if col != 'Candlestick_Signal']
            
        display_columns = all_cols + available_signal_cols
        
        # Create a copy with only the columns we want to display
        display_df = df[display_columns].copy()
        
        # Format datetime
        if 'Datetime' in display_df.columns:
            display_df['Datetime'] = display_df['Datetime'].dt.strftime('%Y-%m-%d %H:%M')
        
        # Format numeric columns
        for col in [c for c in available_tech_cols if c in display_df.columns]:
            if col in ['Open', 'High', 'Low', 'Close', 'Upper Band', 'Middle Band', 'Lower Band', 'short_MA', 'long_MA']:
                display_df[col] = display_df[col].apply(lambda x: f"{x:.2f}" if pd.notna(x) else "")
            else:
                display_df[col] = display_df[col].apply(lambda x: f"{x:.4f}" if pd.notna(x) else "")
        
        # Create conditional formatting for signals
        signal_conditional_formatting = []
        
        # Add formatting for candlestick trend
        if 'candlestick_trend' in display_df.columns:
            signal_conditional_formatting.extend([
                {
                    'if': {'filter_query': '{candlestick_trend} = "Uptrend"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{candlestick_trend} = "Downtrend"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{candlestick_trend} = "Sideways"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.2)',
                    'color': 'gray',
                    'fontWeight': 'bold'
                }
            ])
        
        # Basic formatting for standard signals
        for col in available_signal_cols:
            signal_conditional_formatting.extend([
                {
                    'if': {'filter_query': '{' + col + '} = "Buy"', 'column_id': col},
                    'backgroundColor': 'rgba(0, 255, 0, 0.3)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{' + col + '} = "Sell"', 'column_id': col},
                    'backgroundColor': 'rgba(255, 0, 0, 0.3)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{' + col + '} = "Hold"', 'column_id': col},
                    'backgroundColor': 'rgba(128, 0, 128, 0.3)',
                    'color': 'purple',
                    'fontWeight': 'bold'
                }
            ])
        
        return html.Div([
            html.P(f"Showing detailed {indicator_name} with relevant values. "
                f"Patterns are shown directly rather than as signals.", 
                className="text-xs text-gray-600 mb-2"),
            
            dash_table.DataTable(
                data=display_df.to_dict('records'),
                columns=[{'name': col, 'id': col} for col in display_df.columns],
                style_table={'overflowX': 'auto'},
                style_cell={
                    'textAlign': 'left', 
                    'padding': '6px', 
                    'fontSize': '11px',
                    'minWidth': '50px', 'width': '100px', 'maxWidth': '300px',
                    'overflow': 'hidden',
                    'textOverflow': 'ellipsis',
                },
                style_header={
                    'backgroundColor': 'rgb(230, 230, 230)',
                    'fontWeight': 'bold',
                    'fontSize': '11px'
                },
                style_data_conditional=signal_conditional_formatting,
                page_size=15,
                sort_action='native',
                filter_action='native',
                tooltip_data=[
                    {
                        'detected_patterns': {'value': str(row['detected_patterns']), 'type': 'text'}
                    } if 'detected_patterns' in row else {} for row in display_df.to_dict('records')
                ],
                tooltip_duration=None
            )
        ])

    # FIXED CALLBACK UNTUK SIGNAL ANALYSIS DROPDOWN - DENGAN DEBUG PRINT (YANG SUDAH ADA)
    # @app.callback(
    #     Output({'type': 'signal-content', 'ticker': MATCH}, 'children'),
    #     [Input({'type': 'signal-dropdown', 'ticker': MATCH}, 'value')],
    #     [State({'type': 'ticker-store', 'ticker': MATCH}, 'children')],
    #     prevent_initial_call=True
    # )
    # def update_signal_analysis_content_debug(selected_signal, ticker_data_json):
    #     """Update signal analysis content with comprehensive debugging - ALREADY WORKING"""
        
    #     # DEBUG: Print callback activation
    #     print(f"ðŸ”¥ CALLBACK TRIGGERED!")
    #     print(f"ðŸ“Š Selected signal: {selected_signal}")
    #     print(f"ðŸ“¦ Ticker data available: {ticker_data_json is not None}")
        
    #     # Get callback context info
    #     ctx = dash.callback_context
    #     print(f"ðŸŽ¯ Callback context: {ctx.triggered}")
        
    #     if ctx.triggered:
    #         prop_id = ctx.triggered[0]['prop_id']
    #         # print(f"ðŸ” Triggered by: {prop_id}")
        
    #     if not selected_signal:
    #         print("âŒ No signal selected")
    #         return html.Div([
    #             html.P("Please select a signal to view detailed analysis", className="text-gray-500 p-4"),
    #             html.P(f"DEBUG: Signal value = {selected_signal}", className="text-xs text-red-500")
    #         ])
        
    #     if not ticker_data_json:
    #         print("âŒ No ticker data")
    #         return html.Div([
    #             html.P("No ticker data available", className="text-red-500 p-4"),
    #             html.P("DEBUG: ticker_data_json is None", className="text-xs text-red-500")
    #         ])
        
    #     try:
    #         print(f"ðŸ”„ Processing data for signal: {selected_signal}")
            
    #         # Parse the JSON data
    #         df = pd.read_json(ticker_data_json, orient='split')
    #         print(f"ðŸ“ˆ DataFrame loaded with shape: {df.shape}")
    #         print(f"ðŸ“‹ Available columns: {df.columns.tolist()}")
            
    #         # Convert datetime if needed
    #         if 'Datetime' in df.columns:
    #             df['Datetime'] = pd.to_datetime(df['Datetime'], errors='coerce')
    #             print(f"ðŸ• Datetime converted successfully")
            
    #         # Extract ticker from callback context
    #         ticker_id = "Unknown"
    #         if ctx.triggered:
    #             try:
    #                 prop_id = ctx.triggered[0]['prop_id']
    #                 # Parse ticker from pattern matching ID
    #                 import json
    #                 parsed_id = json.loads(prop_id.split('.')[0])
    #                 ticker_id = parsed_id.get('ticker', 'Unknown')
    #                 print(f"ðŸŽ« Extracted ticker: {ticker_id}")
    #             except Exception as extract_error:
    #                 print(f"âš ï¸ Could not extract ticker: {extract_error}")
            
    #         print(f"ðŸš€ Generating content for signal: {selected_signal}")
            
    #         if selected_signal == 'all':
    #             print("ðŸ“Š Creating all signals overview")
    #             result = create_all_signals_overview_fixed(df, ticker_id)
    #         else:
    #             print(f"ðŸŽ¯ Creating individual signal analysis for: {selected_signal}")
    #             result = create_individual_signal_analysis_fixed(df, selected_signal, ticker_id)
            
    #         print("âœ… Content generated successfully")
    #         return result
                
    #     except Exception as e:
    #         print(f"ðŸ’¥ ERROR in callback: {str(e)}")
    #         traceback.print_exc()
    #         return html.Div([
    #             html.H4("âŒ Error Loading Analysis", className="text-lg font-semibold text-red-600 mb-2"),
    #             html.P(f"Error: {str(e)}", className="text-red-500 mb-2"),
    #             html.P(f"Signal: {selected_signal}", className="text-sm text-gray-600 mb-1"),
    #             html.P(f"Data available: {ticker_data_json is not None}", className="text-sm text-gray-600 mb-1"),
    #             html.Details([
    #                 html.Summary("Show Full Error Details", className="cursor-pointer text-blue-600"),
    #                 html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs mt-2")
    #             ])
    #         ])

    print("âœ… Signal analysis callback registered successfully")

    # Add callback for signal analysis dropdown - FIXED WITH PATTERN MATCHING
    # @app.callback(
    #     Output({'type': 'signal-analysis-content', 'ticker': MATCH}, 'children'),
    #     [Input({'type': 'signal-analysis-dropdown', 'ticker': MATCH}, 'value')],
    #     [State({'type': 'ticker-data-store', 'ticker': MATCH}, 'children')],
    #     prevent_initial_call=True
    # )
    # def update_signal_analysis_content_fixed(selected_signal, ticker_data_json):
    #     """Update signal analysis content based on dropdown selection - FIXED VERSION"""
    #     if not selected_signal or not ticker_data_json:
    #         return html.Div("Select a signal to view detailed analysis", className="text-gray-500 p-4")
        
    #     try:
    #         # Load data from JSON
    #         from io import StringIO
    #         df = pd.read_json(StringIO(ticker_data_json), orient='split')
            
    #         # Convert datetime if needed
    #         if 'Datetime' in df.columns:
    #             df['Datetime'] = pd.to_datetime(df['Datetime'], errors='coerce')
            
    #         # Get ticker name from callback context
    #         ctx = dash.callback_context
    #         ticker = "Unknown"
    #         if ctx.triggered:
    #             try:
    #                 prop_id = ctx.triggered[0]['prop_id']
    #                 # Extract ticker from the prop_id
    #                 import re
    #                 match = re.search(r'"ticker":"([^"]+)"', prop_id)
    #                 if match:
    #                     ticker = match.group(1)
    #             except:
    #                 pass
            
    #         if selected_signal == 'all':
    #             return create_all_signals_overview_fixed(df, ticker)
    #         else:
    #             return create_individual_signal_analysis_fixed(df, selected_signal, ticker)
                
    #     except Exception as e:
    #         return html.Div([
    #             html.P(f"Error loading signal analysis: {str(e)}", className="text-red-500"),
    #             html.Details([
    #                 html.Summary("Show Error Details", className="cursor-pointer text-blue-600"),
    #                 html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs")
    #             ])
    #         ])

    # REGISTER PATTERN MATCHING CALLBACKS WITH CORRECT IDS
    def register_signal_analysis_callbacks():
        """Register callbacks for signal analysis dropdowns with unique pattern matching"""
        
        # Get all tickers that might be processed
        # This callback will be registered dynamically for each ticker
        
        @app.callback(
            Output({'type': 'signal-content', 'ticker': MATCH}, 'children'),
            [Input({'type': 'signal-dropdown', 'ticker': MATCH}, 'value')],
            [State({'type': 'ticker-store', 'ticker': MATCH}, 'children')],
            prevent_initial_call=True
        )
        def update_ticker_signal_analysis(selected_signal, ticker_data_json):
            """Callback for ticker-specific signal analysis"""
            if not selected_signal or not ticker_data_json:
                return html.Div("Please select a signal", className="text-gray-500 p-4")
            
            try:
                # Parse the stored data
                df = pd.read_json(ticker_data_json, orient='split')
                
                # Extract ticker from callback context
                ctx = dash.callback_context
                ticker_id = "Unknown"
                if ctx.triggered:
                    prop_id = ctx.triggered[0]['prop_id']
                    # Parse ticker from pattern matching ID
                    import json
                    try:
                        parsed_id = json.loads(prop_id.split('.')[0])
                        ticker_id = parsed_id.get('ticker', 'Unknown')
                    except:
                        pass
                
                if selected_signal == 'all':
                    return create_all_signals_overview_fixed(df, ticker_id)
                else:
                    return create_individual_signal_analysis_fixed(df, selected_signal, ticker_id)
                    
            except Exception as e:
                return html.Div(f"Error: {str(e)}", className="text-red-500 p-4")

    def create_all_signals_overview_fixed(df, ticker):
        """Create overview of all signals - ENHANCED VERSION"""
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        if not signal_cols:
            return html.Div("No signal data available", className="text-gray-500 p-4")
        
        # Create summary statistics
        summary_data = []
        for col in signal_cols:
            signal_counts = df[col].value_counts()
            
            # Calculate additional metrics
            total_signals = len(df)
            buy_count = signal_counts.get('Buy', 0)
            sell_count = signal_counts.get('Sell', 0)
            hold_count = signal_counts.get('Hold', 0)
            activity_rate = ((buy_count + sell_count) / total_signals * 100) if total_signals > 0 else 0
            buy_sell_ratio = (buy_count / max(1, sell_count))
            
            # Signal effectiveness (simplified)
            effectiveness = "High" if activity_rate > 20 else "Medium" if activity_rate > 10 else "Low"
            
            summary_data.append({
                'Signal Type': col.replace('_Signal', '').replace('_Combined_Signal', ' Combined'),
                'Buy Count': buy_count,
                'Sell Count': sell_count,
                'Hold Count': hold_count,
                'Total Signals': total_signals,
                'Activity Rate': f"{activity_rate:.1f}%",
                'Buy/Sell Ratio': f"{buy_sell_ratio:.2f}",
                'Effectiveness': effectiveness
            })
        
        return html.Div([
            html.H4("ðŸ“ˆ All Signals Overview", className="text-lg font-semibold mb-3"),
            html.P(f"Comprehensive analysis of all {len(signal_cols)} signal types for {ticker}", 
                className="text-gray-600 mb-4"),
            
            # Summary table with enhanced styling
            dash_table.DataTable(
                data=summary_data,
                columns=[
                    {'name': 'Signal Type', 'id': 'Signal Type'},
                    {'name': 'Buy Count', 'id': 'Buy Count'},
                    {'name': 'Sell Count', 'id': 'Sell Count'},
                    {'name': 'Hold Count', 'id': 'Hold Count'},
                    {'name': 'Activity Rate', 'id': 'Activity Rate'},
                    {'name': 'Buy/Sell Ratio', 'id': 'Buy/Sell Ratio'},
                    {'name': 'Effectiveness', 'id': 'Effectiveness'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'center', 'padding': '10px'},
                style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Effectiveness} = High'},
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                        'color': 'green'
                    },
                    {
                        'if': {'filter_query': '{Effectiveness} = Low'},
                        'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                        'color': 'red'
                    },
                    {
                        'if': {'column_id': 'Buy Count'},
                        'color': 'green',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'column_id': 'Sell Count'},
                        'color': 'red',
                        'fontWeight': 'bold'
                    }
                ],
                sort_action='native'
            ),
            
            # Visual comparison chart
            html.Div([
                html.H5("ðŸ“Š Signal Activity Comparison", className="text-md font-semibold mt-6 mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Bar(
                                name='Buy Signals',
                                x=[s['Signal Type'] for s in summary_data],
                                y=[s['Buy Count'] for s in summary_data],
                                marker_color='green',
                                opacity=0.7
                            ),
                            go.Bar(
                                name='Sell Signals',
                                x=[s['Signal Type'] for s in summary_data],
                                y=[s['Sell Count'] for s in summary_data],
                                marker_color='red',
                                opacity=0.7
                            ),
                            go.Bar(
                                name='Hold Signals',
                                x=[s['Signal Type'] for s in summary_data],
                                y=[s['Hold Count'] for s in summary_data],
                                marker_color='gray',
                                opacity=0.5
                            )
                        ],
                        layout=go.Layout(
                            title=f'Signal Distribution Analysis - {ticker}',
                            barmode='group',
                            height=400,
                            xaxis_tickangle=-45,
                            template='plotly_white'
                        )
                    )
                )
            ])
        ])

    def create_individual_signal_analysis_fixed(df, selected_signal, signal_col, ticker):
        """Create detailed analysis for individual signal - ENHANCED VERSION"""

        if not selected_signal or selected_signal not in df.columns:
            return html.Div(f"Signal '{selected_signal}' not found in data", className="text-red-500 p-4")

        if signal_col not in df.columns:
            return html.Div(f"Signal {signal_col} not found in data", className="text-red-500 p-4")
        
        signal_counts = df[signal_col].value_counts()
        signal_data = df[df[signal_col].isin(['Buy', 'Sell'])].copy()
        
        # Calculate enhanced metrics
        total_records = len(df)
        buy_count = signal_counts.get('Buy', 0)
        sell_count = signal_counts.get('Sell', 0)
        hold_count = signal_counts.get('Hold', 0)
        
        activity_rate = ((buy_count + sell_count) / total_records * 100) if total_records > 0 else 0
        signal_frequency = f"1 signal per {int(total_records / max(1, buy_count + sell_count))} records"
        
        # Signal timing analysis
        timing_analysis = []
        if not signal_data.empty and 'Datetime' in df.columns:
            try:
                # Group by month to see signal distribution over time
                df_temp = df.copy()
                df_temp['Month'] = pd.to_datetime(df_temp['Datetime'], errors='coerce').dt.to_period('M')
                monthly_signals = df_temp.groupby(['Month', signal_col]).size().reset_index(name='Count')
                
                for month in monthly_signals['Month'].unique():
                    if pd.notna(month):
                        month_data = monthly_signals[monthly_signals['Month'] == month]
                        buy_month = month_data[month_data[signal_col] == 'Buy']['Count'].sum()
                        sell_month = month_data[month_data[signal_col] == 'Sell']['Count'].sum()
                        timing_analysis.append({
                            'Month': str(month),
                            'Buy Signals': buy_month,
                            'Sell Signals': sell_month,
                            'Total': buy_month + sell_month
                        })
            except Exception as timing_error:
                print(f"Error in timing analysis: {timing_error}")
        
        # Calculate signal effectiveness if possible
        effectiveness_data = []
        if not signal_data.empty and 'Close' in df.columns:
            for idx in signal_data.index:
                try:
                    current_signal = signal_data.loc[idx, signal_col]
                    current_price = signal_data.loc[idx, 'Close']
                    
                    # Look ahead 5 periods to see if signal was effective
                    future_idx = min(idx + 5, len(df) - 1)
                    if future_idx > idx:
                        future_price = df.loc[future_idx, 'Close']
                        price_change = (future_price - current_price) / current_price * 100
                        
                        # Determine if signal was correct
                        effectiveness = 'Correct' if (
                            (current_signal == 'Buy' and price_change > 0) or 
                            (current_signal == 'Sell' and price_change < 0)
                        ) else 'Incorrect'
                        
                        effectiveness_data.append({
                            'Date': signal_data.loc[idx, 'Datetime'] if 'Datetime' in signal_data.columns else idx,
                            'Signal': current_signal,
                            'Price': current_price,
                            'Price Change (5 periods)': f"{price_change:.2f}%",
                            'Effectiveness': effectiveness
                        })
                except Exception as eff_error:
                    continue
        
        # Calculate effectiveness rate
        correct_signals = len([e for e in effectiveness_data if e['Effectiveness'] == 'Correct'])
        effectiveness_rate = (correct_signals / len(effectiveness_data) * 100) if effectiveness_data else 0
        
        return html.Div([
            html.H3(f"{selected_signal} Analysis for {ticker}", className="text-lg font-semibold mb-3"),
            html.H4(f"ðŸ“Š Detailed Analysis: {signal_col.replace('_Signal', '').replace('_Combined_Signal', ' Combined')}", 
                    className="text-lg font-semibold mb-3"),
            html.P(f"In-depth analysis of {signal_col.replace('_Signal', '')} signals for {ticker}", 
                className="text-gray-600 mb-4"),
            
            # Enhanced signal summary with more metrics
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Buy Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{buy_count}", className="block text-xl font-bold text-green-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Sell Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{sell_count}", className="block text-xl font-bold text-red-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Hold Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{hold_count}", className="block text-xl font-bold text-gray-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Activity Rate", className="block text-sm text-gray-500"),
                        html.Span(f"{activity_rate:.1f}%", className="block text-xl font-bold text-blue-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Effectiveness Rate", className="block text-sm text-gray-500"),
                        html.Span(f"{effectiveness_rate:.1f}%", className="block text-xl font-bold text-purple-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
            ], className="flex -mx-2 mb-6"),
            
            # Additional insights
            html.Div([
                html.H5("ðŸ“ˆ Signal Insights", className="text-md font-semibold mb-3"),
                html.Div([
                    html.P([
                        "ðŸ“Š ",
                        html.Strong("Signal Frequency: "),
                        signal_frequency
                    ], className="mb-2"),
                    html.P([
                        "ðŸŽ¯ ",
                        html.Strong("Buy/Sell Ratio: "),
                        f"{buy_count}/{sell_count} = {(buy_count/max(1, sell_count)):.2f}"
                    ], className="mb-2"),
                    html.P([
                        "âš¡ ",
                        html.Strong("Signal Effectiveness: "),
                        f"{effectiveness_rate:.1f}% of signals predicted correct price movement"
                    ], className="mb-2"),
                    html.P([
                        "ðŸ“… ",
                        html.Strong("Analysis Period: "),
                        f"{total_records} total records analyzed"
                    ], className="mb-2")
                ], className="p-4 bg-blue-50 rounded-lg border border-blue-200")
            ], className="mb-6"),
            
            # Signal effectiveness analysis table
            html.Div([
                html.H5("âš¡ Signal Effectiveness Analysis", className="text-md font-semibold mb-3"),
                html.P("Analysis of how well signals predicted future price movements (5-period lookahead)", 
                    className="text-sm text-gray-600 mb-3"),
                
                dash_table.DataTable(
                    data=effectiveness_data[:25] if effectiveness_data else [],  # Show first 25
                    columns=[
                        {'name': 'Date', 'id': 'Date'},
                        {'name': 'Signal', 'id': 'Signal'},
                        {'name': 'Price', 'id': 'Price'},
                        {'name': 'Price Change (5 periods)', 'id': 'Price Change (5 periods)'},
                        {'name': 'Effectiveness', 'id': 'Effectiveness'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Signal} = "Buy"', 'column_id': 'Signal'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{Signal} = "Sell"', 'column_id': 'Signal'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Effectiveness} = "Correct"', 'column_id': 'Effectiveness'},
                            'color': 'green',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{Effectiveness} = "Incorrect"', 'column_id': 'Effectiveness'},
                            'color': 'red',
                            'fontWeight': 'bold'
                        }
                    ],
                    page_size=15,
                    sort_action='native',
                    filter_action='native'
                )
            ], className="mb-6") if effectiveness_data else html.Div("No effectiveness data available", className="text-gray-500"),
            
            # Monthly timing analysis
            html.Div([
                html.H5("ðŸ“… Signal Timing Analysis", className="text-md font-semibold mb-3"),
                
                dash_table.DataTable(
                    data=timing_analysis[:12] if timing_analysis else [],  # Show last 12 months
                    columns=[
                        {'name': 'Month', 'id': 'Month'},
                        {'name': 'Buy Signals', 'id': 'Buy Signals'},
                        {'name': 'Sell Signals', 'id': 'Sell Signals'},
                        {'name': 'Total Signals', 'id': 'Total'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'center', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[
                        {
                            'if': {'column_id': 'Buy Signals'},
                            'color': 'green'
                        },
                        {
                            'if': {'column_id': 'Sell Signals'},
                            'color': 'red'
                        }
                    ],
                    sort_action='native'
                )
            ], className="mb-6") if timing_analysis else html.Div()
        ])

    # Fix the dropdown creation to use pattern matching IDs
    def create_enhanced_ticker_table_with_pattern_matching(filtered_df, selected_ticker):
        """Create enhanced data table with properly working signal analysis dropdown"""
        if filtered_df.empty:
            return html.Div("No data to display", className="text-gray-500")
        
        # Get signal columns
        individual_signal_cols = [col for col in filtered_df.columns 
                                if col.endswith('_Signal') and not col.endswith('_Combined_Signal')]
        voting_signal_cols = [col for col in filtered_df.columns 
                            if col.endswith('_Combined_Signal') and col != 'Combined_Signal']
        simple_combined = ['Combined_Signal'] if 'Combined_Signal' in filtered_df.columns else []
        
        all_signal_cols = individual_signal_cols + simple_combined + voting_signal_cols
        
        # Create dropdown options
        signal_analysis_options = [
            {'label': 'All Signals Overview', 'value': 'all'},
            {'label': '--- Individual Signals ---', 'value': 'separator1', 'disabled': True}
        ]
        
        # Add individual signals
        for col in individual_signal_cols:
            readable_name = col.replace('_Signal', '').replace('_', ' ')
            signal_analysis_options.append({
                'label': f"ðŸ“Š {readable_name}",
                'value': col
            })
        
        # Add simple combined
        if simple_combined:
            signal_analysis_options.append({'label': '--- Simple Combined ---', 'value': 'separator2', 'disabled': True})
            signal_analysis_options.append({
                'label': 'ðŸ”— Combined Signal (Simple)',
                'value': 'Combined_Signal'
            })
        
        # Add voting-based combined
        if voting_signal_cols:
            signal_analysis_options.append({'label': '--- Voting-Based Combined ---', 'value': 'separator3', 'disabled': True})
            for col in voting_signal_cols:
                try:
                    readable_name = extract_indicators_from_combined_name(col)
                    signal_analysis_options.append({
                        'label': f"ðŸ—³ï¸ {readable_name}",
                        'value': col
                    })
                except:
                    signal_analysis_options.append({
                        'label': f"ðŸ—³ï¸ {col.replace('_Combined_Signal', '')}",
                        'value': col
                    })
        
        # Create safe ticker ID for pattern matching
        ticker_safe = selected_ticker.replace(".", "-").replace(" ", "-").replace("/", "-")
        
        return html.Div([
            html.H4(f"ðŸ“‹ Enhanced Technical Analysis Data for {selected_ticker}", className="text-lg font-semibold mb-3"),
            html.P(f"Showing {len(filtered_df)} records with {len(individual_signal_cols)} individual indicators, "
                f"{len(simple_combined)} simple combined, and {len(voting_signal_cols)} voting-based signals.", 
                className="text-sm text-gray-600 mb-3"),
            
            # Signal Analysis Dropdown with pattern matching ID
            html.Div([
                html.Label("ðŸ” Select Signal for Detailed Analysis:", className="block text-sm font-medium text-gray-700 mb-2"),
                dcc.Dropdown(
                    id={'type': 'signal-dropdown', 'ticker': ticker_safe},
                    options=signal_analysis_options,
                    value='all',
                    className="w-full mb-4",
                    placeholder="Choose a signal to analyze..."
                )
            ], className="mb-6 p-4 bg-gray-50 rounded-lg border"),
            
            # Dynamic content container
            html.Div(id={'type': 'signal-content', 'ticker': ticker_safe}, className="mb-6"),
            
            # Hidden store for ticker data
            html.Div(
                id={'type': 'ticker-store', 'ticker': ticker_safe},
                style={'display': 'none'},
                children=filtered_df.to_json(date_format='iso', orient='split')
            ),
            
            # Complete data table
            html.H5("ðŸ“Š Complete Data Table (All Signals)", className="text-md font-semibold mt-6 mb-3"),
            create_complete_data_table(filtered_df, all_signal_cols)
        ])

    # # Make sure to register the pattern matching callback
    # register_signal_analysis_callbacks()






    def create_basic_ticker_table(filtered_df, selected_ticker):
        """Create basic data table as fallback"""
        try:
            # Essential columns only
            essential_cols = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume']
            display_cols = [col for col in essential_cols if col in filtered_df.columns]
            
            # Add any signal columns
            signal_cols = [col for col in filtered_df.columns if col.endswith('_Signal')]
            display_cols.extend(signal_cols[:5])  # Limit to first 5 signal columns
            
            return dash_table.DataTable(
                data=filtered_df[display_cols].to_dict('records'),
                columns=[{'name': col, 'id': col} for col in display_cols],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                page_size=20,
                sort_action='native'
            )
        except Exception as basic_error:
            return html.Div(f"Error creating basic table: {str(basic_error)}", className="text-red-500")

    # def extract_indicators_from_combined_name(combined_signal_name):
    #     """Extract indicator names from combined signal name - SAFE VERSION"""
    #     try:
    #         # Example: "MA_RSI_Volume_Combined_Signal" -> "MA, RSI, Volume"
    #         parts = combined_signal_name.replace('_Combined_Signal', '').split('_')
            
    #         indicator_mapping = {
    #             'Bollinger': 'Bollinger Bands',
    #             'BB': 'Bollinger Bands',
    #             'MA': 'Moving Average', 
    #             'RSI': 'RSI',
    #             'MACD': 'MACD',
    #             'ADX': 'ADX',
    #             'Fibonacci': 'Fibonacci',
    #             'FIBO': 'Fibonacci',
    #             'Candlestick': 'Candlestick',
    #             'CANDLE': 'Candlestick',
    #             'Volume': 'Volume'
    #         }
            
    #         readable_names = []
    #         for part in parts:
    #             if part in indicator_mapping:
    #                 readable_names.append(indicator_mapping[part])
    #             else:
    #                 # Try to find partial matches
    #                 matched = False
    #                 for key, value in indicator_mapping.items():
    #                     if key.lower() in part.lower() or part.lower() in key.lower():
    #                         readable_names.append(value)
    #                         matched = True
    #                         break
    #                 if not matched:
    #                     readable_names.append(part)  # Use original if no mapping found
            
    #         return ', '.join(readable_names) if readable_names else combined_signal_name
            
    #     except Exception as e:
    #         print(f"Error extracting indicator names: {e}")
    #         return combined_signal_name.replace('_Combined_Signal', '').replace('_', ' ')

    def extract_indicators_from_combined_name(combined_signal_name):
        """Extract indicator names from combined signal name - ENHANCED VERSION"""
        try:
            # Remove the suffix first
            base_name = combined_signal_name.replace('_Combined_Signal', '')
            parts = base_name.split('_')
            
            # Enhanced mapping with more comprehensive indicator names
            indicator_mapping = {
                'Bollinger': 'Bollinger Bands',
                'BB': 'Bollinger Bands',
                'MA': 'Moving Average', 
                'RSI': 'RSI',
                'MACD': 'MACD',
                'ADX': 'ADX',
                'Fibonacci': 'Fibonacci Retracement',
                'FIBO': 'Fibonacci Retracement',
                'Candlestick': 'Candlestick Patterns',
                'CANDLE': 'Candlestick Patterns',
                'Volume': 'Volume Analysis',
                'VOL': 'Volume Analysis',
                # 'Stochastic': 'Stochastic Oscillator',
                # 'STOCH': 'Stochastic Oscillator',
                # 'Williams': 'Williams %R',
                # 'CCI': 'Commodity Channel Index',
                # 'OBV': 'On-Balance Volume'
            }
            
            readable_names = []
            for part in parts:
                # Direct mapping
                if part in indicator_mapping:
                    readable_names.append(indicator_mapping[part])
                else:
                    # Try partial matching
                    matched = False
                    for key, value in indicator_mapping.items():
                        if key.lower() in part.lower() or part.lower() in key.lower():
                            readable_names.append(value)
                            matched = True
                            break
                    
                    # If no match found, clean up the name
                    if not matched:
                        cleaned_name = part.replace('_', ' ').title()
                        readable_names.append(cleaned_name)
            
            # Remove duplicates while preserving order
            unique_names = []
            for name in readable_names:
                if name not in unique_names:
                    unique_names.append(name)
            
            return ' + '.join(unique_names) if unique_names else base_name.replace('_', ' ')
            
        except Exception as e:
            print(f"Error extracting indicator names from {combined_signal_name}: {e}")
            return combined_signal_name.replace('_Combined_Signal', '').replace('_', ' ')




    def create_complete_data_table(filtered_df, all_signal_cols):
        """Create complete data table for ticker data - FIXED for CANDLESTICK TREND"""
        if filtered_df.empty:
            return html.Div("No data available", className="text-gray-500")
        
        # Prepare display columns in logical order
        display_columns = []
        
        # Essential price columns first
        essential_cols = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume']
        for col in essential_cols:
            if col in filtered_df.columns:
                display_columns.append({'name': col, 'id': col})
        
        # Technical indicator values
        tech_cols = [col for col in filtered_df.columns if col in ['RSI', 'MACD', 'Signal_Line', 'MACD_Hist', 'ADX', '+DI', '-DI', 'Upper Band', 'Lower Band', 'Middle Band', 'short_MA', 'long_MA', 'VMA']]
        for col in sorted(tech_cols):
            if col in filtered_df.columns:
                display_columns.append({'name': col, 'id': col})
        
        # Add detected_patterns and candlestick_trend columns if they exist
        if 'detected_patterns' in filtered_df.columns:
            display_columns.append({'name': 'Detected Patterns', 'id': 'detected_patterns'})
        
        if 'candlestick_trend' in filtered_df.columns:
            display_columns.append({'name': 'Candlestick Trend', 'id': 'candlestick_trend'})
        
        if 'candlestick_confidence' in filtered_df.columns:
            display_columns.append({'name': 'Pattern Confidence', 'id': 'candlestick_confidence'})
        
        # Signal columns - exclude Candlestick_Signal if candlestick_trend is present
        signal_cols = [col for col in all_signal_cols if col != 'Candlestick_Signal' or ('candlestick_trend' not in filtered_df.columns)]
        for col in sorted(signal_cols):
            if col in filtered_df.columns:
                display_columns.append({'name': col.replace('_Signal', ''), 'id': col})
        
        # Prepare table data with proper formatting
        table_data = []
        for _, row in filtered_df.iterrows():
            row_data = {}
            for col in display_columns:
                col_id = col['id']
                if col_id in filtered_df.columns:
                    if col_id == 'Datetime':
                        row_data[col_id] = row[col_id].strftime('%Y-%m-%d %H:%M') if pd.notna(row[col_id]) else ""
                    elif col_id in ['Open', 'High', 'Low', 'Close', 'Upper Band', 'Lower Band', 'Middle Band', 'short_MA', 'long_MA']:
                        row_data[col_id] = f"{row[col_id]:.2f}" if pd.notna(row[col_id]) else ""
                    elif col_id in ['RSI', 'MACD', 'Signal_Line', 'MACD_Hist', 'ADX', '+DI', '-DI']:
                        row_data[col_id] = f"{row[col_id]:.4f}" if pd.notna(row[col_id]) else ""
                    elif col_id == 'candlestick_confidence':
                        row_data[col_id] = f"{row[col_id]:.1f}%" if pd.notna(row[col_id]) else ""
                    else:
                        row_data[col_id] = row[col_id]
            table_data.append(row_data)
        
        # Create conditional styling for signals - FIXED for CANDLESTICK TREND
        signal_conditional_styling = []
        
        # Add special formatting for candlestick trend
        if 'candlestick_trend' in filtered_df.columns:
            signal_conditional_styling.extend([
                {
                    'if': {'filter_query': '{candlestick_trend} = "Uptrend"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{candlestick_trend} = "Downtrend"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{candlestick_trend} = "Sideways"', 'column_id': 'candlestick_trend'},
                    'backgroundColor': 'rgba(128, 128, 128, 0.2)',
                    'color': 'gray',
                    'fontWeight': 'bold'
                }
            ])
        
        # Add formatting for standard signals
        for col_info in display_columns:
            col_id = col_info['id']
            if col_id.endswith('_Signal'):
                signal_conditional_styling.extend([
                    {
                        'if': {'filter_query': '{' + col_id + '} = "Buy"', 'column_id': col_id},
                        'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                        'color': 'green',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'filter_query': '{' + col_id + '} = "Sell"', 'column_id': col_id},
                        'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                        'color': 'red',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'filter_query': '{' + col_id + '} = "Hold"', 'column_id': col_id},
                        'backgroundColor': 'rgba(128, 0, 128, 0.1)',
                        'color': 'purple'
                    },
                    {
                        'if': {'filter_query': '{' + col_id + '} = "High Volume"', 'column_id': col_id},
                        'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                        'color': 'green',
                        'fontWeight': 'bold'
                    },
                    {
                        'if': {'filter_query': '{' + col_id + '} = "Low Volume"', 'column_id': col_id},
                        'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                        'color': 'red'
                    }
                ])
        
        return html.Div([
            html.P(f"Showing {len(table_data)} records with candlestick trend and patterns directly displayed.", 
                className="text-sm text-gray-600 mb-3"),
            
            dash_table.DataTable(
                data=table_data,
                columns=display_columns,
                style_table={'overflowX': 'auto'},
                style_cell={
                    'textAlign': 'left', 
                    'padding': '8px',
                    'fontSize': '12px',
                    'whiteSpace': 'normal',
                    'height': 'auto',
                    'maxWidth': '150px'
                },
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold',
                    'fontSize': '12px'
                },
                style_data_conditional=signal_conditional_styling,
                page_size=20,
                sort_action='native',
                filter_action='native',
                export_format='xlsx',
                export_headers='display'
            )
        ])



    # Add callback for signal analysis dropdown
    @app.callback(
        Output({'type': 'signal-content', 'ticker': MATCH}, 'children'),
        [Input({'type': 'signal-dropdown', 'ticker': MATCH}, 'value')],
        [State({'type': 'ticker-store', 'ticker': MATCH}, 'children')],
        prevent_initial_call=True
    )
    def update_signal_analysis_content(selected_signal, ticker_data_json):
        import pandas as pd
        import json
        from dash import html

        if not selected_signal or not ticker_data_json:
            return html.Div("Select a signal to view detailed analysis", className="text-gray-500 p-4")
        try:
            df = pd.read_json(ticker_data_json, orient='split')
            # Hanya kolom _Signal atau Combined_Signal, exclude detected_patterns
            signal_cols = [col for col in df.columns if (col.endswith('_Signal') or col == 'Combined_Signal') and col != 'detected_patterns']
            if selected_signal == 'all':
                # Tampilkan summary semua signal
                summary_data = []
                for col in signal_cols:
                    buy = (df[col] == 'Buy').sum()
                    sell = (df[col] == 'Sell').sum()
                    hold = (df[col] == 'Hold').sum()
                    total = buy + sell + hold
                    summary_data.append({
                        'Signal Type': col,
                        'Buy Count': buy,
                        'Sell Count': sell,
                        'Hold Count': hold,
                        'Activity Rate': f"{((buy+sell)/total*100) if total else 0:.1f}%" if total else "0%",
                        'Buy/Sell Ratio': f"{(buy/sell):.2f}" if sell else "-",
                        'Effectiveness': "High" if buy+sell > hold else "Low"
                    })
                return dash_table.DataTable(
                    data=summary_data,
                    columns=[
                        {'name': 'Signal Type', 'id': 'Signal Type'},
                        {'name': 'Buy Count', 'id': 'Buy Count'},
                        {'name': 'Sell Count', 'id': 'Sell Count'},
                        {'name': 'Hold Count', 'id': 'Hold Count'},
                        {'name': 'Activity Rate', 'id': 'Activity Rate'},
                        {'name': 'Buy/Sell Ratio', 'id': 'Buy/Sell Ratio'},
                        {'name': 'Effectiveness', 'id': 'Effectiveness'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'center', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    page_size=10
                )
            elif selected_signal in signal_cols:
                # Tampilkan detail untuk signal terpilih saja
                buy = (df[selected_signal] == 'Buy').sum()
                sell = (df[selected_signal] == 'Sell').sum()
                hold = (df[selected_signal] == 'Hold').sum()
                total = buy + sell + hold
                return html.Div([
                    html.H4(f"Analysis for {selected_signal}", className="text-lg font-semibold mb-3"),
                    html.P(f"Buy: {buy}, Sell: {sell}, Hold: {hold}, Total: {total}"),
                    dash_table.DataTable(
                        data=df[df[selected_signal] != 'Hold'].to_dict('records'),
                        columns=[{'name': col, 'id': col} for col in df.columns],
                        page_size=15,
                        style_table={'overflowX': 'auto'}
                    )
                ])
            else:
                return html.Div("No data for selected signal.", className="text-gray-500 p-4")
        except Exception as e:
            return html.Div(f"Error: {str(e)}", className="text-red-500 p-4")
    

    def create_candlestick_pattern_analysis(df, ticker):
        """Create a detailed candlestick pattern analysis display"""
        if 'detected_patterns' not in df.columns or 'candlestick_trend' not in df.columns:
            return html.Div("No candlestick pattern data available", className="text-gray-500 p-4")
        
        # Import pattern descriptions
        from Candlestick_pattern import get_pattern_description, get_candlestick_explanations
        
        # Get pattern explanations
        explanations = get_candlestick_explanations()
        
        # Count pattern occurrences
        pattern_counts = {}
        for idx, row in df.iterrows():
            if pd.notna(row['detected_patterns']) and row['detected_patterns']:
                patterns = row['detected_patterns'].split(', ')
                for pattern in patterns:
                    if pattern in pattern_counts:
                        pattern_counts[pattern] += 1
                    else:
                        pattern_counts[pattern] = 1
        
        # Sort patterns by frequency
        sorted_patterns = sorted(pattern_counts.items(), key=lambda x: x[1], reverse=True)
        
        # Count trend occurrences
        trend_counts = df['candlestick_trend'].value_counts()
        
        # Create the analysis components
        return html.Div([
            html.H3("ðŸ•¯ï¸ Candlestick Pattern Analysis", className="text-xl font-semibold mb-4"),
            
            # Overview section
            html.Div([
                html.P(explanations['overview'], className="mb-3")
            ], className="mb-6 p-4 bg-blue-50 rounded"),
            
            # Trend statistics
            html.Div([
                html.H4("ðŸ“ˆ Trend Analysis", className="text-lg font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Div([
                            html.Span("Uptrend Days", className="block text-sm text-gray-500"),
                            html.Span(f"{trend_counts.get('Uptrend', 0)}", className="block text-xl font-bold text-green-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/3 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Downtrend Days", className="block text-sm text-gray-500"),
                            html.Span(f"{trend_counts.get('Downtrend', 0)}", className="block text-xl font-bold text-red-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/3 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Sideways Days", className="block text-sm text-gray-500"),
                            html.Span(f"{trend_counts.get('Sideways', 0)}", className="block text-xl font-bold text-blue-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/3 px-2"),
                ], className="flex -mx-2 mb-6")
            ], className="mb-6"),
            
            # Pattern frequency
            html.Div([
                html.H4("ðŸ” Pattern Frequency", className="text-lg font-semibold mb-3"),
                dash_table.DataTable(
                    data=[
                        {'Pattern': pattern, 'Count': count, 'Percentage': f"{count/len(df)*100:.1f}%"}
                        for pattern, count in sorted_patterns
                    ],
                    columns=[
                        {'name': 'Pattern', 'id': 'Pattern'},
                        {'name': 'Count', 'id': 'Count'},
                        {'name': 'Percentage', 'id': 'Percentage'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[],
                    page_size=10
                )
            ], className="mb-6"),
            
            # Pattern details
            html.Div([
                html.H4("ðŸ“š Pattern Descriptions", className="text-lg font-semibold mb-3"),
                html.Details([
                    html.Summary("View Pattern Descriptions", className="cursor-pointer text-blue-600 mb-2"),
                    html.Div([
                        html.Div([
                            html.H5(pattern, className="font-semibold mb-1"),
                            html.P(get_pattern_description(pattern), className="mb-3 text-sm")
                        ])
                        for pattern, _ in sorted_patterns[:10]  # Show top 10 patterns
                    ], className="p-3 bg-gray-50 rounded")
                ])
            ], className="mb-6"),
            
            # Detailed data table
            html.Div([
                html.H4("ðŸ“… Daily Patterns", className="text-lg font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'Date': row['Datetime'].strftime('%Y-%m-%d') if 'Datetime' in df.columns and pd.notna(row['Datetime']) else '',
                        'Trend': row['candlestick_trend'],
                        'Confidence': f"{row['candlestick_confidence']:.0f}%" if pd.notna(row['candlestick_confidence']) else '',
                        'Detected Patterns': row['detected_patterns']
                    } for _, row in df.iterrows() if pd.notna(row['detected_patterns']) and row['detected_patterns']],
                    columns=[
                        {'name': 'Date', 'id': 'Date'},
                        {'name': 'Trend', 'id': 'Trend'},
                        {'name': 'Confidence', 'id': 'Confidence'},
                        {'name': 'Detected Patterns', 'id': 'Detected Patterns'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Trend} = "Uptrend"', 'column_id': 'Trend'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{Trend} = "Downtrend"', 'column_id': 'Trend'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Trend} = "Sideways"', 'column_id': 'Trend'},
                            'backgroundColor': 'rgba(0, 0, 255, 0.1)',
                            'color': 'blue'
                        }
                    ],
                    page_size=15,
                    sort_action='native',
                    filter_action='native'
                )
            ])
        ], className="p-4 bg-white rounded shadow")





    def create_all_signals_overview(df):
        """Create overview of all signals"""
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        if not signal_cols:
            return html.Div("No signal data available", className="text-gray-500")
        
        # Create summary statistics
        summary_data = []
        for col in signal_cols:
            signal_counts = df[col].value_counts()
            summary_data.append({
                'Signal Type': col.replace('_Signal', '').replace('_Combined_Signal', ' Combined'),
                'Buy Count': signal_counts.get('Buy', 0),
                'Sell Count': signal_counts.get('Sell', 0),
                'Hold Count': signal_counts.get('Hold', 0),
                'Total Signals': len(df),
                'Activity Rate': f"{((signal_counts.get('Buy', 0) + signal_counts.get('Sell', 0)) / len(df) * 100):.1f}%",
                'Buy/Sell Ratio': f"{(signal_counts.get('Buy', 0) / max(1, signal_counts.get('Sell', 0))):.2f}"
            })
        
        return html.Div([
            html.H4("ðŸ“ˆ All Signals Overview", className="text-lg font-semibold mb-3"),
            
            # Summary table
            dash_table.DataTable(
                data=summary_data,
                columns=[
                    {'name': 'Signal Type', 'id': 'Signal Type'},
                    {'name': 'Buy Count', 'id': 'Buy Count'},
                    {'name': 'Sell Count', 'id': 'Sell Count'},
                    {'name': 'Hold Count', 'id': 'Hold Count'},
                    {'name': 'Activity Rate', 'id': 'Activity Rate'},
                    {'name': 'Buy/Sell Ratio', 'id': 'Buy/Sell Ratio'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'center', 'padding': '10px'},
                style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                style_data_conditional=[
                    {
                        'if': {'column_id': 'Buy Count'},
                        'color': 'green'
                    },
                    {
                        'if': {'column_id': 'Sell Count'},
                        'color': 'red'
                    }
                ]
            ),
            
            # Visual comparison
            html.Div([
                html.H5("ðŸ“Š Signal Activity Comparison", className="text-md font-semibold mt-4 mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Bar(
                                name='Buy Signals',
                                x=[s['Signal Type'] for s in summary_data],
                                y=[s['Buy Count'] for s in summary_data],
                                marker_color='green',
                                opacity=0.7
                            ),
                            go.Bar(
                                name='Sell Signals',
                                x=[s['Signal Type'] for s in summary_data],
                                y=[s['Sell Count'] for s in summary_data],
                                marker_color='red',
                                opacity=0.7
                            )
                        ],
                        layout=go.Layout(
                            title='Buy vs Sell Signals by Type',
                            barmode='group',
                            height=400,
                            xaxis_tickangle=-45
                        )
                    )
                )
            ])
        ])

    def create_individual_signal_analysis(df, signal_col):
        """Create detailed analysis for individual signal"""
        if signal_col not in df.columns:
            return html.Div(f"Signal {signal_col} not found", className="text-red-500")
        
        signal_counts = df[signal_col].value_counts()
        signal_data = df[df[signal_col].isin(['Buy', 'Sell'])].copy()
        
        # Calculate signal effectiveness if possible
        effectiveness_data = []
        if not signal_data.empty and 'Close' in df.columns:
            for idx in signal_data.index:
                current_signal = signal_data.loc[idx, signal_col]
                current_price = signal_data.loc[idx, 'Close']
                
                # Look ahead 5 periods to see if signal was effective
                future_idx = min(idx + 5, len(df) - 1)
                future_price = df.loc[future_idx, 'Close']
                
                price_change = (future_price - current_price) / current_price * 100
                
                # Determine if signal was correct
                if current_signal == 'Buy' and price_change > 0:
                    effectiveness = 'Correct'
                elif current_signal == 'Sell' and price_change < 0:
                    effectiveness = 'Correct'
                else:
                    effectiveness = 'Incorrect'
                
                effectiveness_data.append({
                    'Date': signal_data.loc[idx, 'Datetime'] if 'Datetime' in signal_data.columns else idx,
                    'Signal': current_signal,
                    'Price': current_price,
                    'Price Change (5 periods)': f"{price_change:.2f}%",
                    'Effectiveness': effectiveness
                })
        
        return html.Div([
            html.H4(f"ðŸ“Š Detailed Analysis: {signal_col.replace('_Signal', '').replace('_Combined_Signal', ' Combined')}", 
                    className="text-lg font-semibold mb-3"),
            
            # Signal summary
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Buy Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{signal_counts.get('Buy', 0)}", className="block text-xl font-bold text-green-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Sell Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{signal_counts.get('Sell', 0)}", className="block text-xl font-bold text-red-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Hold Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{signal_counts.get('Hold', 0)}", className="block text-xl font-bold text-gray-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Activity Rate", className="block text-sm text-gray-500"),
                        html.Span(f"{((signal_counts.get('Buy', 0) + signal_counts.get('Sell', 0)) / len(df) * 100):.1f}%", 
                                className="block text-xl font-bold text-blue-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/4 px-2"),
            ], className="flex -mx-2 mb-6"),
            
            # Signal effectiveness analysis
            html.Div([
                html.H5("âš¡ Signal Effectiveness Analysis", className="text-md font-semibold mb-3"),
                html.P("Analysis of how well signals predicted future price movements (5-period lookahead)", 
                    className="text-sm text-gray-600 mb-3"),
                
                dash_table.DataTable(
                    data=effectiveness_data[:20] if effectiveness_data else [],  # Show first 20
                    columns=[
                        {'name': 'Date', 'id': 'Date'},
                        {'name': 'Signal', 'id': 'Signal'},
                        {'name': 'Price', 'id': 'Price'},
                        {'name': 'Price Change (5 periods)', 'id': 'Price Change (5 periods)'},
                        {'name': 'Effectiveness', 'id': 'Effectiveness'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Signal} = "Buy"', 'column_id': 'Signal'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{Signal} = "Sell"', 'column_id': 'Signal'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Effectiveness} = "Correct"', 'column_id': 'Effectiveness'},
                            'color': 'green',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{Effectiveness} = "Incorrect"', 'column_id': 'Effectiveness'},
                            'color': 'red',
                            'fontWeight': 'bold'
                        }
                    ],
                    page_size=10
                )
            ]) if effectiveness_data else html.Div("No effectiveness data available", className="text-gray-500")
        ])



    

    def create_enhanced_technical_analysis_breakdown(df, individual_signals, voting_signals):
        """Create enhanced breakdown including voting-based signals"""
        
        breakdown_components = [
            html.H5("ðŸ”§ Enhanced Technical Analysis Breakdown", className="text-md font-semibold mb-4"),
            
            # Individual signals section
            html.Div([
                html.H6("ðŸ’¡ Individual Technical Indicators", className="text-sm font-semibold mb-3 text-blue-600"),
                create_signals_summary_table(df, individual_signals, "Individual")
            ], className="mb-4"),
            
            # Voting-based signals section
            html.Div([
                html.H6("ðŸ—³ï¸ Voting-Based Combined Signals", className="text-sm font-semibold mb-3 text-purple-600"),
                create_signals_summary_table(df, voting_signals, "Voting-Based", include_details=True)
            ], className="mb-4")
        ]
        
        return html.Div(breakdown_components, className="mb-6 p-4 bg-gray-50 rounded-lg")



    def create_signals_summary_table(df, signal_columns, signal_type, include_details=False):
        """Create summary table for signals with optional voting details"""
        if not signal_columns:
            return html.Div(f"No {signal_type.lower()} signals available", className="text-gray-500")
        
        summary_data = []
        for col in signal_columns:
            if col in df.columns:
                signal_counts = df[col].value_counts()
                
                row_data = {
                    'Signal': col.replace('_Signal', '').replace('_Combined_Signal', ''),
                    'Buy': signal_counts.get('Buy', 0),
                    'Sell': signal_counts.get('Sell', 0),
                    'Hold': signal_counts.get('Hold', 0),
                    'Total': len(df),
                    'Activity %': f"{((signal_counts.get('Buy', 0) + signal_counts.get('Sell', 0)) / len(df) * 100):.1f}%"
                }
                
                # Add voting details for voting-based signals
                if include_details and col.endswith('_Combined_Signal'):
                    indicators_used = extract_indicators_from_combined_name(col)
                    row_data['Indicators'] = indicators_used
                
                summary_data.append(row_data)
        
        columns = [
            {'name': 'Signal Type', 'id': 'Signal'},
            {'name': 'Buy', 'id': 'Buy'},
            {'name': 'Sell', 'id': 'Sell'},
            {'name': 'Hold', 'id': 'Hold'},
            {'name': 'Activity %', 'id': 'Activity %'}
        ]
        
        if include_details:
            columns.insert(-1, {'name': 'Indicators Used', 'id': 'Indicators'})
        
        return dash_table.DataTable(
            data=summary_data,
            columns=columns,
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'center', 'padding': '8px', 'fontSize': '12px'},
            style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
            style_data_conditional=[
                {
                    'if': {'column_id': 'Buy'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'column_id': 'Sell'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red',
                    'fontWeight': 'bold'
                }
            ]
        )

    # def extract_indicators_from_combined_name(combined_signal_name):
    #     """Extract indicator names from combined signal name"""
    #     # Example: "MA_RSI_Volume_Combined_Signal" -> "MA, RSI, Volume"
    #     parts = combined_signal_name.replace('_Combined_Signal', '').split('_')
        
    #     indicator_mapping = {
    #         'BB': 'Bollinger Bands',
    #         'MA': 'Moving Average', 
    #         'RSI': 'RSI',
    #         'MACD': 'MACD',
    #         'ADX': 'ADX',
    #         'FIBO': 'Fibonacci',
    #         'CANDLE': 'Candlestick',
    #         'Volume': 'Volume'
    #     }
        
    #     readable_names = []
    #     for part in parts:
    #         readable_names.append(indicator_mapping.get(part, part))
        
    #     return ', '.join(readable_names)














    # def create_technical_analysis_breakdown_tables(df, signal_cols):
    #     """Create breakdown tables for each technical analysis indicator"""
    #     if df.empty or not signal_cols:
    #         return html.Div("No technical analysis data available", className="text-gray-500")
        
    #     # Group signal columns by indicator type
    #     indicator_groups = {}
        
    #     for col in signal_cols:
    #         if col == 'Combined_Signal':
    #             indicator_groups['Combined_Signal'] = ['Combined_Signal']
    #         elif 'Bollinger' in col:
    #             if 'Bollinger Bands' not in indicator_groups:
    #                 indicator_groups['Bollinger Bands'] = []
    #             indicator_groups['Bollinger Bands'].append(col)
    #         elif 'MA_Signal' in col:
    #             if 'Moving Average' not in indicator_groups:
    #                 indicator_groups['Moving Average'] = []
    #             indicator_groups['Moving Average'].append(col)
    #         elif 'RSI' in col:
    #             if 'RSI' not in indicator_groups:
    #                 indicator_groups['RSI'] = []
    #             indicator_groups['RSI'].append(col)
    #         elif 'MACD' in col:
    #             if 'MACD' not in indicator_groups:
    #                 indicator_groups['MACD'] = []
    #             indicator_groups['MACD'].append(col)
    #         elif 'ADX' in col:
    #             if 'ADX' not in indicator_groups:
    #                 indicator_groups['ADX'] = []
    #             indicator_groups['ADX'].append(col)
    #         else:
    #             # Other indicators
    #             indicator_name = col.replace('_Signal', '')
    #             if indicator_name not in indicator_groups:
    #                 indicator_groups[indicator_name] = []
    #             indicator_groups[indicator_name].append(col)
        
    #     breakdown_components = []
        
    #     breakdown_components.append(html.H5("ðŸ”§ Technical Analysis Breakdown", className="text-md font-semibold mb-4"))
        
    #     for indicator_name, signal_columns in indicator_groups.items():
    #         # Create summary table for this indicator
    #         summary_table = create_indicator_summary_table(df, indicator_name, signal_columns)
            
    #         # Create detailed breakdown table for this indicator
    #         detailed_table = create_indicator_detailed_table(df, indicator_name, signal_columns)
            
    #         # Create collapsible section for each indicator
    #         breakdown_components.append(html.Div([
    #             # Summary section (always visible)
    #             html.Div([
    #                 html.H6(f"ðŸ“Š {indicator_name} Analysis", className="text-sm font-semibold mb-2"),
    #                 summary_table
    #             ], className="mb-3"),
                
    #             # Collapsible detailed section
    #             html.Details([
    #                 html.Summary(f"ðŸ“‹ View Detailed {indicator_name} Signals & Values", 
    #                         className="cursor-pointer text-sm font-medium text-blue-600 hover:text-blue-800 mb-2"),
    #                 html.Div([
    #                     detailed_table
    #                 ], className="mt-3")
    #             ], className="mb-4")
    #         ], className="p-3 border border-gray-200 rounded-lg bg-gray-50 mb-3"))
        
    #     return html.Div(breakdown_components, className="mb-6")

    # def create_indicator_summary_table(df, indicator_name, signal_columns):
    #     """Create summary table showing signal distribution for an indicator"""
    #     summary_data = []
        
    #     for col in signal_columns:
    #         if col in df.columns:
    #             signal_counts = df[col].value_counts()
    #             buy_count = signal_counts.get('Buy', 0)
    #             sell_count = signal_counts.get('Sell', 0)
    #             hold_count = signal_counts.get('Hold', 0)
                
    #             total_signals = buy_count + sell_count + hold_count
    #             buy_pct = (buy_count / total_signals * 100) if total_signals > 0 else 0
    #             sell_pct = (sell_count / total_signals * 100) if total_signals > 0 else 0
    #             hold_pct = (hold_count / total_signals * 100) if total_signals > 0 else 0
                
    #             summary_data.append({
    #                 'Signal Column': col.replace('_Signal', ''),
    #                 'Buy': buy_count,
    #                 'Buy %': f"{buy_pct:.1f}%",
    #                 'Sell': sell_count,
    #                 'Sell %': f"{sell_pct:.1f}%",
    #                 'Hold': hold_count,
    #                 'Hold %': f"{hold_pct:.1f}%",
    #                 'Total': total_signals
    #             })
        
    #     if not summary_data:
    #         return html.Div("No signal data available", className="text-gray-500 text-sm")
        
    #     return dash_table.DataTable(
    #         data=summary_data,
    #         columns=[
    #             {'name': 'Signal Type', 'id': 'Signal Column'},
    #             {'name': 'Buy', 'id': 'Buy'},
    #             {'name': 'Buy %', 'id': 'Buy %'},
    #             {'name': 'Sell', 'id': 'Sell'},
    #             {'name': 'Sell %', 'id': 'Sell %'},
    #             {'name': 'Hold', 'id': 'Hold'},
    #             {'name': 'Hold %', 'id': 'Hold %'},
    #             {'name': 'Total', 'id': 'Total'}
    #         ],
    #         style_table={'overflowX': 'auto'},
    #         style_cell={'textAlign': 'center', 'padding': '8px', 'fontSize': '12px'},
    #         style_header={
    #             'backgroundColor': 'rgb(240, 240, 240)',
    #             'fontWeight': 'bold',
    #             'fontSize': '12px'
    #         },
    #         style_data_conditional=[
    #             # Buy columns - green
    #             {
    #                 'if': {'column_id': 'Buy'},
    #                 'backgroundColor': 'rgba(0, 255, 0, 0.2)',
    #                 'color': 'green',
    #                 'fontWeight': 'bold'
    #             },
    #             {
    #                 'if': {'column_id': 'Buy %'},
    #                 'backgroundColor': 'rgba(0, 255, 0, 0.1)',
    #                 'color': 'green'
    #             },
    #             # Sell columns - red
    #             {
    #                 'if': {'column_id': 'Sell'},
    #                 'backgroundColor': 'rgba(255, 0, 0, 0.2)',
    #                 'color': 'red',
    #                 'fontWeight': 'bold'
    #             },
    #             {
    #                 'if': {'column_id': 'Sell %'},
    #                 'backgroundColor': 'rgba(255, 0, 0, 0.1)',
    #                 'color': 'red'
    #             },
    #             # Hold columns - purple
    #             {
    #                 'if': {'column_id': 'Hold'},
    #                 'backgroundColor': 'rgba(128, 0, 128, 0.2)',
    #                 'color': 'purple',
    #                 'fontWeight': 'bold'
    #             },
    #             {
    #                 'if': {'column_id': 'Hold %'},
    #                 'backgroundColor': 'rgba(128, 0, 128, 0.1)',
    #                 'color': 'purple'
    #             }
    #         ]
    #     )

    # def create_indicator_detailed_table(df, indicator_name, signal_columns):
    #     """Create detailed table showing signals with corresponding technical values"""
    #     if not signal_columns or df.empty:
    #         return html.Div("No data available", className="text-gray-500")
        
    #     # Determine which technical value columns to include based on indicator
    #     tech_value_cols = []
        
    #     if indicator_name == 'Bollinger Bands':
    #         tech_value_cols = ['Upper Band', 'Middle Band', 'Lower Band', 'Close']
    #     elif indicator_name == 'Moving Average':
    #         tech_value_cols = ['short_MA', 'long_MA', 'Close']
    #     elif indicator_name == 'RSI':
    #         tech_value_cols = ['RSI', 'Close']
    #     elif indicator_name == 'MACD':
    #         tech_value_cols = ['MACD', 'Signal_Line', 'MACD_Hist', 'Close']
    #     elif indicator_name == 'ADX':
    #         tech_value_cols = ['ADX', '+DI', '-DI', 'Close']
    #     else:
    #         tech_value_cols = ['Close']
        
    #     # Filter to include only existing columns
    #     available_tech_cols = [col for col in tech_value_cols if col in df.columns]
    #     available_signal_cols = [col for col in signal_columns if col in df.columns]
        
    #     if not available_signal_cols:
    #         return html.Div("No signal columns available", className="text-gray-500")
        
    #     # Create display columns
    #     display_columns = ['Datetime'] + available_tech_cols + available_signal_cols
    #     display_df = df[display_columns].copy()
        
    #     # Format datetime
    #     if 'Datetime' in display_df.columns:
    #         display_df['Datetime'] = display_df['Datetime'].dt.strftime('%Y-%m-%d %H:%M')
        
    #     # Format numeric columns
    #     for col in available_tech_cols:
    #         if col in display_df.columns:
    #             if col in ['Close', 'Upper Band', 'Middle Band', 'Lower Band', 'short_MA', 'long_MA']:
    #                 display_df[col] = display_df[col].apply(lambda x: f"{x:.2f}" if pd.notna(x) else "")
    #             else:
    #                 display_df[col] = display_df[col].apply(lambda x: f"{x:.4f}" if pd.notna(x) else "")
        
    #     # Create conditional formatting for signals
    #     signal_conditional_formatting = []
        
    #     for col in available_signal_cols:
    #         # Buy signals - green
    #         signal_conditional_formatting.append({
    #             'if': {'filter_query': '{' + col + '} = "Buy"', 'column_id': col},
    #             'backgroundColor': 'rgba(0, 255, 0, 0.3)',
    #             'color': 'green',
    #             'fontWeight': 'bold'
    #         })
    #         # Sell signals - red
    #         signal_conditional_formatting.append({
    #             'if': {'filter_query': '{' + col + '} = "Sell"', 'column_id': col},
    #             'backgroundColor': 'rgba(255, 0, 0, 0.3)',
    #             'color': 'red',
    #             'fontWeight': 'bold'
    #         })
    #         # Hold signals - purple
    #         signal_conditional_formatting.append({
    #             'if': {'filter_query': '{' + col + '} = "Hold"', 'column_id': col},
    #             'backgroundColor': 'rgba(128, 0, 128, 0.3)',
    #             'color': 'purple',
    #             'fontWeight': 'bold'
    #         })
        
    #     # Add special formatting for technical indicators
    #     if 'RSI' in available_tech_cols:
    #         signal_conditional_formatting.extend([
    #             {
    #                 'if': {'filter_query': '{RSI} > 70', 'column_id': 'RSI'},
    #                 'backgroundColor': 'rgba(255, 165, 0, 0.3)',
    #                 'color': 'darkorange',
    #                 'fontWeight': 'bold'
    #             },
    #             {
    #                 'if': {'filter_query': '{RSI} < 30', 'column_id': 'RSI'},
    #                 'backgroundColor': 'rgba(0, 100, 0, 0.3)',
    #                 'color': 'darkgreen',
    #                 'fontWeight': 'bold'
    #             }
    #         ])
        
    #     return html.Div([
    #         html.P(f"Showing detailed {indicator_name} signals with corresponding technical values. "
    #             f"Green = Buy, Red = Sell, Purple = Hold", 
    #             className="text-xs text-gray-600 mb-2"),
            
    #         dash_table.DataTable(
    #             data=display_df.to_dict('records'),
    #             columns=[{'name': col, 'id': col} for col in display_df.columns],
    #             style_table={'overflowX': 'auto'},
    #             style_cell={'textAlign': 'left', 'padding': '6px', 'fontSize': '11px'},
    #             style_header={
    #                 'backgroundColor': 'rgb(230, 230, 230)',
    #                 'fontWeight': 'bold',
    #                 'fontSize': '11px'
    #             },
    #             style_data_conditional=signal_conditional_formatting,
    #             page_size=15,
    #             sort_action='native',
    #             filter_action='native'
    #         )
    #     ])




    # def create_enhanced_price_chart_unique(df, selected_ticker):
    #     """Create enhanced price chart with signals"""
    #     if df.empty or 'Close' not in df.columns:
    #         return html.Div("No price data available", className="text-gray-500")
        
    #     fig = go.Figure()
        
    #     # Add price line
    #     fig.add_trace(go.Scatter(
    #         x=df['Datetime'],
    #         y=df['Close'],
    #         mode='lines',
    #         name='Close Price',
    #         line=dict(color='blue', width=2)
    #     ))
        
    #     # Add signal markers
    #     signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
    #     colors = ['green', 'red', 'orange', 'purple', 'brown', 'pink']
        
    #     for i, col in enumerate(signal_cols):
    #         color = colors[i % len(colors)]
            
    #         # Buy signals
    #         buy_mask = df[col] == 'Buy'
    #         if buy_mask.any():
    #             fig.add_trace(go.Scatter(
    #                 x=df.loc[buy_mask, 'Datetime'],
    #                 y=df.loc[buy_mask, 'Close'],
    #                 mode='markers',
    #                 name=f'{col.replace("_Signal", "")} Buy',
    #                 marker=dict(color=color, symbol='triangle-up', size=10)
    #             ))
            
    #         # Sell signals
    #         sell_mask = df[col] == 'Sell'
    #         if sell_mask.any():
    #             fig.add_trace(go.Scatter(
    #                 x=df.loc[sell_mask, 'Datetime'],
    #                 y=df.loc[sell_mask, 'Close'],
    #                 mode='markers',
    #                 name=f'{col.replace("_Signal", "")} Sell',
    #                 marker=dict(color=color, symbol='triangle-down', size=10)
    #             ))
        
    #     fig.update_layout(
    #         title=f"Price Chart with Signals - {selected_ticker}",
    #         xaxis_title="Date",
    #         yaxis_title="Price",
    #         height=500,
    #         legend=dict(
    #             yanchor="top",
    #             y=0.99,
    #             xanchor="left",
    #             x=1.01
    #         )
    #     )
        
    #     return dcc.Graph(figure=fig)



    def create_enhanced_price_chart_unique(df, selected_ticker):
        """Create enhanced price chart with signals separated by indicator and detailed analysis"""
        if df.empty or 'Close' not in df.columns:
            return html.Div("No price data available", className="text-gray-500")
        
        # Get available signal columns
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        if not signal_cols:
            return html.Div("No signal data available", className="text-gray-500")
        
        # Create main container with dropdown for indicator selection
        return html.Div([
            # Header with indicator selection
            html.Div([
                html.H3(f"ðŸ“ˆ Price Chart Analysis - {selected_ticker}", className="text-xl font-bold mb-4 text-blue-700"),
                html.Div([
                    html.Label("ðŸ”§ Select Technical Indicator:", className="block text-sm font-medium text-gray-700 mb-2"),
                    dcc.Dropdown(
                        id={'type': 'indicator-selector', 'ticker': selected_ticker},
                        options=[{'label': 'All Indicators', 'value': 'all'}] + 
                            [{'label': col.replace('_Signal', ''), 'value': col} for col in signal_cols],
                        value='all',
                        className="mb-4"
                    )
                ], className="mb-4 p-3 bg-gray-50 rounded-lg border"),
                
                # Summary metrics
                html.Div(id={'type': 'indicator-summary', 'ticker': selected_ticker}, className="mb-4")
            ]),
            
            # Chart container
            html.Div(id={'type': 'indicator-chart', 'ticker': selected_ticker}, className="mb-6"),
            
            # Signal analysis table container
            html.Div(id={'type': 'signal-analysis-table', 'ticker': selected_ticker}, className="mb-6"),
            
            # Store ticker data for callbacks
            html.Div(
                id={'type': 'ticker-data-store', 'ticker': selected_ticker},
                style={'display': 'none'},
                children=df.to_json(date_format='iso', orient='split')
            )
        ])

    # Callback untuk update chart dan analisis berdasarkan indicator selection
    @app.callback(
        [Output({'type': 'indicator-summary', 'ticker': MATCH}, 'children'),
        Output({'type': 'indicator-chart', 'ticker': MATCH}, 'children'),
        Output({'type': 'signal-analysis-table', 'ticker': MATCH}, 'children')],
        [Input({'type': 'indicator-selector', 'ticker': MATCH}, 'value')],
        [State({'type': 'ticker-data-store', 'ticker': MATCH}, 'children')],
        prevent_initial_call=True
    )
    def update_indicator_analysis(selected_indicator, ticker_data_json):
        """Update chart and analysis based on selected indicator - FIXED VERSION"""
        if not ticker_data_json:
            empty_div = html.Div("No data available", className="text-gray-500")
            return empty_div, empty_div, empty_div

        try:
            # Load data dengan error handling yang lebih baik
            from io import StringIO
            df = pd.read_json(StringIO(ticker_data_json), orient='split')
            
            # Debug print
            print(f"Loaded data shape: {df.shape}")
            print(f"Selected indicator: {selected_indicator}")
            print(f"Available columns: {df.columns.tolist()}")
            
            # Clean dan convert datetime
            if 'Datetime' in df.columns:
                df['Datetime'] = pd.to_datetime(df['Datetime'], errors='coerce')
                df = df.dropna(subset=['Datetime'])
                
                if df.empty:
                    empty_div = html.Div("No valid datetime data available", className="text-gray-500")
                    return empty_div, empty_div, empty_div
            
            # Get ticker name dari callback context
            ctx = dash.callback_context
            ticker = "Unknown"
            if ctx.triggered:
                try:
                    # Extract ticker dari callback context
                    prop_id = ctx.triggered[0]['prop_id']
                    if '"ticker":"' in prop_id:
                        start = prop_id.find('"ticker":"') + 10
                        end = prop_id.find('"', start)
                        ticker = prop_id[start:end]
                except Exception as ctx_error:
                    print(f"Error extracting ticker from context: {ctx_error}")
            
            # Generate components berdasarkan selection - FIXED
            try:
                if selected_indicator == 'all':
                    # PERBAIKAN: Pastikan fungsi ini mengembalikan komponen yang valid
                    summary = create_all_indicators_summary(df, ticker)
                    chart = create_all_indicators_chart_fixed(df, ticker)  # Gunakan versi yang diperbaiki
                    table = create_all_indicators_analysis_table(df, ticker)
                else:
                    summary = create_single_indicator_summary(df, ticker, selected_indicator)
                    chart = create_single_indicator_chart(df, ticker, selected_indicator)
                    table = create_single_indicator_analysis_table(df, ticker, selected_indicator)
                    
                return summary, chart, table
                
            except Exception as component_error:
                print(f"Error generating components: {component_error}")
                traceback.print_exc()  # Print full traceback for debugging
                error_div = html.Div([
                    html.P(f"Error generating analysis: {str(component_error)}", className="text-red-500"),
                    html.Details([
                        html.Summary("Show Error Details", className="cursor-pointer text-blue-600"),
                        html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs mt-2")
                    ])
                ])
                return error_div, error_div, error_div
                
        except Exception as e:
            print(f"Critical error in update_indicator_analysis: {e}")
            traceback.print_exc()
            error_div = html.Div([
                html.P(f"Critical error processing data: {str(e)}", className="text-red-500"),
                html.Details([
                    html.Summary("Show Full Error Details", className="cursor-pointer text-blue-600"),
                    html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs mt-2")
                ])
            ])
            return error_div, error_div, error_div
    

    def create_all_indicators_chart_fixed(df, ticker):
        """Create chart showing all indicators using enhanced chart generators - COMPLETELY FIXED VERSION"""
        try:
            print(f"create_all_indicators_chart_fixed called for {ticker}")
            print(f"DataFrame shape: {df.shape}")
            print(f"DataFrame columns: {df.columns.tolist()}")
            
            signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
            print(f"Found signal columns: {signal_cols}")
            
            if not signal_cols:
                return html.Div("No signal data available for charting", className="text-gray-500 p-4")
            
            # Pastikan datetime dalam format yang benar
            df_clean = df.copy()
            if 'Datetime' in df_clean.columns:
                df_clean['Datetime'] = pd.to_datetime(df_clean['Datetime'], errors='coerce')
                df_clean = df_clean.dropna(subset=['Datetime'])
                
                if df_clean.empty:
                    return html.Div("No valid datetime data for charting", className="text-red-500 p-4")
            
            charts = []
            successful_charts = 0
            
            for signal_col in signal_cols:
                try:
                    print(f"Processing signal column: {signal_col}")
                    
                    # Method 1: Try enhanced chart generator
                    chart = None
                    try:
                        chart = create_enhanced_technical_chart_with_signals(signal_col, df_clean)
                        if chart is not None:
                            print(f"Enhanced chart created successfully for {signal_col}")
                        else:
                            print(f"Enhanced chart returned None for {signal_col}")
                    except Exception as enhanced_error:
                        print(f"Enhanced chart failed for {signal_col}: {enhanced_error}")
                    
                    # Method 2: Fallback to basic chart if enhanced fails
                    if chart is None:
                        try:
                            print(f"Creating fallback chart for {signal_col}")
                            chart = create_fallback_signal_chart(df_clean, signal_col, ticker)
                            if chart is not None:
                                print(f"Fallback chart created successfully for {signal_col}")
                        except Exception as fallback_error:
                            print(f"Fallback chart failed for {signal_col}: {fallback_error}")
                    
                    # Method 3: Create simple basic chart as last resort
                    if chart is None:
                        try:
                            print(f"Creating simple basic chart for {signal_col}")
                            chart = create_simple_signal_chart(df_clean, signal_col, ticker)
                        except Exception as simple_error:
                            print(f"Simple chart failed for {signal_col}: {simple_error}")
                            chart = html.Div(f"Failed to create chart for {signal_col}: {str(simple_error)}", 
                                        className="text-red-500 p-2")
                    
                    # Add chart to collection if successful
                    if chart is not None:
                        charts.append(html.Div([
                            html.H5(f"ðŸ“ˆ {signal_col.replace('_Signal', '')} Analysis", 
                                className="text-md font-semibold mb-2 text-blue-600"),
                            chart
                        ], className="mb-6 p-4 border rounded shadow-sm"))
                        successful_charts += 1
                        print(f"Successfully added chart for {signal_col}")
                    else:
                        print(f"No chart created for {signal_col}")
                
                except Exception as signal_error:
                    print(f"Critical error processing {signal_col}: {signal_error}")
                    traceback.print_exc()
                    # Add error message instead of chart
                    charts.append(html.Div([
                        html.H5(f"âŒ {signal_col.replace('_Signal', '')} Analysis", 
                            className="text-md font-semibold mb-2 text-red-600"),
                        html.P(f"Error: {str(signal_error)}", className="text-red-500 p-2")
                    ], className="mb-6 p-4 border rounded shadow-sm bg-red-50"))
            
            print(f"Total charts created: {successful_charts}/{len(signal_cols)}")
            
            if charts:
                return html.Div([
                    html.H4(f"ðŸ“Š All Indicators Analysis for {ticker}", 
                        className="text-lg font-bold mb-4 text-blue-700"),
                    html.P(f"Displaying {successful_charts} out of {len(signal_cols)} available indicators.", 
                        className="text-gray-600 mb-4"),
                    html.Div(charts)
                ])
            else:
                return html.Div([
                    html.H4("âŒ No Charts Available", className="text-lg font-bold text-red-600 mb-2"),
                    html.P("Unable to generate any charts from the available signal data.", className="text-red-500"),
                    html.P(f"Available signal columns: {', '.join(signal_cols)}", className="text-gray-600"),
                    html.P(f"DataFrame info: {df.shape[0]} rows, {df.shape[1]} columns", className="text-gray-600")
                ], className="p-4 bg-red-50 border border-red-200 rounded")
                
        except Exception as e:
            print(f"Critical error in create_all_indicators_chart_fixed: {e}")
            traceback.print_exc()
            return html.Div([
                html.H4("âŒ Critical Error", className="text-lg font-bold text-red-600 mb-2"),
                html.P(f"Failed to create charts: {str(e)}", className="text-red-500"),
                html.Details([
                    html.Summary("Show Error Details", className="cursor-pointer text-blue-600"),
                    html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs")
                ])
            ], className="p-4 bg-red-50 border border-red-200 rounded")
    


    def create_simple_signal_chart(df, signal_col, ticker):
        """Create a very simple signal chart as last resort - GUARANTEED TO WORK"""
        try:
            print(f"Creating simple signal chart for {signal_col}")
            
            # Basic validation
            if df.empty:
                return html.Div("No data available", className="text-gray-500")
            
            if 'Close' not in df.columns:
                return html.Div("No price data available", className="text-gray-500")
            
            if signal_col not in df.columns:
                return html.Div(f"Signal column {signal_col} not found", className="text-gray-500")
            
            # Ensure datetime is available
            if 'Datetime' not in df.columns:
                df = df.reset_index()
                df['Datetime'] = pd.date_range(start='2023-01-01', periods=len(df), freq='D')
            
            # Create simple figure
            fig = go.Figure()
            
            # Add price line
            fig.add_trace(go.Scatter(
                x=df['Datetime'],
                y=df['Close'],
                mode='lines',
                name='Close Price',
                line=dict(color='blue', width=2)
            ))
            
            # Add signals if available
            try:
                # Buy signals
                buy_data = df[df[signal_col] == 'Buy']
                if not buy_data.empty and len(buy_data) > 0:
                    fig.add_trace(go.Scatter(
                        x=buy_data['Datetime'],
                        y=buy_data['Close'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=10, color='green'),
                        hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
                
                # Sell signals
                sell_data = df[df[signal_col] == 'Sell']
                if not sell_data.empty and len(sell_data) > 0:
                    fig.add_trace(go.Scatter(
                        x=sell_data['Datetime'],
                        y=sell_data['Close'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=10, color='red'),
                        hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
            except Exception as signal_error:
                print(f"Error adding signals: {signal_error}")
                # Continue without signals - at least show price chart
            
            # Update layout
            fig.update_layout(
                title=f"{signal_col.replace('_Signal', '')} Analysis - {ticker}",
                xaxis_title="Date",
                yaxis_title="Price",
                height=400,
                template="plotly_white",
                hovermode='x unified',
                showlegend=True
            )
            
            return dcc.Graph(
                figure=fig, 
                config={'displayModeBar': True, 'displaylogo': False},
                style={'height': '400px'}
            )
            
        except Exception as e:
            print(f"Error in create_simple_signal_chart: {e}")
            return html.Div([
                html.P(f"Unable to create chart for {signal_col}", className="text-red-500"),
                html.P(f"Error: {str(e)}", className="text-xs text-gray-500")
            ], className="p-4 bg-red-50 border border-red-200 rounded")





    # indicators summary raw data
    def create_all_indicators_summary(df, ticker):
        """Create summary for all indicators with comprehensive statistics"""
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        summary_data = []
        individual_indicators = []
        combination_indicators = []
        
        for col in signal_cols:
            if col not in df.columns:
                continue
                
            buy_count = (df[col] == 'Buy').sum()
            sell_count = (df[col] == 'Sell').sum()
            hold_count = (df[col] == 'Hold').sum()
            
            # Calculate signal pairs and profit
            signal_pairs, total_profit, win_rate = calculate_signal_pairs_profit(df, col)
            
            # Classify indicators
            is_volume = 'Volume' in col
            is_combination = ('Combined_Signal' in col and col != 'Combined_Signal') or col == 'Combined_Signal'
            is_individual = not is_volume and not is_combination
            
            indicator_data = {
                'Indicator': col.replace('_Signal', '').replace('_Combined_Signal', ' Combined'),
                'Buy Signals': buy_count,
                'Sell Signals': sell_count,
                'Hold Signals': hold_count,
                'Signal Pairs': len(signal_pairs),
                'Total Profit %': total_profit,
                'Win Rate': win_rate,
                'Type': 'Individual' if is_individual else ('Combination' if is_combination else 'Volume')
            }
            
            summary_data.append(indicator_data)
            
            # Categorize for statistics (exclude volume from profit calculations)
            if is_individual and not is_volume:
                individual_indicators.append(indicator_data)
            elif is_combination:
                combination_indicators.append(indicator_data)
        
        # Calculate comprehensive statistics
        def calculate_stats(indicators_list, category_name):
            if not indicators_list:
                return {
                    'count': 0,
                    'avg_profit': 0,
                    'avg_win_rate': 0,
                    'best_profit': 0,
                    'worst_profit': 0,
                    'best_indicator': 'N/A',
                    'total_trades': 0
                }
            
            profits = [ind['Total Profit %'] for ind in indicators_list]
            win_rates = [ind['Win Rate'] for ind in indicators_list]
            trades = [ind['Signal Pairs'] for ind in indicators_list]
            
            best_idx = profits.index(max(profits)) if profits else 0
            worst_idx = profits.index(min(profits)) if profits else 0
            
            return {
                'count': len(indicators_list),
                'avg_profit': sum(profits) / len(profits) if profits else 0,
                'avg_win_rate': sum(win_rates) / len(win_rates) if win_rates else 0,
                'best_profit': max(profits) if profits else 0,
                'worst_profit': min(profits) if profits else 0,
                'best_indicator': indicators_list[best_idx]['Indicator'] if indicators_list else 'N/A',
                'worst_indicator': indicators_list[worst_idx]['Indicator'] if indicators_list else 'N/A',
                'total_trades': sum(trades) if trades else 0
            }
        
        # Calculate statistics for each category
        individual_stats = calculate_stats(individual_indicators, 'Individual')
        combination_stats = calculate_stats(combination_indicators, 'Combination')
        
        # Overall statistics (excluding volume)
        all_non_volume = individual_indicators + combination_indicators
        overall_stats = calculate_stats(all_non_volume, 'Overall')
        
        return html.Div([
            html.H4("ðŸ“Š Summary All Indicators", className="text-lg font-semibold mb-3"),
            dash_table.DataTable(
                data=summary_data,
                columns=[
                    {'name': 'Indicator', 'id': 'Indicator'},
                    {'name': 'Buy', 'id': 'Buy Signals'},
                    {'name': 'Sell', 'id': 'Sell Signals'},
                    {'name': 'Hold', 'id': 'Hold Signals'},
                    {'name': 'Pairs', 'id': 'Signal Pairs'},
                    {'name': 'Total Profit %', 'id': 'Total Profit %'},
                    {'name': 'Win Rate', 'id': 'Win Rate'},
                    {'name': 'Type', 'id': 'Type'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'center', 'padding': '10px'},
                style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Total Profit %} contains "-"'},
                        'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                        'color': 'red'
                    },
                    {
                        'if': {'filter_query': '{Total Profit %} > "0"'},
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)', 
                        'color': 'green'
                    },
                    {
                        'if': {'filter_query': '{Type} = "Individual"'},
                        'backgroundColor': 'rgba(59, 130, 246, 0.1)'
                    },
                    {
                        'if': {'filter_query': '{Type} = "Combination"'},
                        'backgroundColor': 'rgba(147, 51, 234, 0.1)'
                    },
                    {
                        'if': {'filter_query': '{Type} = "Volume"'},
                        'backgroundColor': 'rgba(249, 115, 22, 0.1)'
                    }
                ]
            ),
            
            # Comprehensive Summary Statistics Section
            html.Div([
                html.H4("ðŸ“ˆ Comprehensive Performance Statistics", className="text-xl font-bold mb-4 text-blue-700"),
                html.P(f"Analisis lengkap performa technical indicators untuk {ticker} berdasarkan kategori dan keseluruhan.", 
                    className="text-gray-600 mb-4"),
                
                # Individual Indicators Statistics
                html.Div([
                    html.H5("ðŸ’¡ Individual Technical Indicators", className="text-lg font-semibold mb-3 text-green-600"),
                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Total Indikator", className="block text-sm text-gray-500"),
                                html.Span(f"{individual_stats['count']}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Rata-rata Profit", className="block text-sm text-gray-500"),
                                html.Span(f"{individual_stats['avg_profit']:.2f}%", 
                                        className=f"block text-xl font-bold {'text-green-600' if individual_stats['avg_profit'] >= 0 else 'text-red-600'}")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Rata-rata Win Rate", className="block text-sm text-gray-500"),
                                html.Span(f"{individual_stats['avg_win_rate']:.1f}%", className="block text-xl font-bold text-purple-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Best Performer", className="block text-sm text-gray-500"),
                                html.Span(f"{individual_stats['best_profit']:.2f}%", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Total Trades", className="block text-sm text-gray-500"),
                                html.Span(f"{individual_stats['total_trades']}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                    ], className="flex -mx-2 mb-4"),
                    html.Div([
                        html.P([
                            "ðŸŽ¯ Indikator individual terbaik: ",
                            html.Strong(individual_stats['best_indicator']),
                            f" dengan profit {individual_stats['best_profit']:.2f}%"
                        ], className="mb-2"),
                        html.P([
                            "ðŸ“‰ Indikator individual terlemah: ",
                            html.Strong(individual_stats['worst_indicator']),
                            f" dengan profit {individual_stats['worst_profit']:.2f}%"
                        ], className="mb-2"),
                        html.P([
                            "ðŸ“Š Range performa: ",
                            html.Strong(f"{individual_stats['worst_profit']:.2f}% hingga {individual_stats['best_profit']:.2f}%"),
                            f" (spread: {individual_stats['best_profit'] - individual_stats['worst_profit']:.2f}%)"
                        ])
                    ], className="p-3 bg-green-50 rounded-lg border border-green-200")
                ], className="mb-6"),
                
                # Combination Indicators Statistics
                html.Div([
                    html.H5("ðŸ”— Combination Technical Indicators", className="text-lg font-semibold mb-3 text-purple-600"),
                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Total Kombinasi", className="block text-sm text-gray-500"),
                                html.Span(f"{combination_stats['count']}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Rata-rata Profit", className="block text-sm text-gray-500"),
                                html.Span(f"{combination_stats['avg_profit']:.2f}%", 
                                        className=f"block text-xl font-bold {'text-green-600' if combination_stats['avg_profit'] >= 0 else 'text-red-600'}")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Rata-rata Win Rate", className="block text-sm text-gray-500"),
                                html.Span(f"{combination_stats['avg_win_rate']:.1f}%", className="block text-xl font-bold text-purple-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Best Combination", className="block text-sm text-gray-500"),
                                html.Span(f"{combination_stats['best_profit']:.2f}%", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Total Trades", className="block text-sm text-gray-500"),
                                html.Span(f"{combination_stats['total_trades']}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                    ], className="flex -mx-2 mb-4"),
                    html.Div([
                        html.P([
                            "ðŸ¥‡ Kombinasi terbaik: ",
                            html.Strong(combination_stats['best_indicator']),
                            f" dengan profit {combination_stats['best_profit']:.2f}%"
                        ], className="mb-2"),
                        html.P([
                            "ðŸ“ˆ Kombinasi terlemah: ",
                            html.Strong(combination_stats['worst_indicator']),
                            f" dengan profit {combination_stats['worst_profit']:.2f}%"
                        ], className="mb-2"),
                        html.P([
                            "ðŸ“Š Range performa kombinasi: ",
                            html.Strong(f"{combination_stats['worst_profit']:.2f}% hingga {combination_stats['best_profit']:.2f}%"),
                            f" (spread: {combination_stats['best_profit'] - combination_stats['worst_profit']:.2f}%)"
                        ])
                    ], className="p-3 bg-purple-50 rounded-lg border border-purple-200")
                ], className="mb-6"),
                
                # Overall Comprehensive Statistics
                html.Div([
                    html.H5("ðŸ† Overall Performance Summary", className="text-lg font-semibold mb-3 text-orange-600"),
                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Total Indicators", className="block text-sm text-gray-500"),
                                html.Span(f"{overall_stats['count']}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Overall Avg Profit", className="block text-sm text-gray-500"),
                                html.Span(f"{overall_stats['avg_profit']:.2f}%", 
                                        className=f"block text-xl font-bold {'text-green-600' if overall_stats['avg_profit'] >= 0 else 'text-red-600'}")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Overall Avg Win Rate", className="block text-sm text-gray-500"),
                                html.Span(f"{overall_stats['avg_win_rate']:.1f}%", className="block text-xl font-bold text-purple-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Best Overall", className="block text-sm text-gray-500"),
                                html.Span(f"{overall_stats['best_profit']:.2f}%", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Total All Trades", className="block text-sm text-gray-500"),
                                html.Span(f"{overall_stats['total_trades']}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm text-center")
                        ], className="w-1/5 px-2"),
                    ], className="flex -mx-2 mb-4"),
                    
                    # Detailed Analysis
                    html.Div([
                        html.H6("ðŸ“‹ Detailed Performance Analysis", className="text-md font-semibold mb-3"),
                        html.P([
                            "ðŸŽ¯ ",
                            html.Strong("Strategy Effectiveness: "),
                            f"Dari total {overall_stats['count']} strategi (individual + kombinasi), "
                            f"rata-rata menghasilkan profit sebesar {overall_stats['avg_profit']:.2f}% "
                            f"dengan win rate {overall_stats['avg_win_rate']:.1f}%."
                        ], className="mb-3"),
                        html.P([
                            "ðŸ“Š ",
                            html.Strong("Individual vs Combination: "),
                            f"Indikator individual rata-rata: {individual_stats['avg_profit']:.2f}%, "
                            f"Kombinasi rata-rata: {combination_stats['avg_profit']:.2f}%. ",
                            html.Strong("Kombinasi lebih unggul" if combination_stats['avg_profit'] > individual_stats['avg_profit'] 
                                    else "Individual lebih unggul" if individual_stats['avg_profit'] > combination_stats['avg_profit']
                                    else "Performa setara"),
                            f" dengan selisih {abs(combination_stats['avg_profit'] - individual_stats['avg_profit']):.2f}%."
                        ], className="mb-3"),
                        html.P([
                            "ðŸ† ",
                            html.Strong("Best Overall Strategy: "),
                            f"{overall_stats['best_indicator']} adalah strategi terbaik dengan profit {overall_stats['best_profit']:.2f}%, "
                            f"mengungguli rata-rata sebesar {overall_stats['best_profit'] - overall_stats['avg_profit']:.2f}%."
                        ], className="mb-3"),
                        html.P([
                            "ðŸ“ˆ ",
                            html.Strong("Trading Activity: "),
                            f"Total {overall_stats['total_trades']} trades dilakukan across all strategies, "
                            f"dengan rata-rata {overall_stats['total_trades']/max(1, overall_stats['count']):.1f} trades per strategi."
                        ], className="mb-3"),
                        html.P([
                            "ðŸ’¡ ",
                            html.Strong("Recommendation: "),
                            f"Gunakan strategi terbaik ({overall_stats['best_indicator']}) untuk hasil optimal, "
                            f"atau pertimbangkan diversifikasi dengan top 3 performers untuk mengurangi risiko."
                        ], className="mb-3"),
                    ], className="p-4 bg-orange-50 rounded-lg border border-orange-200")
                ], className="mb-6"),
                
                # Volume Indicator Note
                html.Div([
                    html.H6("â„¹ï¸ Important Notes", className="text-md font-semibold mb-2"),
                    html.Div([
                        html.P("ðŸ“ Volume Signal tidak dihitung dalam statistik profit karena berfungsi sebagai konfirmasi (High Volume/Low Volume) bukan sinyal trading langsung.", className="mb-2"),
                        html.P("ðŸ”„ Kombinasi menggunakan sistem voting mayoritas dengan konfirmasi volume dan candlestick trend.", className="mb-2"),
                        html.P("ðŸ“Š Profit dihitung berdasarkan signal pairs (Buy â†’ Sell) dengan asumsi modal tetap per trade.", className="mb-2")
                    ], className="text-sm text-gray-600")
                ], className="p-3 bg-gray-50 rounded-lg border border-gray-200")
                
            ], className="mt-6 p-4 bg-white rounded shadow-sm")
        ], className="p-4 bg-white rounded shadow-sm mb-4")




    # def create_all_indicators_summary(df, ticker):
    #     """Create summary for all indicators"""
    #     signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
    #     summary_data = []
    #     for col in signal_cols:
    #         if col in df.columns:
    #             buy_count = (df[col] == 'Buy').sum()
    #             sell_count = (df[col] == 'Sell').sum()
    #             hold_count = (df[col] == 'Hold').sum()
                
    #             # Calculate signal pairs and profit
    #             signal_pairs, total_profit, win_rate = calculate_signal_pairs_profit(df, col)
                
    #             summary_data.append({
    #                 'Indicator': col.replace('_Signal', ''),
    #                 'Buy Signals': buy_count,
    #                 'Sell Signals': sell_count,
    #                 'Hold Signals': hold_count,
    #                 'Signal Pairs': len(signal_pairs),
    #                 'Total Profit %': f"{total_profit:.2f}%",
    #                 'Win Rate': f"{win_rate:.1f}%"
    #             })
        
    #     return html.Div([
    #         html.H4("ðŸ“Š Summary All Indicators", className="text-lg font-semibold mb-3"),
    #         dash_table.DataTable(
    #             data=summary_data,
    #             columns=[
    #                 {'name': 'Indicator', 'id': 'Indicator'},
    #                 {'name': 'Buy', 'id': 'Buy Signals'},
    #                 {'name': 'Sell', 'id': 'Sell Signals'},
    #                 {'name': 'Hold', 'id': 'Hold Signals'},
    #                 {'name': 'Pairs', 'id': 'Signal Pairs'},
    #                 {'name': 'Total Profit %', 'id': 'Total Profit %'},
    #                 {'name': 'Win Rate', 'id': 'Win Rate'}
    #             ],
    #             style_table={'overflowX': 'auto'},
    #             style_cell={'textAlign': 'center', 'padding': '10px'},
    #             style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
    #             style_data_conditional=[
    #                 {
    #                     'if': {'filter_query': '{Total Profit %} contains "-"'},
    #                     'backgroundColor': 'rgba(255, 0, 0, 0.1)',
    #                     'color': 'red'
    #                 },
    #                 {
    #                     'if': {'filter_query': '{Total Profit %} > "0"'},
    #                     'backgroundColor': 'rgba(0, 255, 0, 0.1)', 
    #                     'color': 'green'
    #                 }
    #             ]
    #         )
    #     ], className="p-4 bg-white rounded shadow-sm mb-4")


    def create_single_indicator_summary(df, ticker, indicator):
        """Create summary for single indicator with fixed holding period calculation"""
        if indicator not in df.columns:
            return html.Div("Indicator not found", className="text-red-500")
        
        buy_count = (df[indicator] == 'Buy').sum()
        sell_count = (df[indicator] == 'Sell').sum()
        hold_count = (df[indicator] == 'Hold').sum()
        
        # Calculate detailed analysis
        signal_pairs, total_profit, win_rate = calculate_signal_pairs_profit(df, indicator)
        avg_holding_period = calculate_avg_holding_period(signal_pairs)
        
        return html.Div([
            html.H4(f"ðŸ“Š {indicator.replace('_Signal', '')} Analysis Summary", className="text-lg font-semibold mb-3"),
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Buy Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{buy_count}", className="block text-2xl font-bold text-green-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Sell Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{sell_count}", className="block text-2xl font-bold text-red-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Signal Pairs", className="block text-sm text-gray-500"),
                        html.Span(f"{len(signal_pairs)}", className="block text-2xl font-bold text-blue-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Total Profit", className="block text-sm text-gray-500"),
                        html.Span(f"{total_profit:.2f}%", 
                                className=f"block text-2xl font-bold {'text-green-600' if total_profit >= 0 else 'text-red-600'}")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Win Rate", className="block text-sm text-gray-500"),
                        html.Span(f"{win_rate:.1f}%", className="block text-2xl font-bold text-purple-600")
                    ], className="p-4 border rounded bg-white shadow-sm text-center")
                ], className="w-1/5 px-2")
            ], className="flex -mx-2 mb-4"),
            
            # Additional metrics
            html.Div([
                html.P(f"ðŸ“… Average Holding Period: {avg_holding_period:.1f} days", className="mb-2"),
                html.P(f"ðŸ“ˆ Best Trade: {max([p['profit_pct'] for p in signal_pairs]):.2f}%" if signal_pairs else "No trades", className="mb-2"),
                html.P(f"ðŸ“‰ Worst Trade: {min([p['profit_pct'] for p in signal_pairs]):.2f}%" if signal_pairs else "No trades", className="mb-2")
            ], className="p-3 bg-blue-50 rounded-lg border border-blue-200")
        ], className="p-4 bg-white rounded shadow-sm mb-4")



    def calculate_avg_holding_period(signal_pairs):
        """Calculate average holding period from signal pairs data with improved error handling"""
        if not signal_pairs:
            return 0
        
        try:
            holding_periods = []
            for pair in signal_pairs:
                # Gunakan kedua nama field untuk compatibility
                holding_period = pair.get('holding_period', pair.get('holding_days', 0))
                
                # Jika masih tidak ada, hitung dari buy_date dan sell_date
                if holding_period == 0 and 'buy_date' in pair and 'sell_date' in pair:
                    if pd.notna(pair['buy_date']) and pd.notna(pair['sell_date']):
                        try:
                            buy_date = pd.to_datetime(pair['buy_date'])
                            sell_date = pd.to_datetime(pair['sell_date'])
                            holding_period = (sell_date - buy_date).days
                        except:
                            holding_period = 0
                
                if holding_period > 0:
                    holding_periods.append(holding_period)
            
            return sum(holding_periods) / len(holding_periods) if holding_periods else 0
        except Exception as e:
            print(f"Error calculating average holding period: {e}")
            return 0
    


    def create_enhanced_technical_chart_with_signals(indicator_type, filtered_df, **kwargs):
        """Create enhanced technical chart with signals - IMPROVED ERROR HANDLING"""
        
        try:
            print(f"Creating enhanced chart for indicator: {indicator_type}")
            
            # Basic validation
            if filtered_df.empty:
                print(f"DataFrame is empty for {indicator_type}")
                return None
            
            # Pastikan datetime column ada dan valid
            if 'Datetime' not in filtered_df.columns:
                print(f"Datetime column not found for {indicator_type}")
                return None
            
            # Pastikan Close price ada
            if 'Close' not in filtered_df.columns:
                print(f"Close price column not found for {indicator_type}")
                return None
                
            # Pastikan datetime dalam format yang benar
            try:
                filtered_df = filtered_df.copy()
                filtered_df['Datetime'] = pd.to_datetime(filtered_df['Datetime'], errors='coerce')
                filtered_df = filtered_df.dropna(subset=['Datetime'])
                
                if filtered_df.empty:
                    print(f"No valid datetime data for {indicator_type}")
                    return None
            except Exception as dt_error:
                print(f"Datetime conversion error for {indicator_type}: {dt_error}")
                return None
            
            # Create figure based on indicator type
            fig = None
            
            # Bollinger Bands Chart
            if indicator_type == 'Bollinger_Signal' and all(col in filtered_df.columns for col in ['Upper Band', 'Lower Band', 'Middle Band']):
                fig = create_bollinger_chart(filtered_df, indicator_type)
            
            # Moving Average Chart
            elif indicator_type == 'MA_Signal' and all(col in filtered_df.columns for col in ['short_MA', 'long_MA']):
                fig = create_ma_chart(filtered_df, indicator_type)
            
            # RSI Chart
            elif indicator_type == 'RSI_Signal' and 'RSI' in filtered_df.columns:
                fig = create_rsi_chart(filtered_df, indicator_type, **kwargs)
            
            # MACD Chart
            elif indicator_type == 'MACD_Signal' and all(col in filtered_df.columns for col in ['MACD', 'Signal_Line', 'MACD_Hist']):
                fig = create_macd_chart(filtered_df, indicator_type)
            
            # ADX Chart
            elif indicator_type == 'ADX_Signal' and all(col in filtered_df.columns for col in ['ADX', '+DI', '-DI']):
                fig = create_adx_chart(filtered_df, indicator_type)
            
            # Volume Analysis Chart
            elif indicator_type == 'Volume_Signal' and all(col in filtered_df.columns for col in ['VMA', 'Volume']):
                fig = create_volume_chart(filtered_df, indicator_type)
            
            # Fibonacci Chart
            elif indicator_type == 'Fibonacci_Signal':
                fig = create_fibonacci_chart(filtered_df, indicator_type)
            
            # Generic Signal Chart (fallback)
            else:
                print(f"Creating generic signal chart for {indicator_type}")
                fig = create_generic_signal_chart(filtered_df, indicator_type)
            
            if fig is not None:
                return dcc.Graph(figure=fig, config={'displayModeBar': True})
            else:
                print(f"No figure created for {indicator_type}")
                return None
                
        except Exception as e:
            print(f"Error in create_enhanced_technical_chart_with_signals for {indicator_type}: {e}")
            traceback.print_exc()
            return None


    def create_generic_signal_chart(filtered_df, indicator_type):
        """Create a generic signal chart for any indicator - ALWAYS WORKS"""
        try:
            fig = go.Figure()
            
            # Add Close price line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'],
                y=filtered_df['Close'],
                mode='lines',
                name='Close Price',
                line=dict(color='blue', width=2)
            ))
            
            # Add signals if the indicator column exists
            if indicator_type in filtered_df.columns:
                # Buy signals
                buy_signals = filtered_df[filtered_df[indicator_type] == 'Buy']
                if not buy_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals['Close'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='green'),
                        hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
                
                # Sell signals
                sell_signals = filtered_df[filtered_df[indicator_type] == 'Sell']
                if not sell_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals['Close'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='red'),
                        hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
            
            fig.update_layout(
                title=f"{indicator_type.replace('_Signal', '')} Analysis with Signals",
                xaxis_title="Date",
                yaxis_title="Price",
                height=500,
                template="plotly_white",
                hovermode='x unified'
            )
            
            return fig
            
        except Exception as e:
            print(f"Error creating generic chart: {e}")
            return None







    def create_bollinger_chart(filtered_df, indicator_type):
        """Create Bollinger Bands chart"""
        try:
            fig = go.Figure()
            
            # Add price line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['Close'], 
                mode='lines', 
                name='Close',
                line=dict(color='black', width=2)
            ))
            
            # Add Bollinger Bands
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['Upper Band'], 
                mode='lines', 
                name='Upper Band',
                line=dict(color='red', dash='dash')
            ))
            
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['Middle Band'], 
                mode='lines', 
                name='Middle Band',
                line=dict(color='blue', dash='dot')
            ))
            
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['Lower Band'], 
                mode='lines', 
                name='Lower Band',
                line=dict(color='green', dash='dash')
            ))
            
            # Add signals
            add_buy_sell_signals(fig, filtered_df, indicator_type)
            
            fig.update_layout(
                title="Bollinger Bands with Signals", 
                xaxis_title="Date", 
                yaxis_title="Price",
                height=500,
                template="plotly_white"
            )
            
            return fig
        except Exception as e:
            print(f"Error creating Bollinger chart: {e}")
            return None

    def create_ma_chart(filtered_df, indicator_type):
        """Create Moving Average chart"""
        try:
            fig = go.Figure()
            
            # Add Close price
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['Close'], 
                mode='lines', 
                name='Close',
                line=dict(color='blue', width=2)
            ))
            
            # Add Moving Averages
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['short_MA'], 
                mode='lines', 
                name='Short MA', 
                line=dict(color='orange', width=2)
            ))
            
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['long_MA'], 
                mode='lines', 
                name='Long MA', 
                line=dict(color='purple', width=2)
            ))
            
            # Add signals
            add_buy_sell_signals(fig, filtered_df, indicator_type)
            
            fig.update_layout(
                title="Moving Average with Signals", 
                xaxis_title="Date", 
                yaxis_title="Price",
                height=500,
                template="plotly_white"
            )
            
            return fig
        except Exception as e:
            print(f"Error creating MA chart: {e}")
            return None

    def create_rsi_chart(filtered_df, indicator_type, **kwargs):
        """Create RSI chart"""
        try:
            rsi_ob = kwargs.get('rsi_ob', 70)
            rsi_os = kwargs.get('rsi_os', 30)
            
            fig = go.Figure()
            
            # Add RSI line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['RSI'], 
                mode='lines', 
                name='RSI',
                line=dict(color='purple', width=2)
            ))
            
            # Add overbought and oversold lines
            fig.add_hline(y=rsi_ob, line_dash="dash", line_color="red", 
                        annotation_text=f"Overbought ({rsi_ob})")
            fig.add_hline(y=rsi_os, line_dash="dash", line_color="green", 
                        annotation_text=f"Oversold ({rsi_os})")
            
            # Add Buy/Sell signals on RSI values
            if indicator_type in filtered_df.columns:
                buy_signals = filtered_df[filtered_df[indicator_type] == 'Buy']
                sell_signals = filtered_df[filtered_df[indicator_type] == 'Sell']
                
                if not buy_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals['RSI'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='darkgreen')
                    ))
                
                if not sell_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals['RSI'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='darkred')
                    ))
            
            fig.update_layout(
                title="RSI with Signals",
                xaxis_title="Date",
                yaxis_title="RSI",
                yaxis=dict(range=[0, 100]),
                height=500,
                template="plotly_white"
            )
            
            return fig
        except Exception as e:
            print(f"Error creating RSI chart: {e}")
            return None

    def create_macd_chart(filtered_df, indicator_type):
        """Create MACD chart"""
        try:
            fig = go.Figure()

            # Add MACD histogram
            fig.add_trace(go.Bar(
                x=filtered_df['Datetime'],
                y=filtered_df['MACD_Hist'],
                name='MACD Histogram',
                marker=dict(
                    color=['rgba(0, 255, 0, 0.3)' if x > 0 else 'rgba(255, 0, 0, 0.3)' for x in filtered_df['MACD_Hist']]
                )
            ))

            # Add MACD line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['MACD'], 
                mode='lines', 
                name='MACD',
                line=dict(color='#FF9900', width=2)
            ))

            # Add Signal Line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['Signal_Line'], 
                mode='lines', 
                name='Signal Line',
                line=dict(color='#0066FF', width=2)
            ))

            # Add zero line
            fig.add_hline(y=0, line_dash="dash", line_color="black")
            
            # Add signals on MACD values
            add_buy_sell_signals_on_indicator(fig, filtered_df, indicator_type, 'MACD')

            fig.update_layout(
                title="MACD with Signals",
                xaxis_title="Date",
                yaxis_title="Value",
                height=600,
                template="plotly_white"
            )

            return fig
        except Exception as e:
            print(f"Error creating MACD chart: {e}")
            return None

    def create_fibonacci_chart(filtered_df, indicator_type):
        """Create Fibonacci chart"""
        try:
            fig = go.Figure()
            
            # Add price line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'],
                y=filtered_df['Close'],
                mode='lines',
                name='Close',
                line=dict(color='black', width=2)
            ))

            # Add fibonacci levels if available
            try:
                if 'fib_levels' in filtered_df.columns:
                    levels_matrix = filtered_df.apply(
                        lambda row: row.get('fib_levels', [None]*5) if 'fib_levels' in row and row['fib_levels'] is not None else [None]*5,
                        axis=1, result_type='expand'
                    )
                    
                    retracement_levels = [0.236, 0.382, 0.5, 0.618, 0.786]
                    colors = ['#FFB347', '#FFD700', '#90EE90', '#87CEEB', '#FF69B4']

                    for i, level in enumerate(retracement_levels):
                        if i < levels_matrix.shape[1]:
                            valid_data = levels_matrix[i].dropna()
                            if not valid_data.empty:
                                fig.add_trace(go.Scatter(
                                    x=filtered_df.loc[valid_data.index, 'Datetime'],
                                    y=valid_data,
                                    mode='lines',
                                    name=f'Fibo {level*100:.1f}%',
                                    line=dict(color=colors[i], dash='dash')
                                ))
            except Exception as fib_error:
                print(f"Error adding Fibonacci levels: {fib_error}")

            # Add signals
            add_buy_sell_signals(fig, filtered_df, indicator_type)

            fig.update_layout(
                title="Fibonacci Retracement with Signals",
                xaxis_title="Date",
                yaxis_title="Price",
                height=500,
                template="plotly_white"
            )

            return fig
        except Exception as e:
            print(f"Error creating Fibonacci chart: {e}")
            return None
    

    def create_volume_chart(filtered_df, indicator_type):
        """Create Volume Analysis chart"""
        try:
            fig = go.Figure()
            
            # Add Volume bars
            fig.add_trace(go.Bar(
                x=filtered_df['Datetime'],
                y=filtered_df['Volume'],
                name='Volume',
                marker_color='lightblue',
                opacity=0.7
            ))
            
            # Add Volume Moving Average if available
            if 'VMA' in filtered_df.columns:
                fig.add_trace(go.Scatter(
                    x=filtered_df['Datetime'], 
                    y=filtered_df['VMA'], 
                    mode='lines', 
                    name='Volume MA',
                    line=dict(color='orange', width=2)
                ))
            
            # Add signals on volume values
            add_buy_sell_signals_on_indicator(fig, filtered_df, indicator_type, 'Volume')
            
            fig.update_layout(
                title="Volume Analysis with Signals",
                xaxis_title="Date",
                yaxis_title="Volume",
                height=500,
                template="plotly_white"
            )
            
            return fig
        except Exception as e:
            print(f"Error creating Volume chart: {e}")
            return None

    def create_adx_chart(filtered_df, indicator_type):
        """Create ADX chart"""
        try:
            fig = go.Figure()
            
            # Add ADX line
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['ADX'], 
                mode='lines', 
                name='ADX',
                line=dict(color='purple', width=2)
            ))
            
            # Add +DI and -DI
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['+DI'], 
                mode='lines', 
                name='+DI',
                line=dict(color='green', width=1)
            ))
            
            fig.add_trace(go.Scatter(
                x=filtered_df['Datetime'], 
                y=filtered_df['-DI'], 
                mode='lines', 
                name='-DI',
                line=dict(color='red', width=1)
            ))
            
            # Add threshold lines
            fig.add_hline(y=25, line_dash="dash", line_color="gray", 
                        annotation_text="Strong Trend (25)")
            fig.add_hline(y=50, line_dash="dash", line_color="black", 
                        annotation_text="Very Strong Trend (50)")
            
            # Add signals on ADX values
            add_buy_sell_signals_on_indicator(fig, filtered_df, indicator_type, 'ADX')
            
            fig.update_layout(
                title="ADX with Directional Movement",
                xaxis_title="Date",
                yaxis_title="Value",
                height=500,
                template="plotly_white"
            )
            
            return fig
        except Exception as e:
            print(f"Error creating ADX chart: {e}")
            return None
    

    def add_buy_sell_signals(fig, filtered_df, indicator_type):
        """Helper function to add buy/sell signals to any chart"""
        try:
            if indicator_type in filtered_df.columns:
                buy_signals = filtered_df[filtered_df[indicator_type] == 'Buy']
                sell_signals = filtered_df[filtered_df[indicator_type] == 'Sell']
                
                if not buy_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals['Close'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='green'),
                        hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
                
                if not sell_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals['Close'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='red'),
                        hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
        except Exception as e:
            print(f"Error adding signals: {e}")

    def add_buy_sell_signals_on_indicator(fig, filtered_df, indicator_type, indicator_column):
        """Helper function to add buy/sell signals on indicator values instead of price"""
        try:
            if indicator_type in filtered_df.columns and indicator_column in filtered_df.columns:
                buy_signals = filtered_df[filtered_df[indicator_type] == 'Buy']
                sell_signals = filtered_df[filtered_df[indicator_type] == 'Sell']
                
                if not buy_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals[indicator_column],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='green')
                    ))
                
                if not sell_signals.empty:
                    fig.add_trace(go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals[indicator_column],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='red')
                    ))
        except Exception as e:
            print(f"Error adding signals on indicator: {e}")












    def create_all_indicators_chart(df, ticker):
        """Create chart showing all indicators using enhanced chart generators - FIXED VERSION"""
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        if not signal_cols:
            return html.Div("No signal data available", className="text-gray-500")
        
        charts = []
        
        for signal_col in signal_cols:
            try:
                # Debug print
                print(f"Creating chart for {signal_col}")
                
                # Gunakan enhanced chart generator yang sudah diperbaiki
                chart = create_enhanced_technical_chart_with_signals(signal_col, df)
                
                if chart is None:
                    # Fallback jika chart generator gagal
                    chart = create_fallback_signal_chart(df, signal_col, ticker)
                
                if chart:
                    charts.append(html.Div([
                        html.H5(f"ðŸ“ˆ {signal_col.replace('_Signal', '')} Analysis", className="text-md font-semibold mb-2"),
                        chart
                    ], className="mb-4"))
            except Exception as e:
                print(f"Error creating chart for {signal_col}: {e}")
                # Tambahkan fallback chart
                fallback_chart = create_fallback_signal_chart(df, signal_col, ticker)
                charts.append(html.Div([
                    html.H5(f"ðŸ“ˆ {signal_col.replace('_Signal', '')} Analysis", className="text-md font-semibold mb-2"),
                    fallback_chart
                ], className="mb-4"))
        
        return html.Div(charts) if charts else html.Div("No charts available", className="text-gray-500")



    

    def create_technical_chart(indicator_type, filtered_df, **kwargs):
        """Factory function untuk membuat chart berdasarkan tipe indikator dengan signals"""
        try:
            return create_enhanced_technical_chart_with_signals(indicator_type, filtered_df, **kwargs)
        except Exception as e:
            print(f"Error creating chart for {indicator_type}: {e}")
            return html.Div(f"Error creating chart: {str(e)}", className="text-red-500")



    def create_single_indicator_chart(df, ticker, indicator):
        """Create detailed chart for single indicator using enhanced chart generators - FIXED VERSION"""
        try:
            # Debug: Print untuk memastikan data tersedia
            print(f"Creating chart for {ticker} - {indicator}")
            print(f"DataFrame shape: {df.shape}")
            print(f"Available columns: {df.columns.tolist()}")
            
            # Pastikan data tidak kosong
            if df.empty:
                return html.Div(f"No data available for {indicator}", className="text-gray-500")
            
            # Panggil function chart generator yang sudah ada
            chart = create_enhanced_technical_chart_with_signals(indicator, df)
            
            if chart is None:
                # Jika chart generator gagal, buat fallback chart
                print(f"Enhanced chart failed for {indicator}, creating fallback chart")
                return create_fallback_signal_chart(df, indicator, ticker)
            
            return chart
            
        except Exception as e:
            print(f"Error creating chart for {indicator}: {e}")
            traceback.print_exc()
            return create_fallback_signal_chart(df, indicator, ticker)


    def add_signals_to_existing_chart(chart_component, df, signal_col, ticker):
        """Add buy/sell signals to an existing chart component"""
        try:
            # Extract the figure from the chart component
            if hasattr(chart_component, 'figure'):
                fig = chart_component.figure
            else:
                # If it's a dcc.Graph component, get the figure
                fig = chart_component.children.figure if hasattr(chart_component.children, 'figure') else None
                
            if not fig:
                return chart_component
            
            # Add buy signals
            buy_mask = df[signal_col] == 'Buy'
            if buy_mask.any():
                fig.add_trace(go.Scatter(
                    x=df.loc[buy_mask, 'Datetime'],
                    y=df.loc[buy_mask, 'Close'],
                    mode='markers',
                    name=f'Buy Signal',
                    marker=dict(symbol='triangle-up', size=12, color='green'),
                    hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                ))
            
            # Add sell signals
            sell_mask = df[signal_col] == 'Sell'
            if sell_mask.any():
                fig.add_trace(go.Scatter(
                    x=df.loc[sell_mask, 'Datetime'],
                    y=df.loc[sell_mask, 'Close'],
                    mode='markers',
                    name=f'Sell Signal',
                    marker=dict(symbol='triangle-down', size=12, color='red'),
                    hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                ))
            
            # Update title to include ticker and signal info
            current_title = fig.layout.title.text if fig.layout.title else ""
            fig.update_layout(
                title=f"{current_title} - {ticker}",
                height=500
            )
            
            return dcc.Graph(figure=fig, config={'displayModeBar': True})
            
        except Exception as e:
            print(f"Error adding signals to chart: {e}")
            return chart_component

    def create_fallback_signal_chart(df, signal_col, ticker):
        """Create a fallback chart when other methods fail - ENHANCED VERSION"""
        try:
            print(f"Creating fallback chart for {signal_col}")
            
            # Pastikan datetime column ada
            if 'Datetime' not in df.columns:
                return html.Div(f"No datetime data for {signal_col}", className="text-red-500")
            
            # Pastikan Close price ada
            if 'Close' not in df.columns:
                return html.Div(f"No price data for {signal_col}", className="text-red-500")
            
            # Convert datetime jika perlu
            df_copy = df.copy()
            try:
                df_copy['Datetime'] = pd.to_datetime(df_copy['Datetime'], errors='coerce')
                df_copy = df_copy.dropna(subset=['Datetime'])
            except Exception as dt_err:
                print(f"Datetime conversion error in fallback: {dt_err}")
            
            if df_copy.empty:
                return html.Div(f"No valid data for {signal_col}", className="text-red-500")
            
            fig = go.Figure()
            
            # Add price line
            fig.add_trace(go.Scatter(
                x=df_copy['Datetime'],
                y=df_copy['Close'],
                mode='lines',
                name='Close Price',
                line=dict(color='blue', width=2)
            ))
            
            # Add signals jika column tersedia
            if signal_col in df_copy.columns:
                # Buy signals
                buy_mask = df_copy[signal_col] == 'Buy'
                if buy_mask.any():
                    buy_data = df_copy.loc[buy_mask]
                    fig.add_trace(go.Scatter(
                        x=buy_data['Datetime'],
                        y=buy_data['Close'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='green'),
                        hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
                
                # Sell signals
                sell_mask = df_copy[signal_col] == 'Sell'
                if sell_mask.any():
                    sell_data = df_copy.loc[sell_mask]
                    fig.add_trace(go.Scatter(
                        x=sell_data['Datetime'],
                        y=sell_data['Close'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='red'),
                        hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
                    ))
            
            fig.update_layout(
                title=f"{signal_col.replace('_Signal', '')} Analysis - {ticker}",
                xaxis_title="Date",
                yaxis_title="Price",
                height=500,
                template="plotly_white",
                hovermode='x unified'
            )
            
            return dcc.Graph(figure=fig, config={'displayModeBar': True})
            
        except Exception as e:
            print(f"Error creating fallback chart: {e}")
            traceback.print_exc()
            return html.Div([
                html.P(f"Error creating chart for {signal_col}", className="text-red-500"),
                html.P(f"Error details: {str(e)}", className="text-xs text-gray-500")
            ])





    def create_all_indicators_analysis_table(df, ticker):
        """Create analysis table for all indicators with improved error handling"""
        try:
            signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
            
            all_trades_data = []
            
            for indicator in signal_cols:
                try:
                    signal_pairs, _, _ = calculate_signal_pairs_profit(df, indicator)
                    
                    for i, pair in enumerate(signal_pairs):
                        try:
                            # Safe datetime formatting
                            buy_date_str = "Invalid Date"
                            sell_date_str = "Invalid Date"
                            
                            if pd.notna(pair['buy_date']):
                                try:
                                    if hasattr(pair['buy_date'], 'strftime'):
                                        buy_date_str = pair['buy_date'].strftime('%Y-%m-%d')
                                    else:
                                        buy_date_str = str(pair['buy_date'])
                                except (AttributeError, ValueError):
                                    buy_date_str = str(pair['buy_date'])
                            
                            if pd.notna(pair['sell_date']):
                                try:
                                    if hasattr(pair['sell_date'], 'strftime'):
                                        sell_date_str = pair['sell_date'].strftime('%Y-%m-%d')
                                    else:
                                        sell_date_str = str(pair['sell_date'])
                                except (AttributeError, ValueError):
                                    sell_date_str = str(pair['sell_date'])
                            
                            # FIX: Konsistensi holding_period/holding_days dengan fallback
                            holding_days = pair.get('holding_period', 0)
                            if holding_days == 0:
                                holding_days = pair.get('holding_days', 0)
                            
                            all_trades_data.append({
                                'Trade #': len(all_trades_data) + 1,
                                'Indicator': indicator.replace('_Signal', ''),
                                'Buy Date': buy_date_str,
                                'Buy Price': f"{pair.get('buy_price', 0):.2f}",
                                'Sell Date': sell_date_str,
                                'Sell Price': f"{pair.get('sell_price', 0):.2f}",
                                'Profit %': f"{pair.get('profit_pct', 0):.2f}%",
                                'Holding Days': f"{holding_days:.1f}",
                                'Result': 'Win' if pair.get('profit_pct', 0) > 0 else 'Loss'
                            })
                        except Exception as pair_error:
                            print(f"Error processing pair {i} for indicator {indicator}: {pair_error}")
                            continue
                except Exception as indicator_error:
                    print(f"Error processing indicator {indicator}: {indicator_error}")
                    continue
            
            return html.Div([
                html.H4("ðŸ“‹ All Trades Analysis", className="text-lg font-semibold mb-3"),
                dash_table.DataTable(
                    data=all_trades_data,
                    columns=[
                        {'name': '#', 'id': 'Trade #'},
                        {'name': 'Indicator', 'id': 'Indicator'},
                        {'name': 'Buy Date', 'id': 'Buy Date'},
                        {'name': 'Buy Price', 'id': 'Buy Price'},
                        {'name': 'Sell Date', 'id': 'Sell Date'},
                        {'name': 'Sell Price', 'id': 'Sell Price'},
                        {'name': 'Profit %', 'id': 'Profit %'},
                        {'name': 'Days', 'id': 'Holding Days'},
                        {'name': 'Result', 'id': 'Result'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '12px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Result} = "Win"'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{Result} = "Loss"'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        }
                    ],
                    sort_action='native',
                    filter_action='native',
                    page_size=20
                )
            ], className="p-4 bg-white rounded shadow-sm")
            
        except Exception as e:
            return html.Div([
                html.P(f"Error creating trades analysis: {str(e)}", className="text-red-500"),
                html.Details([
                    html.Summary("Show Error Details", className="cursor-pointer text-blue-600"),
                    html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs")
                ])
            ])
    

    def create_single_indicator_analysis_table(df, ticker, indicator):
        """Create detailed analysis table for single indicator with improved error handling"""
        try:
            signal_pairs, total_profit, win_rate = calculate_signal_pairs_profit(df, indicator)
            
            trades_data = []
            for i, pair in enumerate(signal_pairs):
                try:
                    # Safe datetime formatting
                    buy_date_str = "Invalid Date"
                    sell_date_str = "Invalid Date"
                    
                    if pd.notna(pair['buy_date']):
                        try:
                            if hasattr(pair['buy_date'], 'strftime'):
                                buy_date_str = pair['buy_date'].strftime('%Y-%m-%d')
                            else:
                                buy_date_str = str(pair['buy_date'])
                        except (AttributeError, ValueError):
                            buy_date_str = str(pair['buy_date'])
                    
                    if pd.notna(pair['sell_date']):
                        try:
                            if hasattr(pair['sell_date'], 'strftime'):
                                sell_date_str = pair['sell_date'].strftime('%Y-%m-%d')
                            else:
                                sell_date_str = str(pair['sell_date'])
                        except (AttributeError, ValueError):
                            sell_date_str = str(pair['sell_date'])
                    
                    # FIX: Gunakan holding_period yang konsisten dan tambahkan fallback
                    holding_days = pair.get('holding_period', 0)  # Gunakan holding_period sebagai primary
                    if holding_days == 0:
                        holding_days = pair.get('holding_days', 0)  # Fallback ke holding_days jika ada
                    
                    trades_data.append({
                        'Trade #': i + 1,
                        'Buy Date': buy_date_str,
                        'Buy Price': f"{pair.get('buy_price', 0):.2f}",
                        'Sell Date': sell_date_str,
                        'Sell Price': f"{pair.get('sell_price', 0):.2f}",
                        'Price Change': f"{((pair.get('sell_price', 0) - pair.get('buy_price', 1)) / pair.get('buy_price', 1) * 100):.2f}%",
                        'Profit %': f"{pair.get('profit_pct', 0):.2f}%",
                        'Holding Days': f"{holding_days:.1f}",
                        'Result': 'Win' if pair.get('profit_pct', 0) > 0 else 'Loss'
                    })
                except Exception as trade_error:
                    print(f"Error processing trade {i}: {trade_error}")
                    continue
            
            return html.Div([
                html.H4(f"ðŸ“‹ {indicator.replace('_Signal', '')} Detailed Trade Analysis", className="text-lg font-semibold mb-3"),
                
                # Performance summary
                html.Div([
                    html.Div([
                        html.Span("Total Trades: ", className="font-semibold"),
                        html.Span(f"{len(signal_pairs)}", className="ml-1 text-blue-600")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Winning Trades: ", className="font-semibold"),
                        html.Span(f"{len([p for p in signal_pairs if p.get('profit_pct', 0) > 0])}", className="ml-1 text-green-600")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Losing Trades: ", className="font-semibold"),
                        html.Span(f"{len([p for p in signal_pairs if p.get('profit_pct', 0) <= 0])}", className="ml-1 text-red-600")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Win Rate: ", className="font-semibold"),
                        html.Span(f"{win_rate:.1f}%", className="ml-1 text-purple-600")
                    ], className="mb-2")
                ], className="mb-4 p-3 bg-gray-50 rounded-lg"),
                
                # Detailed trades table
                dash_table.DataTable(
                    data=trades_data,
                    columns=[
                        {'name': '#', 'id': 'Trade #'},
                        {'name': 'Buy Date', 'id': 'Buy Date'},
                        {'name': 'Buy Price', 'id': 'Buy Price'},
                        {'name': 'Sell Date', 'id': 'Sell Date'},
                        {'name': 'Sell Price', 'id': 'Sell Price'},
                        {'name': 'Price Change', 'id': 'Price Change'},
                        {'name': 'Profit %', 'id': 'Profit %'},
                        {'name': 'Days', 'id': 'Holding Days'},
                        {'name': 'Result', 'id': 'Result'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '12px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Result} = "Win"'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{Result} = "Loss"'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        }
                    ],
                    sort_action='native',
                    filter_action='native',
                    page_size=15
                )
            ], className="p-4 bg-white rounded shadow-sm")
            
        except Exception as e:
            return html.Div([
                html.P(f"Error creating analysis table: {str(e)}", className="text-red-500"),
                html.Details([
                    html.Summary("Show Error Details", className="cursor-pointer text-blue-600"),
                    html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs")
                ])
            ])
    

    # Helper functions
    def calculate_signal_pairs_profit(df, signal_col):
        """Calculate profit from signal pairs with improved error handling and consistent naming"""
        if signal_col not in df.columns:
            return [], 0, 0
        
        try:
            # Ensure datetime column is properly formatted
            if 'Datetime' in df.columns:
                df = df.copy()
                df['Datetime'] = pd.to_datetime(df['Datetime'], errors='coerce')
                df = df.dropna(subset=['Datetime'])
                    
            if df.empty:
                return [], 0, 0
            
            df_sorted = df.sort_values('Datetime')
            signal_pairs = []
            current_position = None
            
            for idx, row in df_sorted.iterrows():
                signal = row[signal_col]
                
                if pd.isna(signal) or signal not in ['Buy', 'Sell']:
                    continue
                
                if signal == 'Buy' and current_position is None:
                    current_position = {
                        'buy_date': row['Datetime'],
                        'buy_price': row.get('Close', 0),
                        'buy_idx': idx
                    }
                elif signal == 'Sell' and current_position is not None:
                    sell_price = row.get('Close', 0)
                    profit_pct = ((sell_price - current_position['buy_price']) / current_position['buy_price']) * 100
                    holding_period = (row['Datetime'] - current_position['buy_date']).days
                    
                    signal_pairs.append({
                        'buy_date': current_position['buy_date'],
                        'buy_price': current_position['buy_price'],
                        'sell_date': row['Datetime'],
                        'sell_price': sell_price,
                        'profit_pct': profit_pct,
                        'holding_period': holding_period,  # KONSISTEN menggunakan holding_period
                        'holding_days': holding_period     # TAMBAHKAN alias untuk backward compatibility
                    })
                    
                    current_position = None
            
            # Calculate overall metrics
            if signal_pairs:
                total_profit = sum(pair['profit_pct'] for pair in signal_pairs)
                winning_trades = len([pair for pair in signal_pairs if pair['profit_pct'] > 0])
                win_rate = (winning_trades / len(signal_pairs)) * 100
            else:
                total_profit = 0
                win_rate = 0
            
            return signal_pairs, total_profit, win_rate
            
        except Exception as e:
            print(f"Error in calculate_signal_pairs_profit: {e}")
            return [], 0, 0

    # def get_signal_strength(df, signal_date, indicator):
    #     """Get signal strength based on technical indicator values"""
    #     # This is a simplified version - you can enhance based on specific indicators
    #     try:
    #         row = df[df['Datetime'] == signal_date].iloc[0]
            
    #         # Example strength calculation based on RSI if available
    #         if 'RSI' in df.columns:
    #             rsi = row['RSI']
    #             if rsi > 70:
    #                 return "Strong"
    #             elif rsi < 30:
    #                 return "Strong"
    #             else:
    #                 return "Moderate"
            
    #         return "Normal"
    #     except:
    #         return "Unknown"






    def create_enhanced_signal_distribution_chart_unique(df, selected_ticker):
        """Create enhanced signal distribution chart with improved layout - MAX 5 COLUMNS - FIXED SPACING"""
        if df.empty:
            return html.Div("No data to display", className="text-gray-500")
        
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        if not signal_cols:
            return html.Div("No signal data available", className="text-gray-500")
        
        # Create comprehensive signal analysis dengan layout yang lebih baik
        charts = []
        
        # 1. Signal Distribution Pie Charts dengan layout maksimal 5 kolom - FIXED SPACING
        total_signals = len(signal_cols)
        max_cols = 5
        rows = (total_signals + max_cols - 1) // max_cols  # Calculate rows needed
        
        # FIXED: Calculate proper vertical spacing based on number of rows
        if rows > 1:
            vertical_spacing = min(0.08, 1.0 / (rows - 1) * 0.8)  # Use 80% of maximum allowed spacing
        else:
            vertical_spacing = 0.1  # Default for single row
        
        # Buat subplot dengan layout yang dinamis
        subplot_titles = [col.replace('_Signal', '').replace('_Combined_Signal', ' Combined') for col in signal_cols]
        
        # Create subplot specs - handle empty cells properly
        specs = []
        for row in range(rows):
            row_specs = []
            for col in range(max_cols):
                if row * max_cols + col < total_signals:
                    row_specs.append({"type": "domain"})
                else:
                    row_specs.append(None)  # Empty cell
            specs.append(row_specs)
        
        try:
            fig_pies = make_subplots(
                rows=rows, 
                cols=max_cols,
                subplot_titles=subplot_titles,
                specs=specs,
                vertical_spacing=vertical_spacing,  # Use calculated spacing
                horizontal_spacing=0.05
            )
            
            # Add pie charts
            for i, col in enumerate(signal_cols):
                row = (i // max_cols) + 1
                col_pos = (i % max_cols) + 1
                
                signal_counts = df[col].value_counts()
                
                # Only add if we have data
                if not signal_counts.empty:
                    fig_pies.add_trace(
                        go.Pie(
                            labels=signal_counts.index.tolist(),
                            values=signal_counts.values.tolist(),
                            name=col.replace('_Signal', ''),
                            hole=0.3,
                            textinfo='label+percent',
                            textposition='inside',
                            showlegend=False
                        ),
                        row=row, col=col_pos
                    )
            
            # Calculate height based on number of rows with minimum height
            chart_height = max(400, rows * 300)  # Increased minimum height per row
            
            fig_pies.update_layout(
                title=f"Signal Distribution - {selected_ticker}",
                height=chart_height,
                showlegend=False,
                margin=dict(t=100, b=50, l=50, r=50)
            )
            
            charts.append(dcc.Graph(figure=fig_pies))
            
        except Exception as pie_error:
            print(f"Error creating pie chart: {pie_error}")
            # Fallback: Create simple bar chart instead
            charts.append(create_fallback_signal_chart_bar(df, signal_cols, selected_ticker))
        
        # 2. Signal Timeline Chart (tetap sama)
        try:
            fig_timeline = go.Figure()
            
            colors = ['green', 'red', 'blue', 'orange', 'purple', 'brown', 'pink', 'gray', 'olive', 'cyan']
            
            for i, col in enumerate(signal_cols):
                color = colors[i % len(colors)]
                
                # Get signal positions
                buy_signals = df[df[col] == 'Buy']
                sell_signals = df[df[col] == 'Sell']
                
                if not buy_signals.empty:
                    fig_timeline.add_trace(go.Scatter(
                        x=buy_signals['Datetime'] if 'Datetime' in buy_signals.columns else buy_signals.index,
                        y=[i] * len(buy_signals),
                        mode='markers',
                        name=f"{col.replace('_Signal', '')} Buy",
                        marker=dict(symbol='triangle-up', size=8, color='green'),
                        showlegend=True
                    ))
                
                if not sell_signals.empty:
                    fig_timeline.add_trace(go.Scatter(
                        x=sell_signals['Datetime'] if 'Datetime' in sell_signals.columns else sell_signals.index,
                        y=[i] * len(sell_signals),
                        mode='markers',
                        name=f"{col.replace('_Signal', '')} Sell",
                        marker=dict(symbol='triangle-down', size=8, color='red'),
                        showlegend=True
                    ))
            
            fig_timeline.update_layout(
                title=f"Signal Timeline - {selected_ticker}",
                xaxis_title="Date",
                yaxis=dict(
                    title="Indicators",
                    tickmode='array',
                    tickvals=list(range(len(signal_cols))),
                    ticktext=[col.replace('_Signal', '').replace('_Combined_Signal', ' Combined') for col in signal_cols]
                ),
                height=400,
                legend=dict(
                    orientation="v",
                    yanchor="top",
                    y=1,
                    xanchor="left",
                    x=1.02
                )
            )
            
            charts.append(dcc.Graph(figure=fig_timeline))
            
        except Exception as timeline_error:
            print(f"Error creating timeline chart: {timeline_error}")
            charts.append(html.Div(f"Error creating timeline chart: {str(timeline_error)}", className="text-red-500"))
        
        return html.Div(charts)
    

    def create_fallback_signal_chart_bar(df, signal_cols, selected_ticker):
        """Create fallback bar chart when pie chart fails"""
        try:
            # Prepare data for bar chart
            signal_data = []
            for col in signal_cols:
                signal_counts = df[col].value_counts()
                for signal_type, count in signal_counts.items():
                    signal_data.append({
                        'Indicator': col.replace('_Signal', '').replace('_Combined_Signal', ' Combined'),
                        'Signal Type': signal_type,
                        'Count': count
                    })
            
            if not signal_data:
                return html.Div("No signal data to display", className="text-gray-500")
            
            signal_df = pd.DataFrame(signal_data)
            
            fig = go.Figure()
            
            # Add bars for each signal type
            signal_types = signal_df['Signal Type'].unique()
            colors = {'Buy': 'green', 'Sell': 'red', 'Hold': 'gray', 'High Volume': 'blue', 'Low Volume': 'orange'}
            
            for signal_type in signal_types:
                data = signal_df[signal_df['Signal Type'] == signal_type]
                fig.add_trace(go.Bar(
                    x=data['Indicator'],
                    y=data['Count'],
                    name=signal_type,
                    marker_color=colors.get(signal_type, 'lightblue')
                ))
            
            fig.update_layout(
                title=f"Signal Distribution (Bar Chart) - {selected_ticker}",
                xaxis_title="Indicators",
                yaxis_title="Count",
                barmode='group',
                height=400,
                xaxis_tickangle=-45
            )
            
            return dcc.Graph(figure=fig)
            
        except Exception as fallback_error:
            return html.Div([
                html.P(f"Error creating fallback chart: {str(fallback_error)}", className="text-red-500"),
                html.P("Signal data is available but cannot be visualized due to technical issues.", className="text-gray-600")
            ])




    def create_technical_indicators_detail_unique(df, selected_ticker):
        """Create comprehensive technical indicators detail using chart_generators"""
        if df.empty:
            return html.Div("No data available", className="text-gray-500")
        
        charts = []
        
        # Find available technical indicators and create charts using chart_generators
        indicator_types = []
        
        # Check for different indicator types
        if 'Upper Band' in df.columns and 'Lower Band' in df.columns:
            indicator_types.append('Bollinger_Signal')
        
        if 'short_MA' in df.columns and 'long_MA' in df.columns:
            indicator_types.append('MA_Signal')
        
        if 'RSI' in df.columns:
            indicator_types.append('RSI_Signal')
        
        if 'MACD' in df.columns and 'Signal_Line' in df.columns:
            indicator_types.append('MACD_Signal')
        
        if 'ADX' in df.columns and '+DI' in df.columns and '-DI' in df.columns:
            indicator_types.append('ADX_Signal')
        
        if 'Volume' in df.columns and 'VMA' in df.columns:
            indicator_types.append('Volume_Signal')
        
        # Create charts for each available indicator
        for indicator_type in indicator_types:
            chart = create_technical_chart(indicator_type, df)
            if chart:
                charts.append(html.Div([
                    html.H5(f"ðŸ“Š {indicator_type.replace('_Signal', '')} Technical Analysis", 
                        className="text-md font-semibold mb-2"),
                    chart
                ], className="mb-4"))
        
        if not charts:
            return html.Div("No technical indicators available for detailed analysis", className="text-gray-500")
        
        return html.Div([
            html.H4(f"ðŸ”§ Technical Indicators Detail - {selected_ticker}", className="text-lg font-semibold mb-4"),
            html.Div(charts)
        ])













    def create_enhanced_ticker_summary_table(raw_data, signal_summary):
        """Create an enhanced ticker summary table with technical analysis info"""
        ticker_data = []
        
        for ticker, data in raw_data.items():
            if not data:
                continue
                
            df = pd.DataFrame(data)
            
            # Basic info
            records = len(df)
            
            # Date range
            date_range = "N/A"
            if 'Datetime' in df.columns:
                try:
                    dates = pd.to_datetime(df['Datetime'], errors='coerce').dropna()
                    if not dates.empty:
                        date_range = f"{dates.min().strftime('%Y-%m-%d')} to {dates.max().strftime('%Y-%m-%d')}"
                except:
                    pass
            
            # Price range
            price_range = "N/A"
            if 'Close' in df.columns:
                try:
                    prices = pd.to_numeric(df['Close'], errors='coerce').dropna()
                    if not prices.empty:
                        price_range = f"{prices.min():.2f} - {prices.max():.2f}"
                except:
                    pass
            
            # Technical indicators count
            tech_indicators = len([col for col in df.columns if col in ['RSI', 'MACD', 'ADX', 'Upper Band', 'Lower Band']])
            signal_indicators = len([col for col in df.columns if col.endswith('_Signal')])
            
            # Signal counts
            ticker_signals = signal_summary.get(ticker, {})
            total_signals = sum(sum(signals.values()) if isinstance(signals, dict) else 0 for signals in ticker_signals.values())
            buy_signals = sum(signals.get('Buy', 0) if isinstance(signals, dict) else 0 for signals in ticker_signals.values())
            sell_signals = sum(signals.get('Sell', 0) if isinstance(signals, dict) else 0 for signals in ticker_signals.values())
            
            # Latest technical values
            latest_rsi = "N/A"
            latest_macd = "N/A"
            
            if 'RSI' in df.columns and not df['RSI'].empty:
                try:
                    latest_rsi = f"{df['RSI'].iloc[-1]:.2f}"
                except:
                    pass
            
            if 'MACD' in df.columns and not df['MACD'].empty:
                try:
                    latest_macd = f"{df['MACD'].iloc[-1]:.4f}"
                except:
                    pass
            
            # Signal ratio
            signal_ratio = f"{buy_signals}/{sell_signals}" if sell_signals > 0 else f"{buy_signals}/0"
            
            ticker_data.append({
                'Ticker': ticker,
                'Records': records,
                'Date Range': date_range,
                'Price Range': price_range,
                'Tech Indicators': tech_indicators,
                'Signal Indicators': signal_indicators,
                'Total Signals': total_signals,
                'Buy Signals': buy_signals,
                'Sell Signals': sell_signals,
                'Latest RSI': latest_rsi,
                'Latest MACD': latest_macd,
                'Signal Ratio': signal_ratio
            })
        
        return dash_table.DataTable(
            data=ticker_data,
            columns=[
                {'name': 'Ticker', 'id': 'Ticker'},
                {'name': 'Records', 'id': 'Records'},
                {'name': 'Date Range', 'id': 'Date Range'},
                {'name': 'Price Range', 'id': 'Price Range'},
                {'name': 'Tech Indicators', 'id': 'Tech Indicators'},
                {'name': 'Signal Indicators', 'id': 'Signal Indicators'},
                {'name': 'Total Signals', 'id': 'Total Signals'},
                {'name': 'Buy Signals', 'id': 'Buy Signals'},
                {'name': 'Sell Signals', 'id': 'Sell Signals'},
                {'name': 'Latest RSI', 'id': 'Latest RSI'},
                {'name': 'Latest MACD', 'id': 'Latest MACD'},
                {'name': 'B/S Ratio', 'id': 'Signal Ratio'}
            ],
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '10px'},
            style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
            style_data_conditional=[
                {
                    'if': {'filter_query': '{Buy Signals} > {Sell Signals}'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)'
                },
                {
                    'if': {'filter_query': '{Sell Signals} > {Buy Signals}'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)'
                },
                {
                    'if': {'filter_query': '{Latest RSI} > 70'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.2)',
                    'color': 'red'
                },
                {
                    'if': {'filter_query': '{Latest RSI} < 30'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.2)',
                    'color': 'green'
                }
            ],
            sort_action='native',
            page_size=10
        )
    

    def generate_enhanced_data_quality_chart(raw_data, signal_summary):
        """Generate enhanced data quality and signal distribution chart"""
        # Create subplots
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Data Records by Ticker', 'Signal Distribution by Ticker', 
                        'Buy vs Sell Signals', 'Technical Indicators Usage'),
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        tickers = list(raw_data.keys())
        
        # 1. Data Records by Ticker
        records_count = [len(raw_data[ticker]) for ticker in tickers]
        fig.add_trace(
            go.Bar(x=tickers, y=records_count, name='Records', marker_color='blue'),
            row=1, col=1
        )
        
        # 2. Signal Distribution by Ticker
        total_signals = []
        for ticker in tickers:
            ticker_signals = signal_summary.get(ticker, {})
            total = sum(sum(signals.values()) if isinstance(signals, dict) else 0 for signals in ticker_signals.values())
            total_signals.append(total)
        
        fig.add_trace(
            go.Bar(x=tickers, y=total_signals, name='Total Signals', marker_color='green'),
            row=1, col=2
        )
        
        # 3. Buy vs Sell Signals
        buy_signals = []
        sell_signals = []
        for ticker in tickers:
            ticker_signals = signal_summary.get(ticker, {})
            buy_count = sum(signals.get('Buy', 0) if isinstance(signals, dict) else 0 for signals in ticker_signals.values())
            sell_count = sum(signals.get('Sell', 0) if isinstance(signals, dict) else 0 for signals in ticker_signals.values())
            buy_signals.append(buy_count)
            sell_signals.append(sell_count)
        
        fig.add_trace(
            go.Bar(x=tickers, y=buy_signals, name='Buy', marker_color='lightgreen'),
            row=2, col=1
        )
        fig.add_trace(
            go.Bar(x=tickers, y=sell_signals, name='Sell', marker_color='lightcoral'),
            row=2, col=1
        )
        
        # 4. Technical Indicators Usage
        all_indicators = set()
        for ticker_signals in signal_summary.values():
            all_indicators.update(ticker_signals.keys())
        
        indicator_usage = []
        for indicator in sorted(all_indicators):
            usage_count = sum(1 for ticker_signals in signal_summary.values() if indicator in ticker_signals)
            indicator_usage.append(usage_count)
        
        fig.add_trace(
            go.Bar(x=[ind.replace('_Signal', '') for ind in sorted(all_indicators)], 
                y=indicator_usage, name='Indicator Usage', marker_color='purple'),
            row=2, col=2
        )
        
        fig.update_layout(
            height=600,
            showlegend=True,
            title_text="Comprehensive Data Quality and Signal Analysis"
        )
        
        return fig




    # Enhanced callback for ticker-specific data
    @app.callback(
        Output("selected-ticker-data", "children", allow_duplicate = True),
        [Input("raw-data-ticker-selector", "value"),
        Input("raw-data-search", "value"),
        Input("raw-data-signal-filter", "value"),
        Input("raw-data-indicator-filter", "value")],
        [State("stored-raw-data", "children")],
        prevent_initial_call=True
    )
    def update_selected_ticker_data_enhanced(selected_ticker, search_term, signal_filter, indicator_filter, stored_data):
        if not selected_ticker or not stored_data:
            return html.Div("No data available", className="text-gray-500 text-center p-4")
        
        try:
            raw_data = json.loads(stored_data)
            ticker_data = raw_data.get(selected_ticker, [])
            
            if not ticker_data:
                return html.Div(f"No data found for {selected_ticker}", className="text-red-500 text-center p-4")
            
            df = pd.DataFrame(ticker_data)
            
            # Convert datetime if it's string
            if 'Datetime' in df.columns:
                try:
                    df['Datetime'] = pd.to_datetime(df['Datetime'])
                except:
                    pass
            
            # Apply filters
            filtered_df = df.copy()
            
            # Search filter
            if search_term:
                search_term = search_term.lower()
                if search_term:
                    # Search in multiple columns
                    mask = False
                    for col in df.columns:
                        if df[col].dtype == 'object':
                            mask |= df[col].astype(str).str.lower().str.contains(search_term, na=False)
                        elif col in ['Close', 'Open', 'High', 'Low']:
                            try:
                                # Try to parse as price range (e.g., "1000-2000")
                                if '-' in search_term and len(search_term.split('-')) == 2:
                                    min_price, max_price = map(float, search_term.split('-'))
                                    mask |= (df[col] >= min_price) & (df[col] <= max_price)
                                else:
                                    # Try exact price match
                                    price = float(search_term)
                                    mask |= abs(df[col] - price) < 0.01
                            except:
                                continue
                    filtered_df = df[mask] if mask.any() else df
            
            # Signal filter
            if signal_filter != 'all':
                signal_columns = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
                if signal_columns:
                    signal_mask = False
                    for col in signal_columns:
                        signal_mask |= (df[col] == signal_filter)
                    filtered_df = filtered_df[signal_mask] if signal_mask.any() else filtered_df
            
            # Indicator filter
            if indicator_filter != 'all':
                # Show only rows where the specific indicator has signals
                indicator_mask = (df[indicator_filter] != 'Hold') & (df[indicator_filter].notna())
                filtered_df = filtered_df[indicator_mask] if indicator_mask.any() else filtered_df
            
            # Create summary statistics
            summary_stats = create_ticker_summary_stats(df, selected_ticker)
            
            # Create detailed table
            detailed_table = create_enhanced_ticker_table(filtered_df, selected_ticker)
            
            return html.Div([
                summary_stats,
                html.Hr(className="my-4"),
                detailed_table
            ])
            
        except Exception as e:
            return html.Div([
                html.P(f"Error processing data: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs")
            ])

    def create_ticker_summary_stats(df, ticker):
        """Create summary statistics for a specific ticker"""
        # Basic stats
        total_records = len(df)
        date_range = "N/A"
        price_stats = "N/A"
        
        if 'Datetime' in df.columns and not df['Datetime'].isna().all():
            try:
                min_date = df['Datetime'].min()
                max_date = df['Datetime'].max()
                date_range = f"{min_date.strftime('%Y-%m-%d')} to {max_date.strftime('%Y-%m-%d')}"
            except:
                pass
        
        if 'Close' in df.columns and not df['Close'].isna().all():
            try:
                min_price = df['Close'].min()
                max_price = df['Close'].max()
                avg_price = df['Close'].mean()
                price_stats = f"Min: {min_price:.2f}, Max: {max_price:.2f}, Avg: {avg_price:.2f}"
            except:
                pass
        
        # Signal analysis
        signal_columns = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        signal_stats = {}
        
        for col in signal_columns:
            if col in df.columns:
                signal_counts = df[col].value_counts().to_dict()
                signal_stats[col.replace('_Signal', '')] = signal_counts
        
        return html.Div([
            html.H4(f"ðŸ“Š Analysis Summary for {ticker}", className="text-lg font-semibold mb-3"),
            
            # Basic Statistics
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Total Records", className="block text-sm text-gray-500"),
                        html.Span(f"{total_records:,}", className="block text-xl font-bold text-blue-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/3 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Date Range", className="block text-sm text-gray-500"),
                        html.Span(date_range, className="block text-sm font-bold text-green-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/3 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Price Statistics", className="block text-sm text-gray-500"),
                        html.Span(price_stats, className="block text-sm font-bold text-purple-600")
                    ], className="p-3 border rounded bg-white shadow-sm text-center")
                ], className="w-1/3 px-2")
            ], className="flex -mx-2 mb-4"),
            
            # Signal Statistics
            html.Div([
                html.H5("ðŸŽ¯ Signal Analysis by Indicator", className="text-md font-semibold mb-2"),
                html.Div([
                    html.Div([
                        html.H6(f"{indicator}", className="font-semibold text-sm mb-1"),
                        html.Div([
                            html.Span(f"Buy: {counts.get('Buy', 0)}", className="mr-2 text-green-600"),
                            html.Span(f"Sell: {counts.get('Sell', 0)}", className="mr-2 text-red-600"),
                            html.Span(f"Hold: {counts.get('Hold', 0)}", className="text-gray-600")
                        ], className="text-xs")
                    ], className="p-2 border rounded bg-gray-50 mb-2")
                    for indicator, counts in signal_stats.items()
                ])
            ], className="p-3 bg-blue-50 rounded-lg border border-blue-200")
        ])

    def create_enhanced_ticker_table(df, ticker):
        """Create an enhanced data table for ticker data"""
        if df.empty:
            return html.Div("No data matches the current filters", className="text-gray-500 text-center p-4")
        
        # Prepare data for display
        display_columns = []
        table_data = []
        
        # Essential columns first
        essential_cols = ['Datetime', 'Open', 'High', 'Low', 'Close', 'Volume']
        for col in essential_cols:
            if col in df.columns:
                display_columns.append({'name': col, 'id': col})
        
        # Add signal columns
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        for col in sorted(signal_cols):
            display_columns.append({'name': col.replace('_Signal', '') + ' Signal', 'id': col})
        
        # Add technical indicator values
        tech_cols = [col for col in df.columns if col in ['RSI', 'MACD', 'ADX', 'Upper Band', 'Lower Band', 'Middle Band', 'short_MA', 'long_MA']]
        for col in sorted(tech_cols):
            display_columns.append({'name': col, 'id': col})
        
        # Prepare table data
        for _, row in df.iterrows():
            row_data = {}
            for col_info in display_columns:
                col_id = col_info['id']
                if col_id in row:
                    value = row[col_id]
                    if col_id == 'Datetime' and pd.notna(value):
                        try:
                            row_data[col_id] = pd.to_datetime(value).strftime('%Y-%m-%d %H:%M')
                        except:
                            row_data[col_id] = str(value)
                    elif isinstance(value, (int, float)) and pd.notna(value):
                        if col_id in ['Open', 'High', 'Low', 'Close']:
                            row_data[col_id] = f"{value:.2f}"
                        elif col_id == 'Volume':
                            row_data[col_id] = f"{int(value):,}"
                        else:
                            row_data[col_id] = f"{value:.4f}"
                    else:
                        row_data[col_id] = str(value) if pd.notna(value) else ""
                else:
                    row_data[col_id] = ""
            table_data.append(row_data)
        
        return html.Div([
            html.H5(f"ðŸ“‹ Detailed Data for {ticker} ({len(df)} records)", className="text-md font-semibold mb-3"),
            dash_table.DataTable(
                data=table_data,
                columns=display_columns,
                style_table={'overflowX': 'auto'},
                style_cell={
                    'textAlign': 'left', 
                    'padding': '8px',
                    'fontSize': '11px',
                    'whiteSpace': 'normal',
                    'height': 'auto'
                },
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold',
                    'fontSize': '12px'
                },
                style_data_conditional=[
                    # Highlight buy signals
                    {
                        'if': {
                            'filter_query': '{{{col}}} = Buy'.format(col=col['id'])
                            for col in display_columns if 'Signal' in col['name']
                        },
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                        'color': 'green'
                    },
                    # Highlight sell signals
                    {
                        'if': {
                            'filter_query': '{{{col}}} = Sell'.format(col=col['id'])
                            for col in display_columns if 'Signal' in col['name']
                        },
                        'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                        'color': 'red'
                    }
                ],
                page_size=20,
                sort_action='native',
                filter_action='native'
            )
        ])

    # Enhanced callback for price chart
    @app.callback(
        Output("ticker-price-chart", "children", allow_duplicate = True),
        [Input("raw-data-ticker-selector", "value")],
        [State("stored-raw-data", "children")],
        prevent_initial_call=True
    )
    def update_ticker_price_chart_enhanced(selected_ticker, stored_data):
        if not selected_ticker or not stored_data:
            return html.Div("No ticker selected", className="text-gray-500 text-center p-4")
        
        try:
            raw_data = json.loads(stored_data)
            ticker_data = raw_data.get(selected_ticker, [])
            
            if not ticker_data:
                return html.Div(f"No data found for {selected_ticker}", className="text-red-500 text-center p-4")
            
            df = pd.DataFrame(ticker_data)
            
            # Convert datetime
            if 'Datetime' in df.columns:
                df['Datetime'] = pd.to_datetime(df['Datetime'])
                df = df.sort_values('Datetime')
            
            return create_enhanced_price_chart(df, selected_ticker)
            
        except Exception as e:
            return html.Div(f"Error creating chart: {str(e)}", className="text-red-500 text-center p-4")

    def create_enhanced_price_chart(df, ticker):
        """Create enhanced price chart with technical indicators and signals"""
        fig = make_subplots(
            rows=3, cols=1,
            shared_xaxes=True,
            vertical_spacing=0.05,
            subplot_titles=(f'{ticker} - Price & Signals', 'Volume', 'RSI & Technical Indicators'),
            row_heights=[0.6, 0.2, 0.2]
        )
        
        # Main price chart
        if all(col in df.columns for col in ['Open', 'High', 'Low', 'Close']):
            fig.add_trace(
                go.Candlestick(
                    x=df['Datetime'],
                    open=df['Open'],
                    high=df['High'],
                    low=df['Low'],
                    close=df['Close'],
                    name='Price'
                ),
                row=1, col=1
            )
        elif 'Close' in df.columns:
            fig.add_trace(
                go.Scatter(
                    x=df['Datetime'],
                    y=df['Close'],
                    mode='lines',
                    name='Close Price',
                    line=dict(color='blue', width=2)
                ),
                row=1, col=1
            )
        
        # Add technical indicators to price chart
        if 'Upper Band' in df.columns and 'Lower Band' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['Upper Band'], mode='lines', 
                        name='Upper BB', line=dict(color='red', dash='dot')),
                row=1, col=1
            )
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['Lower Band'], mode='lines',
                        name='Lower BB', line=dict(color='green', dash='dot')),
                row=1, col=1
            )
        
        if 'short_MA' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['short_MA'], mode='lines',
                        name='Short MA', line=dict(color='orange', width=1)),
                row=1, col=1
            )
        
        if 'long_MA' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['long_MA'], mode='lines',
                        name='Long MA', line=dict(color='purple', width=1)),
                row=1, col=1
            )
        
        # Add signals
        signal_columns = [col for col in df.columns if col.endswith('_Signal')]
        colors = ['green', 'red', 'blue', 'orange', 'purple']
        
        for i, signal_col in enumerate(signal_columns):
            buy_signals = df[df[signal_col] == 'Buy']
            sell_signals = df[df[signal_col] == 'Sell']
            
            if not buy_signals.empty and 'Close' in buy_signals.columns:
                fig.add_trace(
                    go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals['Close'],
                        mode='markers',
                        name=f'{signal_col.replace("_Signal", "")} Buy',
                        marker=dict(symbol='triangle-up', size=10, color=colors[i % len(colors)])
                    ),
                    row=1, col=1
                )
            
            if not sell_signals.empty and 'Close' in sell_signals.columns:
                fig.add_trace(
                    go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals['Close'],
                        mode='markers',
                        name=f'{signal_col.replace("_Signal", "")} Sell',
                        marker=dict(symbol='triangle-down', size=10, color=colors[i % len(colors)])
                    ),
                    row=1, col=1
                )
        
        # Volume chart
        if 'Volume' in df.columns:
            fig.add_trace(
                go.Bar(x=df['Datetime'], y=df['Volume'], name='Volume', marker_color='lightblue'),
                row=2, col=1
            )
        
        # RSI and other indicators
        if 'RSI' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['RSI'], mode='lines', name='RSI', line=dict(color='purple')),
                row=3, col=1
            )
            # Add RSI levels
            fig.add_hline(y=70, line_dash="dash", line_color="red", row=3, col=1)
            fig.add_hline(y=30, line_dash="dash", line_color="green", row=3, col=1)
        
        if 'MACD' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['MACD'], mode='lines', name='MACD', line=dict(color='blue')),
                row=3, col=1
            )
        
        fig.update_layout(
            height=800,
            title_text=f"Comprehensive Technical Analysis - {ticker}",
            xaxis_rangeslider_visible=False
        )
        
        return dcc.Graph(figure=fig, config={'displayModeBar': True})

    # Enhanced callback for signal distribution chart
    @app.callback(
        Output("ticker-signal-chart", "children"),
        [Input("raw-data-ticker-selector", "value")],
        [State("stored-raw-data", "children")]
    )
    def update_ticker_signal_chart_enhanced(selected_ticker, stored_data):
        if not selected_ticker or not stored_data:
            return html.Div("No ticker selected", className="text-gray-500 text-center p-4")
        
        try:
            raw_data = json.loads(stored_data)
            ticker_data = raw_data.get(selected_ticker, [])
            
            if not ticker_data:
                return html.Div(f"No data found for {selected_ticker}", className="text-red-500 text-center p-4")
            
            df = pd.DataFrame(ticker_data)
            return create_enhanced_signal_distribution_chart(df, selected_ticker)
            
        except Exception as e:
            return html.Div(f"Error creating signal chart: {str(e)}", className="text-red-500 text-center p-4")

    def create_enhanced_signal_distribution_chart(df, ticker):
        """Create enhanced signal distribution analysis"""
        signal_cols = [col for col in df.columns if col.endswith('_Signal') or col == 'Combined_Signal']
        
        if not signal_cols:
            return html.Div("No signal data available", className="text-gray-500 text-center p-4")
        
        # Create subplots for different analyses
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Signal Distribution by Indicator', 'Signal Timeline', 
                        'Buy vs Sell Distribution', 'Signal Frequency Over Time'),
            specs=[[{"type": "xy"}, {"type": "xy"}],
                [{"type": "xy"}, {"type": "xy"}]]
        )
        
        # 1. Signal Distribution by Indicator
        signal_data = []
        for col in signal_cols:
            signal_counts = df[col].value_counts()
            for signal_type, count in signal_counts.items():
                signal_data.append({
                    'Indicator': col.replace('_Signal', ''),
                    'Signal': signal_type,
                    'Count': count
                })
        
        signal_df = pd.DataFrame(signal_data)
        
        for signal_type in ['Buy', 'Sell', 'Hold']:
            data = signal_df[signal_df['Signal'] == signal_type]
            if not data.empty:
                color = 'green' if signal_type == 'Buy' else 'red' if signal_type == 'Sell' else 'gray'
                fig.add_trace(
                    go.Bar(x=data['Indicator'], y=data['Count'], name=signal_type, marker_color=color),
                    row=1, col=1
                )
        
        # 2. Signal Timeline (if datetime available)
        if 'Datetime' in df.columns:
            df['Datetime'] = pd.to_datetime(df['Datetime'])
            df_sorted = df.sort_values('Datetime')
            
            # Show signals over time for the first signal column
            if signal_cols:
                signal_col = signal_cols[0]
                signal_timeline = df_sorted[df_sorted[signal_col].isin(['Buy', 'Sell'])]
                
                buy_timeline = signal_timeline[signal_timeline[signal_col] == 'Buy']
                sell_timeline = signal_timeline[signal_timeline[signal_col] == 'Sell']
                
                if not buy_timeline.empty:
                    fig.add_trace(
                        go.Scatter(x=buy_timeline['Datetime'], y=[1]*len(buy_timeline), 
                                mode='markers', name='Buy Timeline', 
                                marker=dict(color='green', size=8, symbol='triangle-up')),
                        row=1, col=2
                    )
                
                if not sell_timeline.empty:
                    fig.add_trace(
                        go.Scatter(x=sell_timeline['Datetime'], y=[0]*len(sell_timeline),
                                mode='markers', name='Sell Timeline',
                                marker=dict(color='red', size=8, symbol='triangle-down')),
                        row=1, col=2
                    )
        
        # 3. Buy vs Sell Distribution
        buy_sell_data = []
        for col in signal_cols:
            buy_count = (df[col] == 'Buy').sum()
            sell_count = (df[col] == 'Sell').sum()
            buy_sell_data.append({'Indicator': col.replace('_Signal', ''), 'Buy': buy_count, 'Sell': sell_count})
        
        if buy_sell_data:
            bs_df = pd.DataFrame(buy_sell_data)
            fig.add_trace(
                go.Bar(x=bs_df['Indicator'], y=bs_df['Buy'], name='Buy Count', marker_color='lightgreen'),
                row=2, col=1
            )
            fig.add_trace(
                go.Bar(x=bs_df['Indicator'], y=bs_df['Sell'], name='Sell Count', marker_color='lightcoral'),
                row=2, col=1
            )
        
        # 4. Signal Frequency Over Time (weekly aggregation)
        if 'Datetime' in df.columns and signal_cols:
            df['Week'] = df['Datetime'].dt.to_period('W')
            weekly_signals = df.groupby(['Week', signal_cols[0]]).size().reset_index(name='Count')
            
            for signal_type in ['Buy', 'Sell']:
                data = weekly_signals[weekly_signals[signal_cols[0]] == signal_type]
                if not data.empty:
                    color = 'green' if signal_type == 'Buy' else 'red'
                    fig.add_trace(
                        go.Scatter(x=data['Week'].astype(str), y=data['Count'], 
                                mode='lines+markers', name=f'{signal_type} Frequency',
                                line=dict(color=color)),
                        row=2, col=2
                    )
        
        fig.update_layout(
            height=600,
            title_text=f"Signal Analysis Dashboard - {ticker}",
            showlegend=True
        )
        
        return dcc.Graph(figure=fig, config={'displayModeBar': True})

    # Enhanced callback for technical indicators detail
    @app.callback(
        Output("ticker-indicators-chart", "children", allow_duplicate = True),
        [Input("raw-data-ticker-selector", "value")],
        [State("stored-raw-data", "children")],
        prevent_initial_call=True
    )
    def update_ticker_indicators_detail(selected_ticker, stored_data):
        if not selected_ticker or not stored_data:
            return html.Div("No ticker selected", className="text-gray-500 text-center p-4")
        
        try:
            raw_data = json.loads(stored_data)
            ticker_data = raw_data.get(selected_ticker, [])
            
            if not ticker_data:
                return html.Div(f"No data found for {selected_ticker}", className="text-red-500 text-center p-4")
            
            df = pd.DataFrame(ticker_data)
            return create_technical_indicators_detail(df, selected_ticker)
            
        except Exception as e:
            return html.Div(f"Error creating indicators detail: {str(e)}", className="text-red-500 text-center p-4")

    def create_technical_indicators_detail(df, ticker):
        """Create detailed technical indicators analysis"""
        # Find available technical indicators
        tech_indicators = []
        
        # RSI
        if 'RSI' in df.columns:
            tech_indicators.append('RSI')
        
        # MACD
        if all(col in df.columns for col in ['MACD', 'Signal_Line']):
            tech_indicators.append('MACD')
        
        # Bollinger Bands
        if all(col in df.columns for col in ['Upper Band', 'Lower Band', 'Middle Band']):
            tech_indicators.append('Bollinger Bands')
        
        # Moving Averages
        if all(col in df.columns for col in ['short_MA', 'long_MA']):
            tech_indicators.append('Moving Averages')
        
        # ADX
        if 'ADX' in df.columns:
            tech_indicators.append('ADX')
        
        if not tech_indicators:
            return html.Div("No technical indicators data available", className="text-gray-500 text-center p-4")
        
        # Create tabs for each indicator
        tab_children = []
        
        for indicator in tech_indicators:
            if indicator == 'RSI':
                tab_children.append(
                    dcc.Tab(label='RSI', children=[
                        create_rsi_analysis(df, ticker)
                    ])
                )
            elif indicator == 'MACD':
                tab_children.append(
                    dcc.Tab(label='MACD', children=[
                        create_macd_analysis(df, ticker)
                    ])
                )
            elif indicator == 'Bollinger Bands':
                tab_children.append(
                    dcc.Tab(label='Bollinger Bands', children=[
                        create_bollinger_analysis(df, ticker)
                    ])
                )
            elif indicator == 'Moving Averages':
                tab_children.append(
                    dcc.Tab(label='Moving Averages', children=[
                        create_ma_analysis(df, ticker)
                    ])
                )
            elif indicator == 'ADX':
                tab_children.append(
                    dcc.Tab(label='ADX', children=[
                        create_adx_analysis(df, ticker)
                    ])
                )
        
        return html.Div([
            html.H4(f"ðŸ”§ Technical Indicators Detail - {ticker}", className="text-lg font-semibold mb-3"),
            dcc.Tabs(tab_children)
        ])

    def create_rsi_analysis(df, ticker):
        """Create RSI analysis"""
        if 'Datetime' in df.columns:
            df['Datetime'] = pd.to_datetime(df['Datetime'])
        
        fig = go.Figure()
        
        # RSI line
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['RSI'], mode='lines', name='RSI', line=dict(color='purple', width=2))
        )
        
        # Overbought and oversold levels
        fig.add_hline(y=70, line_dash="dash", line_color="red", annotation_text="Overbought (70)")
        fig.add_hline(y=30, line_dash="dash", line_color="green", annotation_text="Oversold (30)")
        fig.add_hline(y=50, line_dash="dot", line_color="gray", annotation_text="Neutral (50)")
        
        # Highlight overbought/oversold areas
        fig.add_hrect(y0=70, y1=100, fillcolor="red", opacity=0.1, annotation_text="Overbought Zone")
        fig.add_hrect(y0=0, y1=30, fillcolor="green", opacity=0.1, annotation_text="Oversold Zone")
        
        fig.update_layout(
            title=f"RSI Analysis - {ticker}",
            xaxis_title="Date",
            yaxis_title="RSI Value",
            height=400,
            yaxis=dict(range=[0, 100])
        )
        
        # Calculate RSI statistics
        rsi_stats = {
            'Average RSI': df['RSI'].mean(),
            'Current RSI': df['RSI'].iloc[-1] if not df['RSI'].empty else 0,
            'Overbought Periods': (df['RSI'] > 70).sum(),
            'Oversold Periods': (df['RSI'] < 30).sum(),
            'Neutral Periods': ((df['RSI'] >= 30) & (df['RSI'] <= 70)).sum()
        }
        
        stats_div = html.Div([
            html.H5("RSI Statistics", className="font-semibold mb-2"),
            html.Div([
                html.Div([
                    html.Span(f"{key}: ", className="font-medium"),
                    html.Span(f"{value:.2f}" if isinstance(value, float) else str(value), 
                            className="text-blue-600")
                ], className="mb-1")
                for key, value in rsi_stats.items()
            ])
        ], className="mt-4 p-3 bg-gray-50 rounded")
        
        return html.Div([
            dcc.Graph(figure=fig),
            stats_div
        ])

    def create_macd_analysis(df, ticker):
        """Create MACD analysis"""
        if 'Datetime' in df.columns:
            df['Datetime'] = pd.to_datetime(df['Datetime'])
        
        fig = make_subplots(rows=2, cols=1, shared_xaxes=True, 
                        subplot_titles=('MACD Line & Signal Line', 'MACD Histogram'))
        
        # MACD and Signal Line
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['MACD'], mode='lines', name='MACD', line=dict(color='blue')),
            row=1, col=1
        )
        
        if 'Signal_Line' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['Signal_Line'], mode='lines', name='Signal Line', line=dict(color='red')),
                row=1, col=1
            )
        
        # MACD Histogram
        if 'MACD_Hist' in df.columns:
            colors = ['green' if val >= 0 else 'red' for val in df['MACD_Hist']]
            fig.add_trace(
                go.Bar(x=df['Datetime'], y=df['MACD_Hist'], name='MACD Histogram', marker_color=colors),
                row=2, col=1
            )
        
        fig.update_layout(
            title=f"MACD Analysis - {ticker}",
            height=500
        )
        
        return dcc.Graph(figure=fig)

    def create_bollinger_analysis(df, ticker):
        """Create Bollinger Bands analysis"""
        if 'Datetime' in df.columns:
            df['Datetime'] = pd.to_datetime(df['Datetime'])
        
        fig = go.Figure()
        
        # Price
        if 'Close' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['Close'], mode='lines', name='Close Price', line=dict(color='blue'))
            )
        
        # Bollinger Bands
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['Upper Band'], mode='lines', name='Upper Band', line=dict(color='red', dash='dot'))
        )
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['Middle Band'], mode='lines', name='Middle Band', line=dict(color='orange'))
        )
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['Lower Band'], mode='lines', name='Lower Band', line=dict(color='green', dash='dot'))
        )
        
        # Fill between bands
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['Upper Band'], fill=None, mode='lines', line_color='rgba(0,0,0,0)', showlegend=False)
        )
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['Lower Band'], fill='tonexty', mode='lines', line_color='rgba(0,0,0,0)', 
                    fillcolor='rgba(0,100,80,0.2)', showlegend=False)
        )
        
        fig.update_layout(
            title=f"Bollinger Bands Analysis - {ticker}",
            xaxis_title="Date",
            yaxis_title="Price",
            height=400
        )
        
        return dcc.Graph(figure=fig)

    def create_ma_analysis(df, ticker):
        """Create Moving Average analysis"""
        if 'Datetime' in df.columns:
            df['Datetime'] = pd.to_datetime(df['Datetime'])
        
        fig = go.Figure()
        
        # Price
        if 'Close' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['Close'], mode='lines', name='Close Price', line=dict(color='blue'))
            )
        
        # Moving Averages
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['short_MA'], mode='lines', name='Short MA', line=dict(color='orange'))
        )
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['long_MA'], mode='lines', name='Long MA', line=dict(color='purple'))
        )
        
        # Add crossover points
        if 'MA_Signal' in df.columns:
            buy_points = df[df['MA_Signal'] == 'Buy']
            sell_points = df[df['MA_Signal'] == 'Sell']
            
            if not buy_points.empty:
                fig.add_trace(
                    go.Scatter(x=buy_points['Datetime'], y=buy_points['Close'], mode='markers',
                            name='Golden Cross', marker=dict(symbol='triangle-up', size=10, color='green'))
                )
            
            if not sell_points.empty:
                fig.add_trace(
                    go.Scatter(x=sell_points['Datetime'], y=sell_points['Close'], mode='markers',
                            name='Death Cross', marker=dict(symbol='triangle-down', size=10, color='red'))
                )
        
        fig.update_layout(
            title=f"Moving Average Analysis - {ticker}",
            xaxis_title="Date",
            yaxis_title="Price",
            height=400
        )
        
        return dcc.Graph(figure=fig)

    def create_adx_analysis(df, ticker):
        """Create ADX analysis"""
        if 'Datetime' in df.columns:
            df['Datetime'] = pd.to_datetime(df['Datetime'])
        
        fig = make_subplots(rows=2, cols=1, shared_xaxes=True,
                        subplot_titles=('ADX Trend Strength', 'Directional Movement'))
        
        # ADX
        fig.add_trace(
            go.Scatter(x=df['Datetime'], y=df['ADX'], mode='lines', name='ADX', line=dict(color='purple')),
            row=1, col=1
        )
        fig.add_hline(y=25, line_dash="dash", line_color="red", annotation_text="Strong Trend (25)", row=1, col=1)
        
        # +DI and -DI
        if '+DI' in df.columns and '-DI' in df.columns:
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['+DI'], mode='lines', name='+DI', line=dict(color='green')),
                row=2, col=1
            )
            fig.add_trace(
                go.Scatter(x=df['Datetime'], y=df['-DI'], mode='lines', name='-DI', line=dict(color='red')),
                row=2, col=1
            )
        
        fig.update_layout(
            title=f"ADX Analysis - {ticker}",
            height=500
        )
        
        return dcc.Graph(figure=fig)













    
    # Helper functions to generate the three main tab contents
    # def generate_standard_backtesting_results(all_results):
    #     """Generate content for the Standard Backtesting tab"""
    #     if 'ticker_details' not in all_results or not all_results['ticker_details']:
    #         return html.Div("No standard backtesting results available", className="text-center text-gray-500 p-4")
        
    #     # Get the best performing ticker and indicator
    #     best_performer = None
    #     if all_results['leaderboard']:
    #         best_performer = all_results['leaderboard'][0]
        
    #     components = []
        
    #     # Add best performer insight card if available
    #     if best_performer:
    #         components.append(html.Div([
    #             html.H3("Best Performing Strategy", className="text-xl font-semibold mb-3"),
    #             html.Div([
    #                 html.Div([
    #                     html.Span("Ticker: ", className="font-semibold"),
    #                     html.Span(best_performer['ticker'], className="ml-1 text-blue-600")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Span("Technical Indicator: ", className="font-semibold"),
    #                     html.Span(best_performer['indicator'], className="ml-1 text-blue-600")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Span("Profit: ", className="font-semibold"),
    #                     html.Span(f"{best_performer['profit_percentage']:.2f}%", 
    #                             className=f"ml-1 {'text-green-600' if best_performer['profit_percentage'] > 0 else 'text-red-600'}")
    #                 ], className="mb-2"),
    #                 html.Div([
    #                     html.Span("Win Rate: ", className="font-semibold"),
    #                     html.Span(f"{best_performer['win_rate']:.2f}%", className="ml-1 text-blue-600")
    #                 ], className="mb-2"),
    #             ], className="p-4 bg-green-50 border border-green-200 rounded mb-4")
    #         ]))
        
    #     # Performance comparison chart
    #     if all_results['leaderboard']:
    #         # Limit to top 10 performers for visualization
    #         top_performers = all_results['leaderboard'][:10]
            
    #         profit_chart = dcc.Graph(
    #             figure=go.Figure(
    #                 data=[
    #                     go.Bar(
    #                         x=[f"{p['ticker']} ({p['indicator']})" for p in top_performers],
    #                         y=[p['profit_percentage'] for p in top_performers],
    #                         marker_color=['green' if p['profit_percentage'] > 0 else 'red' for p in top_performers],
    #                         text=[f"{p['profit_percentage']:.2f}%" for p in top_performers],
    #                         textposition='auto'
    #                     )
    #                 ],
    #                 layout=go.Layout(
    #                     title=f"Top {len(top_performers)} Performer(s) by Profit %",
    #                     xaxis_title="Ticker (Indicator)",
    #                     yaxis_title="Profit %",
    #                     height=500,
    #                     margin=dict(l=50, r=50, t=80, b=100),
    #                     xaxis={'tickangle': -45}
    #                 )
    #             )
    #         )
            
    #         components.append(html.Div([
    #             html.H3("Performance Comparison", className="text-xl font-semibold mt-6 mb-3"),
    #             profit_chart
    #         ]))
        
    #     # Summary table of all results
    #     if all_results['leaderboard']:
    #         summary_table = dash_table.DataTable(
    #             data=[{
    #                 'Ticker': result['ticker'],
    #                 'Indicator': result['indicator'],
    #                 'Profit %': f"{result['profit_percentage']:.2f}%",
    #                 'Win Rate': f"{result['win_rate']:.2f}%",
    #                 'Trades': result['num_trades'],
    #                 'Total Profit': f"{result['total_profit']:,.2f}"
    #             } for result in all_results['leaderboard']],
    #             columns=[
    #                 {'name': 'Ticker', 'id': 'Ticker'},
    #                 {'name': 'Indicator', 'id': 'Indicator'},
    #                 {'name': 'Profit %', 'id': 'Profit %'},
    #                 {'name': 'Win Rate', 'id': 'Win Rate'},
    #                 {'name': 'Trades', 'id': 'Trades'},
    #                 {'name': 'Total Profit', 'id': 'Total Profit'}
    #             ],
    #             style_table={'overflowX': 'auto'},
    #             style_cell={'textAlign': 'left', 'padding': '10px'},
    #             style_data_conditional=[
    #                 {
    #                     'if': {'filter_query': '{Profit %} contains "-"'},
    #                     'color': 'red'
    #                 },
    #                 {
    #                     'if': {'filter_query': '{Profit %} contains "%"', 'column_id': 'Profit %'},
    #                     'color': 'green'
    #                 }
    #             ],
    #             style_header={
    #                 'backgroundColor': 'rgb(240, 240, 240)',
    #                 'fontWeight': 'bold'
    #             },
    #             sort_action='native',
    #             page_size=15
    #         )
            
    #         components.append(html.Div([
    #             html.H3("All Backtesting Results", className="text-xl font-semibold mt-6 mb-3"),
    #             summary_table
    #         ]))
        
    #     return html.Div(components, className="p-4 bg-white rounded shadow-sm")





    def create_capital_growth_chart(result_details, ticker, indicator):
        if not result_details or 'trades' not in result_details:
            return go.Figure(layout=go.Layout(title=f"Tidak ada data trade untuk {ticker} - {indicator}"))

        trades = result_details['trades']
        initial_capital = result_details['initial_capital']
        
        dates = [trade['entry_date'] for trade in trades] + [trade['exit_date'] for trade in trades]
        dates = sorted(list(set(dates)))
        
        capital_over_time = {result_details['start_date']: initial_capital}
        
        current_capital = initial_capital
        for trade in trades:
            # Sebelum masuk, modal tetap
            capital_over_time[trade['entry_date']] = current_capital
            
            # Setelah keluar, modal berubah
            current_capital += trade['profit']
            capital_over_time[trade['exit_date']] = current_capital

        # Sort by date
        sorted_capital = sorted(capital_over_time.items())
        x_dates = [item[0] for item in sorted_capital]
        y_capital = [item[1] for item in sorted_capital]
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=x_dates, y=y_capital, mode='lines+markers', name='Capital Growth'))
        fig.update_layout(
            title=f"Capital Growth for {ticker} ({indicator})",
            xaxis_title="Date",
            yaxis_title="Capital",
            height=400
        )
        return fig
    



    def create_debug_div(title, data_to_display):
        import json
        try:
            if isinstance(data_to_display, list) and len(data_to_display) > 5:
                display_str = json.dumps(data_to_display[:5], indent=2, default=str) + f"\n... (and {len(data_to_display) - 5} more items)"
            else:
                display_str = json.dumps(data_to_display, indent=2, default=str)
        except Exception:
            display_str = str(data_to_display)
        return html.Div([
            html.H4(f"ðŸž DEBUG: {title}", className="text-lg font-bold text-red-600"),
            html.Pre(display_str, className="bg-gray-100 p-2 rounded text-sm overflow-auto")
        ], className="p-4 border-2 border-dashed border-red-400 my-4")


    # BACKTESTING ANALYSIS SECTION

    def generate_backtesting_analysis_results(all_results):
        """
        Menghasilkan hasil analisis backtesting dengan MENGGUNAKAN DATA YANG SUDAH DIHITUNG.
        Fungsi ini tidak lagi melakukan kalkulasi ulang untuk kombinasi indikator berbeda.
        """
        if not all_results or 'leaderboard' not in all_results or not all_results['leaderboard']:
            return html.Div("Tidak ada data analisis backtesting yang tersedia", className="text-center text-gray-500 p-4")
        
        try:
            # Ekstrak data dari all_results
            ticker_details = all_results.get('ticker_details', {})
            trade_details = all_results.get('trade_details', {})
            
            # Proses data untuk analisis individual (ini tetap diperlukan)
            processed_data = []
            individual_results = []
            
            for ticker, indicators in ticker_details.items():
                for indicator_result in indicators:
                    indicator_name = indicator_result.get('indicator', 'Unknown')
                    trades = trade_details.get(ticker, {}).get(indicator_name, [])
                    
                    # <<<--- BLOK YANG HILANG DAN PERLU DIKEMBALIKAN ---<<<
                    # Konversi trades untuk membuat dropdown filter (tetap dibutuhkan)
                    for trade in trades:
                        try:
                            signal_type = trade.get('type')
                            if signal_type in ['Buy', 'Sell']:
                                processed_data.append({
                                    'Title': ticker,
                                    'Datetime': pd.to_datetime(trade.get('date')),
                                    'Analysis_info': indicator_name,
                                    'Signal': signal_type,
                                    'Price': trade.get('price', 0),
                                    'Volume': trade.get('volume', 1000)
                                })
                        except Exception as trade_error:
                            print(f"Error processing trade for dropdown data: {trade_error}")
                            continue
                    # <<<--- AKHIR BLOK YANG DIKEMBALIKAN ---<<<
                    
                    # Analisis individual indicator (tetap dibutuhkan)
                    try:
                        all_combinations_log = indicator_result.get('all_possible_combinations', [])
                        individual_analysis = analyze_individual_indicator(
                            ticker, indicator_name, trades, indicator_result, all_combinations_log=all_combinations_log
                        )
                        if individual_analysis:
                            individual_results.append(individual_analysis)
                    except Exception as individual_error:
                        print(f"Error in individual analysis for {ticker}-{indicator_name}: {individual_error}")
                        continue
            
            # Ambil hasil kombinasi yang sudah dihitung sebelumnya
            combination_results = all_results.get('different_combination_results', [])
            print(f"UI function received {len(combination_results)} pre-calculated 'different combination' results.")

            if not individual_results and not combination_results:
                return html.Div("Tidak ada data trade yang valid untuk dianalisis.", className="text-center text-gray-500 p-4")
            
            # Konversi ke DataFrame hanya untuk membuat filter dropdown
            # Sekarang df_for_filters akan berisi data karena processed_data sudah diisi
            df_for_filters = pd.DataFrame(processed_data) if processed_data else pd.DataFrame()

            # Jika tidak ada data sama sekali untuk filter, berikan pesan
            if df_for_filters.empty:
                all_tickers = []
                all_indicators = []
            else:
                all_tickers = sorted(df_for_filters['Title'].unique().tolist())
                all_indicators = sorted(df_for_filters['Analysis_info'].unique().tolist())
            
            # Buat kombinasi ticker-indicator untuk dropdown
            ticker_indicator_combinations = []
            for ticker in all_tickers:
                for indicator in all_indicators:
                    if not df_for_filters[(df_for_filters['Title'] == ticker) & (df_for_filters['Analysis_info'] == indicator)].empty:
                        ticker_indicator_combinations.append({
                            'label': f"{ticker} - {indicator}",
                            'value': f"{ticker}|{indicator}"
                        })
            
            # Tambahkan opsi global di awal
            dropdown_options = [
                {'label': 'Analisis Global (Semua Ticker & Strategi)', 'value': 'global'},
                {'label': '--- Filter by Ticker ---', 'value': 'separator', 'disabled': True}
            ]
            
            # Tambahkan opsi per ticker
            for ticker in all_tickers:
                dropdown_options.append({
                    'label': f"Semua Strategi untuk {ticker}",
                    'value': f"ticker:{ticker}"
                })
            
            dropdown_options.append({'label': '--- Filter by Combination ---', 'value': 'separator2', 'disabled': True})
            dropdown_options.extend(ticker_indicator_combinations)
            
            # Buat komponen utama dengan dropdown filter
            main_components = [
                # Header dan Filter Section
                html.Div([
                    html.H2("ðŸ“ˆ Analisis Backtesting Berkelanjutan Lengkap", className="text-2xl font-bold mb-4 text-blue-700"),
                    html.Div([
                        html.P("ðŸ“Š Analisis komprehensif ini mengevaluasi performa strategi trading menggunakan indikator teknikal individual dan kombinasinya.", 
                            className="text-gray-700 mb-3"),
                        html.P("ðŸŽ¯ Sistem menguji berbagai skenario entry dan exit point untuk menemukan strategi optimal dengan return terbaik.", 
                            className="text-gray-700 mb-3"),
                        html.P("ðŸ“‹ Pilih kombinasi untuk melihat analisis spesifik, atau gunakan 'Analisis Global' untuk melihat performa terbaik dari semua ticker dan strategi.", 
                            className="text-gray-600 mb-4"),
                    ]),
                    
                    # Filter Dropdown
                    html.Div([
                        html.Label("ðŸ” Pilih Analisis:", className="block text-sm font-medium text-gray-700 mb-2"),
                        dcc.Dropdown(
                            id='backtesting-analysis-filter',
                            options=dropdown_options,
                            value='global',  # Default ke analisis global
                            className="w-full mb-4",
                            placeholder="Pilih ticker dan strategi untuk analisis..."
                        )
                    ], className="mb-6 p-4 bg-gray-50 rounded-lg border")
                ], className="mb-6"),
                
                # Container untuk hasil yang akan diupdate berdasarkan filter
                html.Div(id='filtered-backtesting-results', className="min-h-96")
            ]
            
            # Generate hasil global sebagai default dengan penjelasan lengkap
            global_results = generate_enhanced_global_analysis_results(
                df_for_filters, ticker_details, all_tickers, all_indicators, individual_results, combination_results
            )
            
            # Generate section detail transaksi
            detailed_transaction_section = generate_detailed_transaction_section_with_charts(
                individual_results, combination_results, ticker_details, trade_details
            )
            
            # Store semua data untuk callback (sekarang sudah konsisten)
            analysis_data_store = html.Div(
                id='backtesting-analysis-data-store',
                style={'display': 'none'},
                children=json.dumps({
                    'processed_data': processed_data,
                    'ticker_details': ticker_details,
                    'trade_details': trade_details,
                    'all_tickers': all_tickers,
                    'all_indicators': all_indicators,
                    'individual_results': individual_results,
                    'combination_results': combination_results # Ini sekarang berisi data yang benar
                }, default=str)
            )
                
            return html.Div([
                analysis_data_store,
                html.Div(main_components),
                html.Div(global_results, id='initial-global-results'),
                detailed_transaction_section
            ], className="p-4 bg-white rounded shadow-sm")

        except Exception as e:
            return html.Div([
                html.H3("âŒ Error", className="text-xl font-bold text-red-600 mb-2"),
                html.P(f"Terjadi kesalahan selama menampilkan analisis: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="bg-gray-100 p-4 rounded text-sm mt-2")
            ])


    def generate_detailed_transaction_section_with_charts(individual_results, combination_results, ticker_details, trade_details):
        """Generate section untuk detail transaksi yang lengkap dengan line chart dan dropdown collapsible"""
        if not individual_results and not combination_results:
            return html.Div("Tidak ada data transaksi yang tersedia", className="text-center text-gray-500 p-4")
        
        # Format individual results untuk display dengan price data
        formatted_individual_results = []
        for result in individual_results:
            if result.get('trade_pairs'):
                # Ambil data price untuk ticker ini
                ticker = result['ticker']
                indicator = result['indicator']
                trades = trade_details.get(ticker, {}).get(indicator, [])
                
                # Buat formatted trades dengan informasi lebih lengkap
                formatted_trades = []
                price_data = []  # Untuk line chart
                
                for trade_pair in result['trade_pairs']:
                    formatted_trades.append({
                        'Entry Date': trade_pair['buy_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade_pair['buy_date'], 'strftime') else str(trade_pair['buy_date']),
                        'Entry Price': f"{trade_pair['buy_price']:.2f}",
                        'Exit Date': trade_pair['sell_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade_pair['sell_date'], 'strftime') else str(trade_pair['sell_date']),
                        'Exit Price': f"{trade_pair['sell_price']:.2f}",
                        'Shares': trade_pair['shares'],
                        'Profit/Loss': f"{trade_pair['profit']:.2f}",
                        'Return %': f"{trade_pair['price_change']:.2f}%",
                        'Holding Period': f"{trade_pair['holding_period']} hari"
                    })
                    
                    # Tambahkan data untuk line chart
                    price_data.append({
                        'date': trade_pair['buy_date'],
                        'price': trade_pair['buy_price'],
                        'type': 'Buy'
                    })
                    price_data.append({
                        'date': trade_pair['sell_date'],
                        'price': trade_pair['sell_price'],
                        'type': 'Sell'
                    })
                
                # Buat line chart untuk strategi ini
                line_chart = create_transaction_line_chart(ticker, indicator, price_data, trades)

                volume_summary = result.get('volume_analysis_summary', 'Analisis volume tidak tersedia.')
                # Cari hasil asli dari ticker_details untuk mendapatkan volume_summary
                # if ticker in ticker_details and indicator in [d['indicator'] for d in ticker_details[ticker]]:
                #     original_result = next((item for item in ticker_details[ticker] if item["indicator"] == indicator), None)
                #     if original_result:
                #         volume_summary = original_result.get('volume_analysis_summary', volume_summary)
                
                formatted_individual_results.append({
                    'Strategy': f"{result['ticker']} - {result['indicator']}",
                    'Ticker': result['ticker'],
                    'Indicator': result['indicator'],
                    'Trades': formatted_trades,
                    'Total Return': result['return_percentage'],
                    'Win Rate': result['win_rate'],
                    'Total Trades': result['total_trades'],
                    'Line Chart': line_chart,
                    'Price Data': price_data,
                    'volume_analysis_summary': volume_summary
                })
        
        # Format combination results untuk display
        formatted_combination_results = []
        for result in combination_results:
            if result.get('trades'):
                ticker = result['ticker']
                indicator = result.get('strategy', 'Combination')
                
                formatted_trades = []
                price_data = []
                
                for trade in result['trades']:
                    formatted_trades.append({
                        'Entry Date': trade['entry_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['entry_date'], 'strftime') else str(trade['entry_date']),
                        'Entry Price': f"{trade['entry_price']:.2f}",
                        'Exit Date': trade['exit_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['exit_date'], 'strftime') else str(trade['exit_date']),
                        'Exit Price': f"{trade['exit_price']:.2f}",
                        'Shares': trade['shares'],
                        'Profit/Loss': f"{trade['profit']:.2f}",
                        'Return %': f"{trade['return_pct']:.2f}%",
                        'Buy Indicator': trade.get('buy_indicator', ''),
                        'Sell Indicator': trade.get('sell_indicator', ''),
                        'Holding Period': f"{trade.get('holding_period', 0)} hari"
                    })
                    
                    price_data.append({
                        'date': trade['entry_date'],
                        'price': trade['entry_price'],
                        'type': 'Buy'
                    })
                    price_data.append({
                        'date': trade['exit_date'],
                        'price': trade['exit_price'],
                        'type': 'Sell'
                    })
                
                # Buat line chart untuk kombinasi ini
                line_chart = create_combination_line_chart(ticker, result['strategy'], price_data)

                volume_summary = result.get('volume_analysis_summary', 'Analisis volume tidak tersedia.')
                # Cari hasil asli dari ticker_details untuk mendapatkan volume_summary
                # if ticker in ticker_details and indicator in [d['indicator'] for d in ticker_details[ticker]]:
                #     original_result = next((item for item in ticker_details[ticker] if item["indicator"] == indicator), None)
                #     if original_result:
                #         volume_summary = original_result.get('volume_analysis_summary', volume_summary)
                
                formatted_combination_results.append({
                    'Strategy': result['strategy'],
                    'Ticker': result['ticker'],
                    'Trades': formatted_trades,
                    'Total Return': result['return_percentage'],
                    'Win Rate': result['win_rate'],
                    'Total Trades': result['total_trades'],
                    'Line Chart': line_chart,
                    'Price Data': price_data,
                    'volume_analysis_summary': volume_summary
                })
        
        # Sort berdasarkan return
        formatted_individual_results = sorted(formatted_individual_results, key=lambda x: x['Total Return'], reverse=True)
        formatted_combination_results = sorted(formatted_combination_results, key=lambda x: x['Total Return'], reverse=True)

        # all_strategies_for_volume_tab = individual_results + combination_results
        # strategy_options = sorted(
        #     [{'label': s['strategy'], 'value': s['strategy']} 
        #     for s in all_strategies_for_volume_tab if s.get('detailed_combinations_log')], # Hanya tampilkan yang punya data detail
        #     key=lambda x: x['label']
        # )

        # ekstrak ticker dan indikator yang unik
        all_analyzed_tickers = set(r['ticker'] for r in individual_results + combination_results)
        all_analyzed_indicators = set(r.get('indicator', r.get('buy_indicator')) for r in individual_results + combination_results)
        all_analyzed_indicators.update(set(r.get('sell_indicator') for r in combination_results if r.get('sell_indicator')))
        
        strategy_options = []
        # Buat SEMUA kemungkinan kombinasi untuk dropdown
        for ticker in sorted(list(all_analyzed_tickers)):
            # Tambahkan strategi individual
            for indicator in sorted(list(all_analyzed_indicators)):
                strategy_name = f"{ticker} - {indicator}"
                strategy_options.append({'label': strategy_name, 'value': strategy_name})
            
            # Tambahkan strategi kombinasi
            for buy_indicator in sorted(list(all_analyzed_indicators)):
                for sell_indicator in sorted(list(all_analyzed_indicators)):
                    if buy_indicator == sell_indicator: continue
                    strategy_name = f"{ticker} - {buy_indicator} (Buy) + {sell_indicator} (Sell)"
                    strategy_options.append({'label': strategy_name, 'value': strategy_name})
        
        # Hapus duplikat jika ada
        # strategy_options = [dict(t) for t in {tuple(d.items()) for d in strategy_options}]
        # strategy_options = sorted(strategy_options, key=lambda x: x['label'])
        
        all_strategies = individual_results + combination_results
    
        # BARU: Buat opsi dropdown dengan "Top Performers" sebagai pilihan pertama
        strategy_options = [{'label': 'ðŸ† Top Performers Leaderboard', 'value': 'top_performers'}]
        strategy_options.extend(sorted(
            [{'label': s['strategy'], 'value': s['strategy']} for s in all_strategies],
            key=lambda x: x['label']
        ))
        
        return html.Div([
            html.Div([
                html.H2("ðŸ“‹ Detail Transaksi Lengkap dengan Analisis Chart", className="text-2xl font-bold mb-4 text-blue-700"),
                html.P("Bagian ini menampilkan detail lengkap dari setiap transaksi yang dilakukan oleh strategi individual dan kombinasi, dilengkapi dengan line chart untuk melihat sebaran sinyal dan posisi price.", 
                    className="text-gray-700 mb-4"),
                
                dcc.Tabs([
                    # Tab untuk Individual Indicator Trades dengan Line Chart
                    dcc.Tab(label="ðŸ’¡ Transaksi Strategi Individual", 
                        className="font-semibold py-3 px-4",
                        selected_className="bg-green-50 border-t-2 border-green-600",
                        children=[
                        html.Div([
                            html.H3("ðŸ“Š Transaksi Strategi Individual dengan Line Chart", className="text-xl font-bold mb-4 text-green-700"),
                            html.P(f"Menampilkan detail transaksi dari {len(formatted_individual_results)} strategi individual terbaik dengan visualisasi price chart.", 
                                className="text-gray-600 mb-4"),
                            
                            # Accordion untuk setiap strategi individual dengan collapsible line chart
                            html.Div([
                                create_collapsible_strategy_section(result, i, "individual")
                                for i, result in enumerate(formatted_individual_results[:10])  # Tampilkan top 10
                            ])
                        ], className="mt-4")
                    ]),

                    # Tab untuk Combination Strategy Trades dengan Line Chart
                    dcc.Tab(label="ðŸ”— Transaksi Strategi Kombinasi", 
                        className="font-semibold py-3 px-4",
                        selected_className="bg-purple-50 border-t-2 border-purple-600",
                        children=[
                        html.Div([
                            html.H3("ðŸ“Š Transaksi Strategi Kombinasi dengan Line Chart", className="text-xl font-bold mb-4 text-purple-700"),
                            html.P(f"Menampilkan detail transaksi dari {len(formatted_combination_results)} strategi kombinasi terbaik dengan visualisasi price chart.", 
                                className="text-gray-600 mb-4"),
                            
                            # Accordion untuk setiap strategi kombinasi dengan collapsible line chart
                            html.Div([
                                create_collapsible_strategy_section(combo, i, "combination")
                                for i, combo in enumerate(formatted_combination_results[:10])  # Tampilkan top 10
                            ])
                        ], className="mt-4")
                    ]),
                    
                    # Tab untuk Summary Comparison dengan Chart Overview
                    dcc.Tab(label="ðŸ“ˆ Perbandingan Summary & Chart Overview", 
                        className="font-semibold py-3 px-4",
                        selected_className="bg-blue-50 border-t-2 border-blue-600",
                        children=[
                        html.Div([
                            html.H3("ðŸ“Š Perbandingan Performa Semua Strategi & Chart Overview", className="text-xl font-bold mb-4 text-blue-700"),
                            
                            # Chart Overview semua strategi
                            html.Div([
                                html.H4("ðŸ“ˆ Overview Chart Semua Strategi Terbaik", className="text-lg font-semibold mb-3"),
                                create_strategies_overview_chart(formatted_individual_results[:5], formatted_combination_results[:5])
                            ], className="mb-6"),
                            
                            # Tabel perbandingan semua strategi
                            html.Div([
                                html.H4("ðŸ† Top 20 Strategi Terbaik (Individual + Kombinasi)", className="text-lg font-semibold mb-3"),
                                
                                # Gabungkan dan sort semua strategi
                                dash_table.DataTable(
                                    data=[{
                                        'Rank': i+1,
                                        'Type': 'Individual',
                                        'Strategy': result['Strategy'],
                                        'Total Return': f"{result['Total Return']:.2f}%",
                                        'Win Rate': f"{result['Win Rate']:.1f}%",
                                        'Total Trades': result['Total Trades']
                                    } for i, result in enumerate(formatted_individual_results[:10])] +
                                    [{
                                        'Rank': i+len(formatted_individual_results[:10])+1,
                                        'Type': 'Combination',
                                        'Strategy': result['Strategy'],
                                        'Total Return': f"{result['Total Return']:.2f}%",
                                        'Win Rate': f"{result['Win Rate']:.1f}%",
                                        'Total Trades': result['Total Trades']
                                    } for i, result in enumerate(formatted_combination_results[:10])],
                                    columns=[
                                        {'name': '#', 'id': 'Rank'},
                                        {'name': 'Type', 'id': 'Type'},
                                        {'name': 'Strategy', 'id': 'Strategy'},
                                        {'name': 'Total Return', 'id': 'Total Return'},
                                        {'name': 'Win Rate', 'id': 'Win Rate'},
                                        {'name': 'Total Trades', 'id': 'Total Trades'}
                                    ],
                                    style_table={'overflowX': 'auto'},
                                    style_cell={'textAlign': 'left', 'padding': '10px'},
                                    style_header={
                                        'backgroundColor': 'rgb(240, 240, 240)',
                                        'fontWeight': 'bold'
                                    },
                                    style_data_conditional=[
                                        {
                                            'if': {'filter_query': '{Type} = "Individual"'},
                                            'backgroundColor': 'rgba(34, 197, 94, 0.1)'
                                        },
                                        {
                                            'if': {'filter_query': '{Type} = "Combination"'},
                                            'backgroundColor': 'rgba(147, 51, 234, 0.1)'
                                        },
                                        {
                                            'if': {'filter_query': '{Total Return} contains "-"'},
                                            'color': 'red'
                                        },
                                        {
                                            'if': {'filter_query': '{Total Return} > "0"'},
                                            'color': 'green'
                                        }
                                    ],
                                    sort_action='native',
                                    page_size=20
                                )
                            ], className="mb-6"),
                            
                            # Insight summary
                            html.Div([
                                html.H4("ðŸ’¡ Ringkasan Insights", className="text-lg font-semibold mb-3"),
                                html.Div([
                                    html.P([
                                        "ðŸ“Š Total strategi yang dianalisis: ",
                                        html.Strong(f"{len(formatted_individual_results)} individual"),
                                        " dan ",
                                        html.Strong(f"{len(formatted_combination_results)} kombinasi"),
                                        " strategi."
                                    ], className="mb-2"),
                                    html.P([
                                        "ðŸŽ¯ Strategi terbaik: ",
                                        html.Strong(formatted_individual_results[0]['Strategy'] if formatted_individual_results and 
                                                (not formatted_combination_results or formatted_individual_results[0]['Total Return'] >= formatted_combination_results[0]['Total Return'])
                                                else (formatted_combination_results[0]['Strategy'] if formatted_combination_results else 'N/A')),
                                        " dengan return ",
                                        html.Strong(f"{max([r['Total Return'] for r in formatted_individual_results + formatted_combination_results]):.2f}%" if (formatted_individual_results or formatted_combination_results) else "0%"),
                                        "."
                                    ], className="mb-2"),
                                    html.P([
                                        "ðŸ“ˆ Rata-rata win rate: ",
                                        html.Strong(f"{sum([r['Win Rate'] for r in formatted_individual_results + formatted_combination_results]) / len(formatted_individual_results + formatted_combination_results):.1f}%" if (formatted_individual_results or formatted_combination_results) else "0%"),
                                        "."
                                    ], className="mb-2")
                                ], className="p-4 bg-blue-50 rounded-lg border border-blue-200")
                            ])
                        ], className="mt-4")
                    ]),

                    dcc.Tab(label="ðŸ” Analisis Volume & Siklus", value="tab-volume",
                        className="font-semibold py-3 px-4",
                        selected_className="bg-blue-50 border-t-2 border-blue-600",
                        children=[
                            html.Div(className="p-4 bg-gray-50", children=[
                                html.H3("Analisis Mendalam per Siklus Trading", className="text-xl font-bold mb-2 text-gray-800"),
                                html.P("Pilih strategi untuk melihat semua siklus trading yang dieksekusi. "
                                    "Kemudian, pilih siklus untuk membedah semua kemungkinan pasangan trade di dalamnya dan melihat mengapa sistem memilih yang terbaik.",
                                    className="text-gray-600 mb-4"),

                                
                                # html.Label("Pilih Tampilan:", className="font-semibold"),
                                #     dcc.Dropdown(
                                #         id='volume-strategy-selector',
                                #         options=strategy_options,
                                #         value='top_performers', # Default ke Top Performers
                                #         className="mb-6"
                                #     ),
                                    
                                    # --- KONTENER UNTUK TOP PERFORMERS ---
                                    html.Div(
                                        id='top-performers-container',
                                        style={'display': 'block'}, # Terlihat secara default
                                        children=[
                                            html.Label("Tampilkan Top:", className="font-semibold mr-2"),
                                            dcc.Dropdown(
                                                id='top-performers-limit-selector',
                                                options=[{'label': f'Top {n}', 'value': n} for n in [5, 10, 20]],
                                                value=10,
                                                clearable=False,
                                                style={'width': '150px'}
                                            ),
                                            html.Div(id='top-performers-content', className="mt-4")
                                        ]
                                    ),
                                
                                # Dropdown untuk memilih STRATEGI
                                html.Label("Pilih Strategi:", className="font-semibold"),
                                dcc.Dropdown(
                                    id='volume-strategy-selector',
                                    options=strategy_options,
                                    placeholder="Pilih strategi untuk dianalisis...",
                                    className="mb-4"
                                ),
                                
                                # Dropdown untuk memilih SIKLUS (akan diisi oleh callback)
                                html.Label("Pilih Siklus Trading:", className="font-semibold"),
                                dcc.Dropdown(
                                    id='volume-cycle-selector',
                                    placeholder="Pilih strategi terlebih dahulu...",
                                    className="mb-4"
                                ),
                                
                                # Kontainer untuk menampilkan hasil analisis detail
                                dcc.Loading(
                                    id="loading-volume-analysis",
                                    type="circle",
                                    children=html.Div(id='volume-analysis-detail-content', className="mt-4 min-h-96")
                                )
                            ])
                        ]),


                ])
            ], className="mt-6 mb-6 p-4 bg-white rounded shadow-sm")
        ])


    def create_collapsible_strategy_section(result, index, strategy_type):
        """Buat section collapsible untuk setiap strategi dengan line chart"""
        strategy_id = f"{strategy_type}-strategy-{index}"
        color_class = "green" if strategy_type == "individual" else "purple"


        # formatted_trades = []
        # if strategy_type == "individual":
        #     for trade_pair in result.get('Trades', []):
        #         formatted_trades.append({
        #             'Entry Date': pd.to_datetime(trade_pair['buy_date']).strftime('%Y-%m-%d %H:%M'),
        #             'Entry Price': f"{trade_pair['buy_price']:.2f}",
        #             'Exit Date': pd.to_datetime(trade_pair['sell_date']).strftime('%Y-%m-%d %H:%M'),
        #             'Exit Price': f"{trade_pair['sell_price']:.2f}",
        #             'Shares': trade_pair['shares'],
        #             'Profit/Loss': f"{trade_pair['profit']:.2f}",
        #             'Return %': f"{trade_pair['price_change']:.2f}%",
        #             'Holding Period': f"{trade_pair['holding_period']} hari"
        #         })
        # else: # Combination
        #     for trade in result.get('Trades', []):
        #         formatted_trades.append({
        #             'Entry Date': pd.to_datetime(trade['entry_date']).strftime('%Y-%m-%d %H:%M'),
        #             'Entry Price': f"{trade['entry_price']:.2f}",
        #             'Exit Date': pd.to_datetime(trade['exit_date']).strftime('%Y-%m-%d %H:%M'),
        #             'Exit Price': f"{trade['exit_price']:.2f}",
        #             'Shares': trade['shares'],
        #             'Profit/Loss': f"{trade['profit']:.2f}",
        #             'Return %': f"{trade.get('return_pct', 0):.2f}%",
        #             'Holding Period': f"{trade.get('holding_period', 0)} hari"
        #         })

        
        return html.Div([
            # Clickable header
            html.Div([
                html.Div([
                    html.H4(f"ðŸŽ¯ {result['Strategy']}", className=f"text-lg font-semibold mb-2 text-{color_class}-600"),
                    html.Div([
                        html.Div([
                            html.Span("Total Return: ", className="font-semibold"),
                            html.Span(f"{result['Total Return']:.2f}%", 
                                    className=f"ml-1 font-bold {'text-green-600' if result['Total Return'] >= 0 else 'text-red-600'}")
                        ], className="mr-4"),
                        html.Div([
                            html.Span("Win Rate: ", className="font-semibold"),
                            html.Span(f"{result['Win Rate']:.1f}%", className="ml-1 text-blue-600")
                        ], className="mr-4"),
                        html.Div([
                            html.Span("Total Trades: ", className="font-semibold"),
                            html.Span(f"{result['Total Trades']}", className="ml-1 text-gray-700")
                        ])
                    ], className="flex mb-3"),
                    html.I(className="fas fa-chevron-down", id={'type': f'{strategy_type}-chevron', 'index': strategy_id})
                ], className="flex-1"),
            ], 
            id={'type': f'{strategy_type}-header', 'index': strategy_id},
            className=f"p-3 bg-{color_class}-50 rounded-lg border border-{color_class}-200 mb-2 cursor-pointer hover:bg-{color_class}-100 flex justify-between items-center"),
            
            # Collapsible content
            html.Div([
                # Line Chart Section
                html.Div([
                    html.H5("ðŸ“ˆ Price Chart dengan Sinyal Transaksi", className="text-md font-semibold mb-3"),
                    html.P("Chart di bawah menunjukkan pergerakan harga dan posisi sinyal buy/sell pada timeline.", 
                        className="text-sm text-gray-600 mb-3"),
                    result['Line Chart']
                ], className="mb-6"),
                
                # Detailed Transaction Table
                html.Div([
                    html.H5("ðŸ“‹ Detail Transaksi", className="text-md font-semibold mb-3"),
                    dash_table.DataTable(
                        data=result['Trades'],
                        columns=[
                            {'name': col, 'id': col} for col in [
                                'Entry Date', 'Entry Price', 'Exit Date', 'Exit Price',
                                'Shares', 'Profit/Loss', 'Return %', 'Holding Period'
                            ] + (['Buy Indicator', 'Sell Indicator'] if strategy_type == "combination" else [])
                        ],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '12px'},
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{Profit/Loss} contains "-"'},
                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                'color': 'red'
                            },
                            {
                                'if': {'filter_query': '{Profit/Loss} > "0.00"'},
                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                'color': 'green'
                            }
                        ],
                        sort_action='native',
                        page_size=15,
                        filter_action='native'
                    )
                ]),
                html.Div([
                    html.H5("ðŸ“Š Analisis Dampak Volume", className="text-md font-semibold mb-3 mt-6"),
                    html.P(
                        "Analisis ini mengkaji hubungan antara volume trading (saat sinyal Beli/Jual muncul) dengan probabilitas profit. "
                        "Ini membantu mengidentifikasi apakah volume tinggi adalah konfirmasi yang baik untuk sebuah sinyal.",
                        className="text-sm text-gray-600 mb-3"
                    ),
                    html.Div([
                        html.I(className="fas fa-info-circle mr-2 text-blue-500"),
                        html.Span(
                            result.get('volume_analysis_summary', 'Data analisis volume tidak ditemukan.'),
                            className="text-sm"
                        )
                    ], className="p-4 bg-blue-50 border-l-4 border-blue-500 text-blue-800 rounded")
                ], className="mt-4")


            ], 
            id={'type': f'{strategy_type}-content', 'index': strategy_id},
            className="bg-white p-4 border rounded-b shadow-sm",
            style={'display': 'none'}  # Initially hidden
            )
        ], className="mb-4")


    def create_transaction_line_chart(ticker, indicator, price_data, trades):
        """Buat line chart untuk menampilkan transaksi individual strategy - ENHANCED"""
        if not price_data and not trades:
            return dcc.Graph(figure=go.Figure(layout=go.Layout(title=f"No data available for {ticker} - {indicator}")))
        
        fig = go.Figure()
        
        # Buat data price line dari trades dengan validasi yang lebih baik
        all_dates = []
        all_prices = []
        buy_dates = []
        buy_prices = []
        sell_dates = []
        sell_prices = []
        
        # Validasi dan konversi data trades
        for trade in trades:
            try:
                date = pd.to_datetime(trade['date'])
                price = float(trade['price'])
                
                # Validasi price
                if price <= 0 or not np.isfinite(price):
                    continue
                    
                all_dates.append(date)
                all_prices.append(price)
                
                if trade['type'] == 'Buy':
                    buy_dates.append(date)
                    buy_prices.append(price)
                elif trade['type'] == 'Sell':
                    sell_dates.append(date)
                    sell_prices.append(price)
            except (ValueError, TypeError, KeyError) as e:
                print(f"Error processing trade data: {e}")
                continue
        
        # Urutkan data berdasarkan tanggal untuk line yang smooth
        if all_dates:
            sorted_data = sorted(zip(all_dates, all_prices))
            sorted_dates = [item[0] for item in sorted_data]
            sorted_prices = [item[1] for item in sorted_data]
            
            # Tambahkan price line
            fig.add_trace(go.Scatter(
                x=sorted_dates,
                y=sorted_prices,
                mode='lines',
                name='Price Movement',
                line=dict(color='lightblue', width=2),
                hovertemplate='Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
            ))
        
        # Tambahkan Buy signals
        if buy_dates:
            fig.add_trace(go.Scatter(
                x=buy_dates,
                y=buy_prices,
                mode='markers',
                name='Buy Signal',
                marker=dict(
                    symbol='triangle-up',
                    size=12,
                    color='green',
                    line=dict(width=2, color='darkgreen')
                ),
                hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
            ))
        
        # Tambahkan Sell signals
        if sell_dates:
            fig.add_trace(go.Scatter(
                x=sell_dates,
                y=sell_prices,
                mode='markers',
                name='Sell Signal',
                marker=dict(
                    symbol='triangle-down',
                    size=12,
                    color='red',
                    line=dict(width=2, color='darkred')
                ),
                hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
            ))
        
        fig.update_layout(
            title=f"Price Chart dengan Sinyal Transaksi: {ticker} - {indicator}",
            xaxis_title="Tanggal",
            yaxis_title="Harga",
            height=400,
            template="plotly_white",
            hovermode='x unified',
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            )
        )
        
        return dcc.Graph(figure=fig, config={'displayModeBar': True})


    def create_combination_line_chart(ticker, strategy, price_data):
        """Buat line chart untuk menampilkan transaksi combination strategy"""
        if not price_data:
            return dcc.Graph(figure=go.Figure(layout=go.Layout(title=f"No data available for {ticker} - {strategy}")))
        
        fig = go.Figure()
        
        # Pisahkan data berdasarkan type
        all_dates = [item['date'] for item in price_data]
        all_prices = [item['price'] for item in price_data]
        buy_data = [item for item in price_data if item['type'] == 'Buy']
        sell_data = [item for item in price_data if item['type'] == 'Sell']
        
        # Urutkan data berdasarkan tanggal
        if all_dates:
            sorted_data = sorted(zip(all_dates, all_prices))
            sorted_dates = [item[0] for item in sorted_data]
            sorted_prices = [item[1] for item in sorted_data]
            
            # Tambahkan price line
            fig.add_trace(go.Scatter(
                x=sorted_dates,
                y=sorted_prices,
                mode='lines',
                name='Price Movement',
                line=dict(color='lightblue', width=2),
                hovertemplate='Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
            ))
        
        # Tambahkan Buy signals
        if buy_data:
            fig.add_trace(go.Scatter(
                x=[item['date'] for item in buy_data],
                y=[item['price'] for item in buy_data],
                mode='markers',
                name='Buy Signal',
                marker=dict(
                    symbol='triangle-up',
                    size=12,
                    color='green',
                    line=dict(width=2, color='darkgreen')
                ),
                hovertemplate='Buy Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
            ))
        
        # Tambahkan Sell signals
        if sell_data:
            fig.add_trace(go.Scatter(
                x=[item['date'] for item in sell_data],
                y=[item['price'] for item in sell_data],
                mode='markers',
                name='Sell Signal',
                marker=dict(
                    symbol='triangle-down',
                    size=12,
                    color='red',
                    line=dict(width=2, color='darkred')
                ),
                hovertemplate='Sell Signal<br>Date: %{x}<br>Price: %{y:.2f}<extra></extra>'
            ))
        
        fig.update_layout(
            title=f"Price Chart dengan Sinyal Transaksi: {ticker} - {strategy}",
            xaxis_title="Tanggal",
            yaxis_title="Harga",
            height=400,
            template="plotly_white",
            hovermode='x unified',
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            )
        )
        
        return dcc.Graph(figure=fig, config={'displayModeBar': True})


    def create_strategies_overview_chart(individual_results, combination_results):
        """Buat overview chart untuk membandingkan semua strategi terbaik"""
        fig = go.Figure()
        
        # Gabungkan data untuk overview
        all_strategies = []
        
        # Tambahkan individual strategies
        for result in individual_results:
            if result.get('Price Data'):
                all_strategies.append({
                    'name': f"IND: {result['Strategy'][:20]}...",
                    'ticker': result['Ticker'],
                    'type': 'Individual',
                    'return': result['Total Return'],
                    'price_data': result['Price Data']
                })
        
        # Tambahkan combination strategies
        for result in combination_results:
            if result.get('Price Data'):
                all_strategies.append({
                    'name': f"COMB: {result['Strategy'][:20]}...",
                    'ticker': result['Ticker'],
                    'type': 'Combination', 
                    'return': result['Total Return'],
                    'price_data': result['Price Data']
                })
        
        # Plot untuk setiap strategi dengan warna berbeda
        colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'olive', 'cyan']
        
        for i, strategy in enumerate(all_strategies):
            price_data = strategy['price_data']
            if price_data:
                dates = [item['date'] for item in price_data]
                prices = [item['price'] for item in price_data]
                
                # Sort by date
                sorted_data = sorted(zip(dates, prices))
                sorted_dates = [item[0] for item in sorted_data]
                sorted_prices = [item[1] for item in sorted_data]
                
                color = colors[i % len(colors)]
                fig.add_trace(go.Scatter(
                    x=sorted_dates,
                    y=sorted_prices,
                    mode='lines+markers',
                    name=f"{strategy['name']} ({strategy['return']:.1f}%)",
                    line=dict(color=color, width=2),
                    marker=dict(size=6),
                    hovertemplate=f"{strategy['name']}<br>Date: %{{x}}<br>Price: %{{y:.2f}}<br>Return: {strategy['return']:.2f}%<extra></extra>"
                ))
        
        fig.update_layout(
            title="Overview Chart: Top 5 Individual vs Top 5 Combination Strategies",
            xaxis_title="Tanggal",
            yaxis_title="Harga",
            height=500,
            template="plotly_white",
            hovermode='x unified',
            legend=dict(
                orientation="v",
                yanchor="top",
                y=1,
                xanchor="left",
                x=1.02
            )
        )
        
        return dcc.Graph(figure=fig, config={'displayModeBar': True})


    # Tambahkan callback untuk collapsible sections
    @app.callback(
        [Output({'type': 'individual-content', 'index': MATCH}, "style"),
        Output({'type': 'individual-chevron', 'index': MATCH}, "className")],
        [Input({'type': 'individual-header', 'index': MATCH}, "n_clicks")],
        [State({'type': 'individual-content', 'index': MATCH}, "style")],
        prevent_initial_call=True
    )
    def toggle_individual_strategy_collapse(n_clicks, current_style):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate
        
        is_open = current_style and current_style.get('display') == 'block'
        
        if is_open:
            new_style = {'display': 'none'}
            new_icon_class = "fas fa-chevron-down"
        else:
            new_style = {'display': 'block'}
            new_icon_class = "fas fa-chevron-up"
        
        return new_style, new_icon_class


    @app.callback(
        [Output({'type': 'combination-content', 'index': MATCH}, "style"),
        Output({'type': 'combination-chevron', 'index': MATCH}, "className")],
        [Input({'type': 'combination-header', 'index': MATCH}, "n_clicks")],
        [State({'type': 'combination-content', 'index': MATCH}, "style")],
        prevent_initial_call=True
    )
    def toggle_combination_strategy_collapse(n_clicks, current_style):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate
        
        is_open = current_style and current_style.get('display') == 'block'
        
        if is_open:
            new_style = {'display': 'none'}
            new_icon_class = "fas fa-chevron-down"
        else:
            new_style = {'display': 'block'}
            new_icon_class = "fas fa-chevron-up"
        
        return new_style, new_icon_class

    # fungsi menampilkan hasil backtesting
    def generate_enhanced_global_analysis_results(df, ticker_details, all_tickers, all_indicators, individual_results, combination_results):
        """Generate hasil analisis global yang diperkaya dengan penjelasan lengkap - FIXED SAFELY"""
        try:
            # Enrich individual_results
            for result in individual_results:
                ticker = result.get('ticker')
                indicator = result.get('indicator')
                if ticker and indicator and ticker in ticker_details:
                    # Cari hasil original dari backtest berdasarkan ticker dan indicator
                    original_result = next((item for item in ticker_details.get(ticker, []) if item.get('indicator') == indicator), None)
                    if original_result:
                        # Salin volume_analysis_summary yang hilang ke dalam dictionary 'result'
                        result['volume_analysis_summary'] = original_result.get('volume_analysis_summary', 'N/A')
                        result['num_executed_cycles'] = original_result.get('num_executed_cycles', result.get('total_trades'))

            # Enrich combination_results (dengan logika yang sama)
            for result in combination_results:
                ticker = result.get('ticker')
                # Untuk kombinasi, 'indicator'nya adalah nama 'strategy' itu sendiri
                indicator = result.get('strategy') 
                if ticker and indicator and ticker in ticker_details:
                    original_result = next((item for item in ticker_details.get(ticker, []) if item.get('indicator') == indicator), None)
                    if original_result:
                        result['volume_analysis_summary'] = original_result.get('volume_analysis_summary', 'N/A')
                        # Untuk kombinasi, kita asumsikan total_trades adalah jumlah siklusnya
                        result['num_executed_cycles'] = result.get('total_trades')



            components = []
            
            # === RINGKASAN EKSEKUTIF ===
            components.append(html.Div([
                html.H3("ðŸ“‹ Ringkasan Eksekutif", className="text-xl font-bold mb-3 text-blue-700"),
                html.Div([
                    html.Div([
                        html.Div([
                            html.Span("Total Ticker Dianalisis", className="block text-sm text-gray-500"),
                            html.Span(f"{len(all_tickers)}", className="block text-2xl font-bold text-blue-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Indikator Teknikal", className="block text-sm text-gray-500"),
                            html.Span(f"{len(all_indicators)}", className="block text-2xl font-bold text-green-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Strategi Individual", className="block text-sm text-gray-500"),
                            html.Span(f"{len(individual_results)}", className="block text-2xl font-bold text-purple-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Strategi Kombinasi", className="block text-sm text-gray-500"),
                            html.Span(f"{len(combination_results)}", className="block text-2xl font-bold text-orange-600")
                        ], className="p-4 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/4 px-2"),
                ], className="flex -mx-2 mb-6"),
                
                # Penjelasan metodologi
                html.Div([
                    html.H4("ðŸ”¬ Metodologi Analisis", className="text-lg font-semibold mb-3"),
                    html.P("Sistem melakukan backtesting komprehensif dengan menguji setiap indikator teknikal secara individual maupun dalam kombinasi. "
                        "Analisis mencakup evaluasi entry point, exit point, holding period, dan performa profitabilitas untuk setiap strategi.", 
                        className="text-gray-700 mb-2"),
                    html.P("Kombinasi indikator diuji dengan menggunakan sinyal buy dari satu indikator dan sinyal sell dari indikator lain, "
                        "memberikan fleksibilitas strategi yang lebih beragam dibandingkan pendekatan konvensional.", 
                        className="text-gray-700"),
                ], className="p-4 bg-blue-50 rounded-lg border border-blue-200 mb-6")
            ]))
            
            # === ANALISIS STRATEGI INDIVIDUAL ===
            if individual_results:
                # Sort berdasarkan return percentage - SAFE ACCESS
                individual_results_sorted = sorted(individual_results, 
                                                key=lambda x: x.get('return_percentage', 0), reverse=True)
                
                if individual_results_sorted:
                    best_individual = individual_results_sorted[0]
                    
                    components.append(html.Div([
                        html.H3("ðŸŽ¯ Analisis Strategi Individual", className="text-xl font-bold mb-3 text-green-700"),
                        
                        # Best individual strategy
                        html.Div([
                            html.H4("ðŸ¥‡ Strategi Individual Terbaik", className="text-lg font-semibold mb-2 text-green-600"),
                            html.Div([
                                html.Div([
                                    html.Span("Ticker: ", className="font-semibold"),
                                    html.Span(best_individual.get('ticker', 'N/A'), className="ml-1 text-blue-600 text-lg")
                                ], className="mb-2"),
                                html.Div([
                                    html.Span("Indikator: ", className="font-semibold"),
                                    html.Span(best_individual.get('indicator', 'N/A'), className="ml-1 text-blue-600 text-lg")
                                ], className="mb-2"),
                                html.Div([
                                    html.Span("Return: ", className="font-semibold"),
                                    html.Span(f"{best_individual.get('return_percentage', 0):.2f}%", 
                                            className=f"ml-1 text-lg font-bold {'text-green-600' if best_individual.get('return_percentage', 0) >= 0 else 'text-red-600'}")
                                ], className="mb-2"),
                                html.Div([
                                    html.Span("Win Rate: ", className="font-semibold"),
                                    html.Span(f"{best_individual.get('win_rate', 0):.1f}%", className="ml-1 text-blue-600")
                                ], className="mb-2"),
                            ], className="p-4 bg-gradient-to-r from-green-50 to-blue-50 rounded-lg border border-green-200 mb-4")
                        ]),
                        
                        # Individual insights
                        html.Div([
                            html.H4("ðŸ’¡ Insights Strategi Individual", className="text-lg font-semibold mb-3"),
                            html.P([
                                f"Strategi individual terbaik menggunakan indikator ",
                                html.Strong(best_individual.get('indicator', 'N/A')),
                                f" pada ticker ",
                                html.Strong(best_individual.get('ticker', 'N/A')),
                                f" berhasil menghasilkan return sebesar ",
                                html.Strong(f"{best_individual.get('return_percentage', 0):.2f}%"),
                                f" dengan melakukan ",
                                html.Strong(f"{best_individual.get('total_trades', 0)} transaksi"),
                                "."
                            ], className="mb-3"),
                            html.P([
                                f"Dari total {best_individual.get('total_trades', 0)} transaksi, ",
                                html.Strong(f"{best_individual.get('profitable_trades', 0)} transaksi menghasilkan profit"),
                                f" dan ",
                                html.Strong(f"{best_individual.get('losing_trades', 0)} transaksi mengalami kerugian"),
                                f", memberikan win rate sebesar ",
                                html.Strong(f"{best_individual.get('win_rate', 0):.1f}%"),
                                "."
                            ], className="mb-3"),
                            html.P([
                                f"Rata-rata holding period untuk strategi ini adalah ",
                                html.Strong(f"{best_individual.get('avg_holding_period', 0):.1f} hari"),
                                f" dengan rata-rata profit per transaksi sebesar ",
                                html.Strong(f"Rp {best_individual.get('avg_profit_per_trade', 0):,.0f}"),
                                "."
                            ], className="mb-3"),
                            html.Div([
                                html.H5("ðŸ”Š Analisis Dampak Volume", className="text-md font-semibold mt-4 mb-2 text-gray-800"),
                                html.P([
                                    "Kesimpulan dari analisis volume untuk strategi ini adalah: ",
                                    html.Strong(
                                        best_individual.get('volume_analysis_summary', 'Analisis volume tidak tersedia.'),
                                        className="text-gray-700"
                                    )
                                ]),
                                html.P(
                                    "(Catatan: Analisis ini membandingkan volume rata-rata pada semua kemungkinan kombinasi trade dalam siklus untuk melihat korelasinya dengan profitabilitas.)",
                                    className="text-xs text-gray-500 mt-1 italic"
                                )
                            ], className="mt-4 p-3 bg-gray-50 rounded border border-gray-200"),

                        ], className="p-4 bg-green-50 rounded-lg border border-green-200 mb-4"),
                        

                        
                        # Top 10 individual strategies table
                        html.Div([
                            html.H4("ðŸ“Š Top 10 Strategi Individual", className="text-lg font-semibold mb-3"),
                            dash_table.DataTable(
                                data=[{
                                    'Rank': i+1,
                                    'Ticker': r.get('ticker', 'N/A'),
                                    'Indikator': r.get('indicator', 'N/A'),
                                    'Return %': f"{r.get('return_percentage', 0):.2f}%",
                                    'Total Profit': f"Rp {r.get('total_profit', 0):,.0f}",
                                    'Win Rate': f"{r.get('win_rate', 0):.1f}%",
                                    'Total Trades': r.get('total_trades', 0),
                                    'Avg Holding': f"{r.get('avg_holding_period', 0):.1f} hari",
                                    # 'Avg Profit per Trade': f"Rp {r.get('avg_profit_per_trade', 0):,.0f}",

                                    # 'Avg Loss per Trade': f"Rp {r.get('avg_loss_per_trade', 0):,.0f}",
                                    # 'Avg Profit Factor': f"{r.get('avg_profit_factor', 0):.2f}",
                                    # 'Avg Drawdown': f"{r.get('avg_drawdown', 0):.2f}%",
                                    
                                    'Cycles': r.get('num_executed_cycles', 0), 
                                    'Volume Analysis': r.get('volume_analysis_summary', 'N/A')
                                } for i, r in enumerate(individual_results_sorted[:100])],
                                columns=[
                                    {'name': '#', 'id': 'Rank'},
                                    {'name': 'Ticker', 'id': 'Ticker'},
                                    {'name': 'Indikator', 'id': 'Indikator'},
                                    {'name': 'Return %', 'id': 'Return %'},
                                    {'name': 'Total Profit', 'id': 'Total Profit'},
                                    {'name': 'Win Rate', 'id': 'Win Rate'},
                                    {'name': 'Total Trades', 'id': 'Total Trades'},
                                    {'name': 'Avg Holding', 'id': 'Avg Holding'},

                                    # {'name': 'Cycles', 'id': 'Total Trades'}, 
                                    # {'name': 'Avg Profit per Trade', 'id': 'Avg Profit per Trade'},
                                    # {'name': 'Avg Loss per Trade', 'id': 'Avg Loss per Trade'},
                                    # {'name': 'Avg Profit Factor', 'id': 'Avg Profit Factor'},
                                    # {'name': 'Avg Drawdown', 'id': 'Avg Drawdown'},

                                    {'name': 'Trade Cycles', 'id': 'Cycles'},
                                    {'name': 'Volume Summary', 'id': 'Volume Analysis', 'type': 'text'},
                                ],
                                style_table={'overflowX': 'auto'},
                                style_cell={'textAlign': 'left', 'padding': '10px'},
                                style_header={
                                    'backgroundColor': 'rgb(240, 240, 240)',
                                    'fontWeight': 'bold'
                                },
                                style_data_conditional=[
                                    {
                                        'if': {'row_index': 0},
                                        'backgroundColor': 'rgba(255, 215, 0, 0.3)',
                                        'fontWeight': 'bold'
                                    },
                                    {
                                        'if': {'filter_query': '{Return %} contains "-"'},
                                        'color': 'red'
                                    },
                                    {
                                        'if': {'filter_query': '{Return %} > "0"'},
                                        'color': 'green'
                                    }
                                ],
                                sort_action='native',
                                page_size=10
                            )
                        ], className="mb-6")
                    ]))
            
            # === ANALISIS STRATEGI KOMBINASI ===
            if combination_results:
                combination_results_sorted = sorted(combination_results, 
                                                key=lambda x: x.get('return_percentage', 0), reverse=True)
                
                if combination_results_sorted:
                    best_combination = combination_results_sorted[0]
                    
                    components.append(html.Div([
                        html.H3("ðŸ”— Analisis Strategi Kombinasi", className="text-xl font-bold mb-3 text-purple-700"),
                        
                        # Best combination strategy
                        html.Div([
                            html.H4("ðŸ¥‡ Strategi Kombinasi Terbaik", className="text-lg font-semibold mb-2 text-purple-600"),
                            html.Div([
                                html.Div([
                                    html.Span("Ticker: ", className="font-semibold"),
                                    html.Span(best_combination.get('ticker', 'N/A'), className="ml-1 text-blue-600 text-lg")
                                ], className="mb-2"),
                                html.Div([
                                    html.Span("Strategi: ", className="font-semibold"),
                                    html.Span(best_combination.get('strategy', 'N/A'), className="ml-1 text-blue-600 text-lg")
                                ], className="mb-2"),
                                html.Div([
                                    html.Span("Return: ", className="font-semibold"),
                                    html.Span(f"{best_combination.get('return_percentage', 0):.2f}%", 
                                            className=f"ml-1 text-lg font-bold {'text-green-600' if best_combination.get('return_percentage', 0) >= 0 else 'text-red-600'}")
                                ], className="mb-2"),
                                html.Div([
                                    html.Span("Win Rate: ", className="font-semibold"),
                                    html.Span(f"{best_combination.get('win_rate', 0):.1f}%", className="ml-1 text-blue-600")
                                ], className="mb-2"),
                            ], className="p-4 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200 mb-4")
                        ]),
                        
                        # Combination insights
                        html.Div([
                            html.H4("ðŸ’¡ Insights Strategi Kombinasi", className="text-lg font-semibold mb-3"),
                            html.P([
                                f"Strategi kombinasi terbaik menggunakan ",
                                html.Strong(f"{best_combination.get('buy_indicator', 'N/A')} untuk sinyal buy"),
                                f" dan ",
                                html.Strong(f"{best_combination.get('sell_indicator', 'N/A')} untuk sinyal sell"),
                                f" pada ticker ",
                                html.Strong(best_combination.get('ticker', 'N/A')),
                                f" menghasilkan return sebesar ",
                                html.Strong(f"{best_combination.get('return_percentage', 0):.2f}%"),
                                "."
                            ], className="mb-3"),
                            
                            # Perbandingan dengan strategi individual - SAFE ACCESS
                            html.P([
                                "Dibandingkan dengan strategi individual terbaik (",
                                html.Strong(f"{best_individual.get('indicator', 'N/A') if individual_results_sorted else 'N/A'}"),
                                f"), strategi kombinasi ini ",
                                html.Strong("berkinerja lebih baik") if (individual_results_sorted and 
                                        best_combination.get('return_percentage', 0) > best_individual.get('return_percentage', 0)) 
                                        else html.Strong("berkinerja lebih rendah"),
                                f" dengan selisih ",
                                html.Strong(f"{abs(best_combination.get('return_percentage', 0) - best_individual.get('return_percentage', 0)):.2f}%" if individual_results_sorted else "N/A"),
                                "."
                            ], className="mb-3"),
                            
                            html.P([
                                f"Strategi kombinasi menunjukkan win rate sebesar ",
                                html.Strong(f"{best_combination.get('win_rate', 0):.1f}%"),
                                f" dengan total ",
                                html.Strong(f"{best_combination.get('total_trades', 0)} transaksi"),
                                f", dimana ",
                                html.Strong(f"{best_combination.get('winning_trades', 0)} transaksi menghasilkan profit"),
                                "."
                            ], className="mb-3"),
                            
                            html.Div([
                                html.H5("ðŸ”Š Analisis Dampak Volume", className="text-md font-semibold mt-4 mb-2 text-gray-800"),
                                html.P([
                                    "Kesimpulan dari analisis volume untuk strategi ini adalah: ",
                                    html.Strong(
                                        best_combination.get('volume_analysis_summary', 'Analisis volume tidak tersedia.'),
                                        className="text-gray-700"
                                    )
                                ])
                            ], className="mt-4 p-3 bg-gray-50 rounded border border-gray-200"),

                        ], className="p-4 bg-purple-50 rounded-lg border border-purple-200 mb-4"),
                        
                        # Top 10 combination strategies table
                        html.Div([
                            html.H4("ðŸ“Š Top 10 Strategi Kombinasi", className="text-lg font-semibold mb-3"),
                            dash_table.DataTable(
                                data=[{
                                    'Rank': i+1,
                                    'Ticker': r.get('ticker', 'N/A'),
                                    'Buy Indicator': r.get('buy_indicator', 'N/A'),
                                    'Sell Indicator': r.get('sell_indicator', 'N/A'),
                                    'Return %': f"{r.get('return_percentage', 0):.2f}%",
                                    'Total Profit': f"Rp {r.get('total_profit', 0):,.0f}",
                                    'Win Rate': f"{r.get('win_rate', 0):.1f}%",
                                    'Total Trades': r.get('total_trades', 0),

                                    'Avg Holding': f"{r.get('avg_holding_period', 0):.1f} hari",
                                    # 'Avg Profit per Trade': f"Rp {r.get('avg_profit_per_trade', 0):,.0f}",
                                    # 'Avg Loss per Trade': f"Rp {r.get('avg_loss_per_trade', 0):,.0f}",
                                    # 'Avg Profit Factor': f"{r.get('avg_profit_factor', 0):.2f}",
                                    # 'Avg Drawdown': f"{r.get('avg_drawdown', 0):.2f}%",

                                    'Cycles': r.get('num_executed_cycles', 0),
                                    'Volume Analysis': r.get('volume_analysis_summary', 'N/A'),

                                } for i, r in enumerate(combination_results_sorted[:100])],
                                columns=[
                                    {'name': '#', 'id': 'Rank'},
                                    {'name': 'Ticker', 'id': 'Ticker'},
                                    {'name': 'Buy Indicator', 'id': 'Buy Indicator'},
                                    {'name': 'Sell Indicator', 'id': 'Sell Indicator'},
                                    {'name': 'Return %', 'id': 'Return %'},
                                    {'name': 'Total Profit', 'id': 'Total Profit'},
                                    {'name': 'Win Rate', 'id': 'Win Rate'},
                                    {'name': 'Total Trades', 'id': 'Total Trades'},

                                    {'name': 'Avg Holding', 'id': 'Avg Holding'},
                                    # {'name': 'Avg Profit per Trade', 'id': 'Avg Profit per Trade'},
                                    # {'name': 'Avg Loss per Trade', 'id': 'Avg Loss per Trade'},
                                    # {'name': 'Avg Profit Factor', 'id': 'Avg Profit Factor'},
                                    # {'name': 'Avg Drawdown', 'id': 'Avg Drawdown'},

                                    {'name': 'Trade Cycles', 'id': 'Cycles'},
                                    {'name': 'Volume Summary', 'id': 'Volume Analysis', 'type': 'text'}
                                ],
                                style_table={'overflowX': 'auto'},
                                style_cell={'textAlign': 'left', 'padding': '10px'},
                                style_header={
                                    'backgroundColor': 'rgb(240, 240, 240)',
                                    'fontWeight': 'bold'
                                },
                                style_data_conditional=[
                                    {
                                        'if': {'row_index': 0},
                                        'backgroundColor': 'rgba(147, 51, 234, 0.3)',
                                        'fontWeight': 'bold'
                                    },
                                    {
                                        'if': {'filter_query': '{Return %} contains "-"'},
                                        'color': 'red'
                                    },
                                    {
                                        'if': {'filter_query': '{Return %} > "0"'},
                                        'color': 'green'
                                    }
                                ],
                                sort_action='native',
                                page_size=10
                            )
                        ], className="mb-6")
                    ]))
            
            # === KESIMPULAN ANALISIS ===
            all_strategies = individual_results + combination_results
            if all_strategies:
                best_overall = max(all_strategies, key=lambda x: x.get('return_percentage', 0))
                
                components.append(html.Div([
                    html.H3("ðŸŽ¯ Kesimpulan dan Rekomendasi", className="text-xl font-bold mb-3 text-red-700"),
                    html.Div([
                        html.H4("ðŸ“ˆ Strategi Optimal", className="text-lg font-semibold mb-3"),
                        html.P([
                            "Berdasarkan hasil backtesting komprehensif, ",
                            html.Strong(f"strategi {'kombinasi' if best_overall in combination_results else 'individual'} terbaik"),
                            " adalah ",
                            html.Strong(best_overall.get('strategy', best_overall.get('indicator', 'N/A'))),
                            f" pada ticker ",
                            html.Strong(best_overall.get('ticker', 'N/A')),
                            f" dengan return sebesar ",
                            html.Strong(f"{best_overall.get('return_percentage', 0):.2f}%"),
                            "."
                        ], className="mb-3"),
                        
                        html.P([
                            "Analisis menunjukkan bahwa ",
                            html.Strong("strategi kombinasi lebih unggul") if (len(combination_results) > 0 and combination_results_sorted and individual_results_sorted and 
                                    combination_results_sorted[0].get('return_percentage', 0) > individual_results_sorted[0].get('return_percentage', 0)) 
                                    else html.Strong("strategi individual lebih stabil"),
                            " untuk dataset ini dalam periode yang dianalisis."
                        ], className="mb-3"),
                        
                        html.P([
                            "Rekomendasi: Gunakan strategi optimal yang telah diidentifikasi dengan tetap mempertimbangkan ",
                            html.Strong("manajemen risiko yang tepat"),
                            " dan melakukan ",
                            html.Strong("monitoring berkala"),
                            " terhadap performa strategi di kondisi pasar yang berubah."
                        ], className="mb-3"),
                    ], className="p-4 bg-red-50 rounded-lg border border-red-200")
                ]))
            
            return html.Div(components)
            
        except Exception as e:
            return html.Div([
                html.H3("âŒ Error dalam analisis global", className="text-xl font-bold text-red-600 mb-2"),
                html.P(f"Terjadi kesalahan: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="bg-gray-100 p-4 rounded text-sm mt-2")
            ])



    @app.callback(
        [Output('volume-cycle-selector', 'options'),
        Output('volume-cycle-selector', 'value'),
        Output('volume-cycle-selector', 'style')], # Tambahkan output style
        [Input('volume-strategy-selector', 'value')],
        [State('backtesting-analysis-data-store', 'children')]
    )
    def update_cycle_dropdown(selected_strategy, stored_data):
        
        
        # Kasus 1: Pengguna memilih "Top Performers", sembunyikan dropdown
        if selected_strategy == 'top_performers':
            return [], None, {'display': 'none'}
            
        # Kasus 2: Tidak ada strategi yang dipilih, tampilkan dropdown kosong
        if not selected_strategy or not stored_data:
            return [], None, {'display': 'block'}

        # Cari data untuk strategi yang dipilih
        data = json.loads(stored_data)
        all_results = data.get('individual_results', []) + data.get('combination_results', [])
        strategy_data = next((s for s in all_results if s.get('strategy') == selected_strategy), None)
        
        # Kasus 3: Data tidak ditemukan atau tidak ada log, tampilkan pesan error tapi tetap kembalikan 3 nilai
        if not strategy_data or not strategy_data.get('detailed_combinations_log'):
            options = [{'label': 'Tidak ada siklus untuk dianalisis', 'value': -1, 'disabled': True}]
            return options, None, {'display': 'block'} # FIX: Tambahkan {'display': 'block'}

        df_log = pd.DataFrame(strategy_data['detailed_combinations_log'])
        
        # Kasus 4: Log ada tapi kosong, sama seperti kasus 3
        if 'cycle_id' not in df_log.columns or df_log.empty:
            options = [{'label': 'Tidak ada siklus yang tercatat', 'value': -1, 'disabled': True}]
            return options, None, {'display': 'block'} # FIX: Tambahkan {'display': 'block'}
            
        # Kasus 5 (Sukses): Buat opsi dan kembalikan 3 nilai
        cycle_ids = sorted(df_log['cycle_id'].unique())
        
        options = [{'label': 'ðŸ“ˆ Tampilkan Semua Siklus (Overview)', 'value': 'all'}]
        options.extend([{'label': f'Siklus Trading #{cycle_id}', 'value': cycle_id} for cycle_id in cycle_ids])
        
        # Set default ke "Semua Siklus"
        return options, 'all', {'display': 'block'}
    



    def create_performer_card(result, rank, type_color):
        """
        DEBUG VERSION: Membuat kartu ringkasan dengan output debug yang detail.
        """
        # Debug 1: Pastikan fungsi ini dipanggil dan lihat data 'result' yang masuk
        print(f"\n--- DEBUG: create_performer_card called for rank #{rank} - Strategy: {result.get('strategy', 'NO STRATEGY NAME')} ---")
        
        # Cek apakah kunci-kunci penting ada di 'result'
        required_keys = ['strategy', 'return_percentage', 'win_rate', 'total_trades', 'total_profit']
        missing_keys = [key for key in required_keys if key not in result]
        if missing_keys:
            print(f"    - WARNING: 'result' dictionary is missing keys: {missing_keys}")

        trades = result.get('trades', []) or result.get('trade_pairs', [])
        
        # Debug 2: Berapa banyak trade yang ditemukan?
        print(f"    - Found {len(trades)} trades/trade_pairs to process for the mini-chart.")

        fig = go.Figure()
        if trades:
            for i, trade in enumerate(trades):
                try:
                    # Ambil data dengan defensive getter
                    entry_date = pd.to_datetime(trade.get('entry_date') or trade.get('buy_date'))
                    exit_date = pd.to_datetime(trade.get('exit_date') or trade.get('sell_date'))
                    entry_price = trade.get('entry_price') or trade.get('buy_price')
                    exit_price = trade.get('exit_price') or trade.get('sell_price')

                    # Debug 3: Periksa nilai-nilai yang diambil. Apakah ada yang None?
                    if any(v is None for v in [entry_date, exit_date, entry_price, exit_price]):
                        print(f"    - ERROR in trade #{i}: One of the values is None!")
                        print(f"      - Raw Trade Data: {trade}")
                        print(f"      - Parsed Values: entry_price={entry_price}, exit_price={exit_price}")
                        continue # Lewati trade yang bermasalah ini

                    # Ini adalah titik rawan error
                    color = 'green' if (exit_price > entry_price) else 'red'
                    
                    fig.add_trace(go.Scatter(x=[entry_date, exit_date], y=[entry_price, exit_price], mode='lines+markers', line=dict(color=color, width=2)))

                except Exception as e:
                    # Debug 4: Tangkap error apa pun yang terjadi di dalam loop
                    print(f"    - FATAL ERROR processing trade #{i}: {e}")
                    print(f"    - Problematic trade data: {trade}")
                    # Hentikan loop jika terjadi error tak terduga
                    break

        # ... sisa fungsi untuk membuat layout ...
        fig.update_layout(
            showlegend=False, height=150, margin=dict(l=0, r=0, t=5, b=0),
            xaxis=dict(showticklabels=False, showgrid=False, zeroline=False),
            yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),
            paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)'
        )
        
        # Bagian layout tidak berubah
        return html.Div([
            html.H5(f"#{rank} - {result.get('strategy', 'N/A')}", className=f"text-lg font-bold border-b pb-2 mb-2 border-{type_color}-200 text-{type_color}-700"),
            html.Div([
                # Kolom Kiri: Metrik
                html.Div([
                    html.Div([html.Strong("Return:", className="w-24 inline-block"), html.Span(f"{result.get('return_percentage', 0):.2f}%", className=f"font-semibold {'text-green-600' if result.get('return_percentage', 0) > 0 else 'text-red-600'}")]),
                    html.Div([html.Strong("Win Rate:", className="w-24 inline-block"), html.Span(f"{result.get('win_rate', 0):.1f}%")]),
                    html.Div([html.Strong("Total Trades:", className="w-24 inline-block"), html.Span(f"{result.get('total_trades', 0)}")]),
                    html.Div([html.Strong("Total Profit:", className="w-24 inline-block"), html.Span(f"Rp {result.get('total_profit', 0):,.0f}")]),
                ], className="w-1/2 pr-2"),
                # Kolom Kanan: Mini Chart
                html.Div(dcc.Graph(figure=fig, config={'displayModeBar': False}), className="w-1/2"),
            ], className="flex items-center"),
            html.Div([
                html.Strong("Volume Insight:", className="block mt-2"),
                html.P(result.get('volume_analysis_summary', 'N/A'), className="text-sm italic text-gray-600")
            ], className="mt-2")
        ], className="p-4 border rounded-lg shadow-sm bg-white mb-4")



    def generate_detailed_analysis_tabs(individual_results, combination_results):
        """
        Membuat layout tab dengan arsitektur show/hide yang andal.
        FIXED: Memastikan semua komponen input ada di layout awal.
        """
        # ... (logika Anda untuk menyiapkan strategy_options tetap sama) ...
        all_strategies = individual_results + combination_results
        strategy_options = [{'label': 'ðŸ† Top Performers Leaderboard', 'value': 'top_performers'}]
        strategy_options.extend(sorted(
            [{'label': s['strategy'], 'value': s['strategy']} for s in all_strategies],
            key=lambda x: x['label']
        ))
        
        return html.Div([
            dcc.Tabs(id="detailed-analysis-tabs", value='tab-volume', children=[
                # ... (Tab-tab Anda yang lain tetap sama) ...
                
                dcc.Tab(label="ðŸ” Analisis & Leaderboard", value="tab-volume", children=[
                    html.Div(className="p-4 bg-gray-50", children=[
                        # Dropdown utama yang selalu terlihat
                        html.Label("Pilih Tampilan:", className="font-semibold"),
                        dcc.Dropdown(
                            id='volume-strategy-selector',
                            options=strategy_options,
                            value='top_performers', # Default ke Top Performers
                            className="mb-6"
                        ),
                        
                        # --- KONTENER UNTUK TOP PERFORMERS ---
                        # Selalu ada di layout, tapi bisa disembunyikan
                        html.Div(
                            id='top-performers-container',
                            style={'display': 'block'}, # Terlihat secara default
                            children=[
                                html.Label("Tampilkan Top:", className="font-semibold mr-2"),
                                dcc.Dropdown(
                                    id='top-performers-limit-selector',
                                    options=[{'label': f'Top {n}', 'value': n} for n in [5, 10, 20]],
                                    value=10,
                                    clearable=False,
                                    style={'width': '150px'}
                                ),
                                # Target output untuk leaderboard
                                html.Div(id='top-performers-content', className="mt-4")
                            ]
                        ),
                        
                        # --- KONTENER UNTUK ANALISIS SIKLUS ---
                        # Selalu ada di layout, tapi awalnya tersembunyi
                        html.Div(
                            id='cycle-analysis-container',
                            style={'display': 'none'}, # Tersembunyi secara default
                            children=[
                                html.Label("Pilih Siklus Trading:", className="font-semibold"),
                                dcc.Dropdown(id='volume-cycle-selector', className="mb-4"),
                                # Target output untuk detail siklus
                                html.Div(id='cycle-detail-content', className="mt-4")
                            ]
                        )
                    ])
                ])
            ])
        ])




    # 2. Callback utama untuk menampilkan detail analisis volume
    @app.callback(
        Output('volume-analysis-detail-content', 'children'),
        [Input('volume-cycle-selector', 'value')],
        [State('volume-strategy-selector', 'value'),
        State('backtesting-analysis-data-store', 'children')]
    )
    def update_volume_analysis_detail(selected_cycle, selected_strategy, stored_data):
        if not selected_cycle or not selected_strategy or not stored_data:
            return html.P("Silakan pilih strategi dan siklus trading untuk melihat detail.", className="text-center text-gray-500")

        data = json.loads(stored_data)
        all_results = data['individual_results'] + data['combination_results']


        if selected_strategy == 'top_performers':
            individual_results = sorted(data.get('individual_results', []), key=lambda x: x.get('return_percentage', 0), reverse=True)
            combination_results = sorted(data.get('combination_results', []), key=lambda x: x.get('return_percentage', 0), reverse=True)
            
            # Dropdown untuk memilih jumlah top N
            limit_selector = html.Div([
                html.Label("Tampilkan Top:", className="font-semibold mr-2"),
                dcc.Dropdown(
                    id='top-performers-limit-selector',
                    options=[
                        {'label': 'Top 5', 'value': 5},
                        {'label': 'Top 10', 'value': 10},
                        {'label': 'Top 20', 'value': 20},
                    ],
                    value=10, # Default value
                    clearable=False,
                    style={'width': '150px'}
                )
            ], className="flex items-center mb-6")

            # Kontainer untuk leaderboard yang akan diupdate oleh callback baru
            leaderboard_content = html.Div(id='top-performers-content')
            
            return html.Div([limit_selector, leaderboard_content])


        else:

            # all_results = data.get('individual_results', []) + data.get('combination_results', [])
            strategy_data = next((s for s in all_results if s.get('strategy') == selected_strategy), None)

            if not strategy_data:
                return html.P(f"Data tidak ditemukan untuk strategi '{selected_strategy}'.", className="text-center text-red-500")

            # --- Ambil Data Harga & Volume Keseluruhan (untuk Konteks) ---
            df_processed = pd.DataFrame(data['processed_data'])
            df_processed['Datetime'] = pd.to_datetime(df_processed['Datetime'])
            ticker_prices = df_processed[df_processed['Title'] == strategy_data['ticker']].sort_values('Datetime')

            # ==============================================================================
            # LOGIKA BARU: TAMPILAN "SEMUA SIKLUS" (OVERVIEW)
            # ==============================================================================
            if selected_cycle == 'all':
                executed_trades = strategy_data.get('trades', []) or strategy_data.get('trade_pairs', [])
                if not executed_trades:
                    return html.P("Strategi ini tidak menghasilkan trade yang dieksekusi.", className="text-center text-orange-500 p-4")

                # --- Buat Chart Ganda (Harga & Volume) ---
                fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.05, row_heights=[0.7, 0.3])
                
                # Chart 1: Close Price & Semua Trade yang Dieksekusi
                fig.add_trace(go.Scatter(
                    x=ticker_prices['Datetime'], y=ticker_prices['Price'],
                    mode='lines', name='Close Price', line=dict(color='rgba(150, 150, 150, 0.5)', width=1.5)
                ), row=1, col=1)

                for i, trade in enumerate(executed_trades):
                    # Normalisasi kunci agar bisa menangani hasil individual dan kombinasi
                    entry_date = pd.to_datetime(trade.get('entry_date') or trade.get('buy_date'))
                    exit_date = pd.to_datetime(trade.get('exit_date') or trade.get('sell_date'))
                    entry_price = trade.get('entry_price') or trade.get('buy_price')
                    exit_price = trade.get('exit_price') or trade.get('sell_price')
                    profit = trade.get('profit', 0)
                    
                    color = 'green' if profit > 0 else 'red'
                    fig.add_trace(go.Scatter(
                        x=[entry_date, exit_date], y=[entry_price, exit_price],
                        mode='lines+markers', name=f'Trade #{i+1}', line=dict(color=color, width=2),
                        marker=dict(size=8, symbol='circle'), hoverinfo='none'
                    ), row=1, col=1)

                # Chart 2: Volume Pasar Keseluruhan
                fig.add_trace(go.Bar(
                    x=ticker_prices['Datetime'], y=ticker_prices['Volume'],
                    name='Market Volume', marker_color='rgba(100, 149, 237, 0.6)'
                ), row=2, col=1)

                fig.update_layout(title_text=f"Overview Semua Transaksi untuk: {selected_strategy}", height=600, template="plotly_white", showlegend=False)
                fig.update_yaxes(title_text="Harga (Rp)", row=1, col=1)
                fig.update_yaxes(title_text="Volume Pasar", row=2, col=1)
                fig.update_xaxes(title_text="Tanggal", row=2, col=1)

                # --- Buat Tabel Detail Transaksi ---
                formatted_trades = []
                for trade in executed_trades:
                    formatted_trades.append({
                        'Tgl Masuk': (pd.to_datetime(trade.get('entry_date') or trade.get('buy_date'))).strftime('%Y-%m-%d'),
                        'Harga Masuk': f"{trade.get('entry_price') or trade.get('buy_price'):.2f}",
                        'Tgl Keluar': (pd.to_datetime(trade.get('exit_date') or trade.get('sell_date'))).strftime('%Y-%m-%d'),
                        'Harga Keluar': f"{trade.get('exit_price') or trade.get('sell_price'):.2f}",
                        'Profit/Loss': f"{trade.get('profit', 0):,.2f}",
                        'Periode (hari)': trade.get('holding_period', 'N/A')
                    })

                transactions_table = dash_table.DataTable(
                    data=formatted_trades,
                    columns=[{'name': col, 'id': col} for col in formatted_trades[0].keys()],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '8px'},
                    style_header={'fontWeight': 'bold'},
                    style_data_conditional=[
                        {'if': {'filter_query': '{Profit/Loss} contains "-"'}, 'color': 'red'},
                        {'if': {'filter_query': '{Profit/Loss} > "0"'}, 'color': 'green'}
                    ],
                    page_size=10
                )
                
                # --- Buat Penjelasan Lengkap ---
                explanation_div = html.Div([
                    html.H4("ðŸ“ˆ Overview Kinerja Strategi", className="text-lg font-semibold mt-4 mb-2"),
                    html.P([
                        "Visualisasi ini memberikan gambaran lengkap tentang performa strategi dari waktu ke waktu. ",
                        "Anda dapat melihat setiap transaksi yang dieksekusi (garis hijau untuk untung, merah untuk rugi) dengan latar belakang pergerakan harga saham (garis abu-abu) dan volume pasar (bar biru)."
                    ]),
                    html.H5("Tabel Detail Transaksi", className="text-md font-semibold mt-4 mb-2"),
                    transactions_table,
                    html.H5("Cara Menginterpretasi", className="text-md font-semibold mt-4 mb-2"),
                    html.Ul([
                        html.Li("Apakah trade yang untung cenderung terjadi saat harga sedang tren naik?"),
                        html.Li("Apakah trade yang rugi terjadi saat mencoba melawan tren kuat?"),
                        html.Li("Perhatikan chart volume di bawah. Apakah transaksi-transaksi penting (baik untung besar atau rugi besar) terjadi pada saat volume pasar sedang tinggi? Volume tinggi seringkali menandakan partisipasi pasar yang kuat dan dapat mengkonfirmasi validitas sebuah pergerakan harga."),
                    ], className="list-disc list-inside"),
                ], className="mt-4")
                
                return html.Div([dcc.Graph(figure=fig), explanation_div])

            # --- Logika untuk Tampilan "Per Siklus" (yang sudah diperbaiki) ---
            else:
                df_log = pd.DataFrame(strategy_data.get('detailed_combinations_log', []))
                if df_log.empty:
                    return html.P("Data analisis detail siklus tidak ditemukan.", className="text-center")
                    
                for col in ['buy_date', 'sell_date']: df_log[col] = pd.to_datetime(df_log[col])
                log_for_cycle = df_log[df_log['cycle_id'] == selected_cycle].copy()

                if log_for_cycle.empty: return html.P(f"Tidak ada data untuk Siklus #{selected_cycle}.", className="text-center")
                
                executed_trade = log_for_cycle.loc[log_for_cycle['profit_per_share'].idxmax()]
                all_buys = log_for_cycle[['buy_date', 'buy_price', 'buy_volume']].drop_duplicates().rename(columns={'buy_date':'date', 'buy_price':'price', 'buy_volume':'volume'})
                all_sells = log_for_cycle[['sell_date', 'sell_price', 'sell_volume']].drop_duplicates().rename(columns={'sell_date':'date', 'sell_price':'price', 'sell_volume':'volume'})
                
                # Batasi data harga sesuai rentang waktu siklus
                cycle_start_date = log_for_cycle['buy_date'].min()
                cycle_end_date = log_for_cycle['sell_date'].max()
                price_in_cycle = ticker_prices[(ticker_prices['Datetime'] >= cycle_start_date) & (ticker_prices['Datetime'] <= cycle_end_date)]

                fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.05, row_heights=[0.7, 0.3])
                
                # Chart 1: Harga, Sinyal, dan Close Price
                fig.add_trace(go.Scatter(x=price_in_cycle['Datetime'], y=price_in_cycle['Price'], mode='lines', name='Close Price', line=dict(color='lightgray')), row=1, col=1)
                fig.add_trace(go.Scatter(x=all_buys['date'], y=all_buys['price'], mode='markers', name='Sinyal Beli', marker=dict(symbol='triangle-up', size=10, color='rgba(0, 128, 0, 0.6)')), row=1, col=1)
                fig.add_trace(go.Scatter(x=all_sells['date'], y=all_sells['price'], mode='markers', name='Sinyal Jual', marker=dict(symbol='triangle-down', size=10, color='rgba(255, 0, 0, 0.6)')), row=1, col=1)
                fig.add_trace(go.Scatter(x=[executed_trade['buy_date'], executed_trade['sell_date']], y=[executed_trade['buy_price'], executed_trade['sell_price']], mode='lines+markers', name='Trade Dieksekusi', line=dict(color='black', width=2, dash='dash'), marker=dict(size=14, line=dict(width=3, color='black'))), row=1, col=1)

                # Chart 2: Volume pada Sinyal
                fig.add_trace(go.Bar(x=all_buys['date'], y=all_buys['volume'], name='Volume Sinyal Beli', marker_color='green'), row=2, col=1)
                fig.add_trace(go.Bar(x=all_sells['date'], y=all_sells['volume'], name='Volume Sinyal Jual', marker_color='red'), row=2, col=1)

                fig.update_layout(title_text=f"Analisis Keputusan & Volume - Siklus #{selected_cycle}", height=600, template="plotly_white")
                fig.update_yaxes(title_text="Harga (Rp)", row=1, col=1)
                fig.update_yaxes(title_text="Volume", row=2, col=1)
                fig.update_xaxes(row=2, col=1)

            # --- PENJELASAN ANALITIS LENGKAP ---
            explanation_div = html.Div([
                html.H4("ðŸ’¡ Cara Membaca Analisis Ini", className="text-lg font-semibold mb-2"),
                html.P("Visualisasi ini membantu Anda memahami 'mengapa' sebuah trade dieksekusi dengan membandingkan semua pilihan yang ada dalam satu siklus trading.", className="mb-3"),
                
                html.Ul([
                    html.Li([html.Strong("Chart Atas (Harga & Sinyal):"), " Menunjukkan semua titik Beli (â–²) dan Jual (â–¼) yang mungkin terjadi. Garis putus-putus hitam menghubungkan pasangan Beli-Jual yang dipilih oleh sistem karena memberikan profit tertinggi."]),
                    html.Li([html.Strong("Chart Bawah (Volume):"), " Menampilkan kekuatan (volume) di pasar pada saat setiap sinyal muncul. Bandingkan tinggi bar hijau (Beli) dan merah (Jual)."]),
                ], className="list-disc list-inside mb-4"),

                html.H4("ðŸ”¬ Analisis untuk Siklus Ini", className="text-lg font-semibold mb-2"),
                html.P([
                    "Dalam periode ini, sistem mengidentifikasi ", html.Strong(f"{len(all_buys)} sinyal Beli"), " dan ", html.Strong(f"{len(all_sells)} sinyal Jual"),
                    ", yang menghasilkan ", html.Strong(f"{len(log_for_cycle)} kemungkinan pasangan trade"), "."
                ]),
                html.Div([
                    html.Strong("Keputusan Sistem:", className="text-gray-800"),
                    html.P([
                        "Sistem memilih untuk ",
                        html.Span(f"MEMBELI pada {executed_trade['buy_date'].strftime('%Y-%m-%d')} seharga Rp {executed_trade['buy_price']:.2f}", className="text-green-700"),
                        " dan ",
                        html.Span(f"MENJUAL pada {executed_trade['sell_date'].strftime('%Y-%m-%d')} seharga Rp {executed_trade['sell_price']:.2f}", className="text-red-700"),
                        f", karena pasangan ini memberikan profit per saham tertinggi sebesar Rp {executed_trade['profit_per_share']:.2f}."
                    ])
                ], className="p-3 my-3 bg-gray-100 rounded-lg border"),

                html.H4("ðŸ”Š Insight dari Volume", className="text-lg font-semibold mb-2"),
                html.P([
                    "Perhatikan volume pada sinyal yang dieksekusi: Volume saat ", html.Strong("Beli"), " adalah ", 
                    html.Strong(f"{executed_trade['buy_volume']:,.0f}"), " dan volume saat ", html.Strong("Jual"), " adalah ",
                    html.Strong(f"{executed_trade['sell_volume']:,.0f}"), "."
                ]),
                html.P([
                    "Bandingkan angka ini dengan volume pada sinyal-sinyal lain yang diabaikan. Apakah sinyal beli yang dipilih memiliki volume yang signifikan lebih tinggi daripada rata-rata sinyal beli lainnya? ",
                    "Jika ya, ini bisa mengindikasikan bahwa volume tinggi berfungsi sebagai konfirmasi yang baik untuk memulai posisi pada strategi ini."
                ])
            ], className="mt-6")


            return html.Div([
                dcc.Graph(figure=fig),
                explanation_div
            ])




    @app.callback(
        Output('top-performers-content', 'children'),
        [Input('top-performers-limit-selector', 'value')],
        [State('backtesting-analysis-data-store', 'children')],
        prevent_initial_call=False # Izinkan berjalan saat pertama kali dimuat
    )
    def update_top_performers_leaderboard(limit, stored_data):
        # Debugging Point: Ini akan muncul di terminal Anda sekarang
        print(f"--- SUCCESS: update_top_performers_leaderboard CALLED with limit: {limit} ---")

        if not limit or not stored_data:
            raise PreventUpdate

        data = json.loads(stored_data)
        individual_results = sorted(data.get('individual_results', []), key=lambda x: x.get('return_percentage', 0), reverse=True)
        combination_results = sorted(data.get('combination_results', []), key=lambda x: x.get('return_percentage', 0), reverse=True)

        top_individuals = individual_results[:limit]
        top_combinations = combination_results[:limit]

        if not top_individuals and not top_combinations:
            return html.P("Tidak ada data performa untuk ditampilkan.", className="text-center text-gray-500 mt-8")

        return html.Div([
            html.Div([
                # Kolom Kiri: Top Individual
                html.Div([
                    html.H4("ðŸ’¡ Top Strategi Individual", className="text-xl font-bold mb-4 text-green-700"),
                    html.Div([create_performer_card(res, i + 1, 'green') for i, res in enumerate(top_individuals)]) if top_individuals else html.P("Tidak ada hasil.", className="text-center")
                ], className="w-1/2 px-2"),
                
                # Kolom Kanan: Top Kombinasi
                html.Div([
                    html.H4("ðŸ”— Top Strategi Kombinasi", className="text-xl font-bold mb-4 text-purple-700"),
                    html.Div([create_performer_card(res, i + 1, 'purple') for i, res in enumerate(top_combinations)]) if top_combinations else html.P("Tidak ada hasil.", className="text-center")
                ], className="w-1/2 px-2"),
            ], className="flex")
        ])





    # def generate_backtesting_analysis_results(all_results):
    #     """
    #     Menghasilkan hasil analisis backtesting menggunakan logika yang sama persis dengan run_backtest_analysis
    #     Diperbaiki untuk mendukung transaksi berkelanjutan sepanjang periode data
    #     Dengan filter ticker dan kombinasi strategi
    #     Ditambah penjelasan detail dalam Bahasa Indonesia
    #     """
    #     if not all_results or 'leaderboard' not in all_results or not all_results['leaderboard']:
    #         return html.Div("Tidak ada data analisis backtesting yang tersedia", className="text-center text-gray-500 p-4")
        
    #     try:
    #         # Ekstrak data dari all_results
    #         leaderboard = all_results['leaderboard']
    #         ticker_details = all_results.get('ticker_details', {})
    #         trade_details = all_results.get('trade_details', {})
            
    #         # Proses data untuk mencocokkan format yang diharapkan untuk logika analisis
    #         processed_data = []
    #         individual_results = []  # Untuk menyimpan hasil analisis individual
    #         combination_results = []  # Untuk menyimpan hasil analisis kombinasi
            
    #         for ticker, indicators in ticker_details.items():
    #             for indicator_result in indicators:
    #                 indicator_name = indicator_result['indicator']
    #                 trades = trade_details.get(ticker, {}).get(indicator_name, [])
                    
    #                 # Konversi trades ke format signal untuk pemrosesan
    #                 for trade in trades:
    #                     if trade['type'] == 'Buy':
    #                         processed_data.append({
    #                             'Title': ticker,
    #                             'Datetime': pd.to_datetime(trade['date']),
    #                             'Analysis_info': indicator_name,
    #                             'Signal': 'Buy',
    #                             'Price': trade['price'],
    #                             'Volume': getattr(trade, 'volume', 1000)
    #                         })
    #                     elif trade['type'] == 'Sell':
    #                         processed_data.append({
    #                             'Title': ticker,
    #                             'Datetime': pd.to_datetime(trade['date']),
    #                             'Analysis_info': indicator_name,
    #                             'Signal': 'Sell',
    #                             'Price': trade['price'],
    #                             'Volume': getattr(trade, 'volume', 1000)
    #                         })
                    
    #                 # Analisis individual indicator
    #                 individual_analysis = analyze_individual_indicator(
    #                     ticker, indicator_name, trades, indicator_result
    #                 )
    #                 if individual_analysis:
    #                     individual_results.append(individual_analysis)
            
    #         # Analisis kombinasi indikator
    #         combination_results = analyze_indicator_combinations(processed_data, ticker_details, trade_details)
            
    #         if not processed_data:
    #             return html.Div("Tidak ada data trade yang tersedia untuk analisis", className="text-center text-gray-500 p-4")
            
    #         # Konversi ke DataFrame untuk pemrosesan
    #         df = pd.DataFrame(processed_data)
            
    #         # Dapatkan semua ticker dan indikator unik untuk dropdown
    #         all_tickers = sorted(df['Title'].unique().tolist())
    #         all_indicators = sorted(df['Analysis_info'].unique().tolist())
            
    #         # Buat kombinasi ticker-indicator untuk dropdown
    #         ticker_indicator_combinations = []
    #         for ticker in all_tickers:
    #             for indicator in all_indicators:
    #                 ticker_data = df[(df['Title'] == ticker) & (df['Analysis_info'] == indicator)]
    #                 if not ticker_data.empty:
    #                     ticker_indicator_combinations.append({
    #                         'label': f"{ticker} - {indicator}",
    #                         'value': f"{ticker}|{indicator}"
    #                     })
            
    #         # Tambahkan opsi global di awal
    #         dropdown_options = [
    #             {'label': 'Analisis Global (Semua Ticker & Strategi)', 'value': 'global'},
    #             {'label': '--- Filter by Ticker ---', 'value': 'separator', 'disabled': True}
    #         ]
            
    #         # Tambahkan opsi per ticker
    #         for ticker in all_tickers:
    #             dropdown_options.append({
    #                 'label': f"Semua Strategi untuk {ticker}",
    #                 'value': f"ticker:{ticker}"
    #             })
            
    #         dropdown_options.append({'label': '--- Filter by Combination ---', 'value': 'separator2', 'disabled': True})
    #         dropdown_options.extend(ticker_indicator_combinations)
            
    #         # Buat komponen utama dengan dropdown filter
    #         main_components = [
    #             # Header dan Filter Section
    #             html.Div([
    #                 html.H2("ðŸ“ˆ Analisis Backtesting Berkelanjutan Lengkap", className="text-2xl font-bold mb-4 text-blue-700"),
    #                 html.Div([
    #                     html.P("ðŸ“Š Analisis komprehensif ini mengevaluasi performa strategi trading menggunakan indikator teknikal individual dan kombinasinya.", 
    #                         className="text-gray-700 mb-3"),
    #                     html.P("ðŸŽ¯ Sistem menguji berbagai skenario entry dan exit point untuk menemukan strategi optimal dengan return terbaik.", 
    #                         className="text-gray-700 mb-3"),
    #                     html.P("ðŸ“‹ Pilih kombinasi untuk melihat analisis spesifik, atau gunakan 'Analisis Global' untuk melihat performa terbaik dari semua ticker dan strategi.", 
    #                         className="text-gray-600 mb-4"),
    #                 ]),
                    
    #                 # Filter Dropdown
    #                 html.Div([
    #                     html.Label("ðŸ” Pilih Analisis:", className="block text-sm font-medium text-gray-700 mb-2"),
    #                     dcc.Dropdown(
    #                         id='backtesting-analysis-filter',
    #                         options=dropdown_options,
    #                         value='global',  # Default ke analisis global
    #                         className="w-full mb-4",
    #                         placeholder="Pilih ticker dan strategi untuk analisis..."
    #                     )
    #                 ], className="mb-6 p-4 bg-gray-50 rounded-lg border")
    #             ], className="mb-6"),
                
    #             # Container untuk hasil yang akan diupdate berdasarkan filter
    #             html.Div(id='filtered-backtesting-results', className="min-h-96")
    #         ]
            
    #         # Generate hasil global sebagai default dengan penjelasan lengkap
    #         global_results = generate_enhanced_global_analysis_results(
    #             df, ticker_details, all_tickers, all_indicators, individual_results, combination_results
    #         )
            
    #         # Tambahkan section detail transaksi yang lengkap
    #         detailed_transaction_section = generate_detailed_transaction_section(individual_results, combination_results)
            
    #         # Store semua data untuk callback
    #         analysis_data_store = html.Div(
    #             id='backtesting-analysis-data-store',
    #             style={'display': 'none'},
    #             children=json.dumps({
    #                 'processed_data': processed_data,
    #                 'ticker_details': ticker_details,
    #                 'trade_details': trade_details,
    #                 'all_tickers': all_tickers,
    #                 'all_indicators': all_indicators,
    #                 'individual_results': individual_results,
    #                 'combination_results': combination_results
    #             }, default=str)
    #         )
            
    #         return html.Div([
    #             analysis_data_store,
    #             html.Div(main_components),
    #             html.Div(global_results, id='initial-global-results'),
    #             detailed_transaction_section
    #         ], className="p-4 bg-white rounded shadow-sm")

    #     except Exception as e:
    #         return html.Div([
    #             html.H3("âŒ Error", className="text-xl font-bold text-red-600 mb-2"),
    #             html.P(f"Terjadi kesalahan selama analisis: {str(e)}", className="text-red-500"),
    #             html.Pre(traceback.format_exc(), className="bg-gray-100 p-4 rounded text-sm mt-2")
    #         ])


    def generate_detailed_transaction_section(individual_results, combination_results):
        """Generate section untuk detail transaksi yang lengkap"""
        if not individual_results and not combination_results:
            return html.Div("Tidak ada data transaksi yang tersedia", className="text-center text-gray-500 p-4")
        
        # Format individual results untuk display
        formatted_individual_results = []
        for result in individual_results:
            if result.get('trade_pairs'):
                formatted_trades = []
                for trade_pair in result['trade_pairs']:
                    formatted_trades.append({
                        'Entry Date': trade_pair['buy_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade_pair['buy_date'], 'strftime') else str(trade_pair['buy_date']),
                        'Entry Price': f"{trade_pair['buy_price']:.2f}",
                        'Exit Date': trade_pair['sell_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade_pair['sell_date'], 'strftime') else str(trade_pair['sell_date']),
                        'Exit Price': f"{trade_pair['sell_price']:.2f}",
                        'Shares': trade_pair['shares'],
                        'Profit/Loss': f"{trade_pair['profit']:.2f}",
                        'Return %': f"{trade_pair['price_change']:.2f}%",
                        'Price Change %': f"{trade_pair['price_change']:.2f}%",
                        'Holding Period': f"{trade_pair['holding_period']} hari"
                    })
                
                formatted_individual_results.append({
                    'Strategy': f"{result['ticker']} - {result['indicator']}",
                    'Trades': formatted_trades,
                    'Total Return': result['return_percentage'],
                    'Win Rate': result['win_rate'],
                    'Total Trades': result['total_trades']
                })
        
        # Format combination results untuk display
        formatted_combination_results = []
        for result in combination_results:
            if result.get('trades'):
                formatted_trades = []
                for trade in result['trades']:
                    formatted_trades.append({
                        'Entry Date': trade['entry_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['entry_date'], 'strftime') else str(trade['entry_date']),
                        'Entry Price': f"{trade['entry_price']:.2f}",
                        'Exit Date': trade['exit_date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['exit_date'], 'strftime') else str(trade['exit_date']),
                        'Exit Price': f"{trade['exit_price']:.2f}",
                        'Shares': trade['shares'],
                        'Profit/Loss': f"{trade['profit']:.2f}",
                        'Return %': f"{trade['return_pct']:.2f}%",
                        'Buy Indicator': trade.get('buy_indicator', ''),
                        'Sell Indicator': trade.get('sell_indicator', ''),
                        'Holding Period': f"{trade.get('holding_period', 0)} hari"
                    })
                
                formatted_combination_results.append({
                    'Strategy': result['strategy'],
                    'Trades': formatted_trades,
                    'Total Return': result['return_percentage'],
                    'Win Rate': result['win_rate'],
                    'Total Trades': result['total_trades']
                })
        
        # Sort berdasarkan return
        formatted_individual_results = sorted(formatted_individual_results, key=lambda x: x['Total Return'], reverse=True)
        formatted_combination_results = sorted(formatted_combination_results, key=lambda x: x['Total Return'], reverse=True)
        
        return html.Div([
            html.Div([
                html.H2("ðŸ“‹ Detail Transaksi Lengkap Semua Strategi", className="text-2xl font-bold mb-4 text-blue-700"),
                html.P("Bagian ini menampilkan detail lengkap dari setiap transaksi yang dilakukan oleh strategi individual dan kombinasi.", 
                    className="text-gray-700 mb-4"),
                
                dcc.Tabs([
                    # Tab untuk Individual Indicator Trades
                    dcc.Tab(label="ðŸ’¡ Transaksi Strategi Individual", 
                        className="font-semibold py-3 px-4",
                        selected_className="bg-green-50 border-t-2 border-green-600",
                        children=[
                        html.Div([
                            html.H3("ðŸ“Š Transaksi Strategi Individual", className="text-xl font-bold mb-4 text-green-700"),
                            html.P(f"Menampilkan detail transaksi dari {len(formatted_individual_results)} strategi individual terbaik.", 
                                className="text-gray-600 mb-4"),
                            
                            # Accordion untuk setiap strategi individual
                            html.Div([
                                html.Div([
                                    # Header untuk setiap strategi
                                    html.Div([
                                        html.H4(f"ðŸŽ¯ {result['Strategy']}", className="text-lg font-semibold mb-2 text-green-600"),
                                        html.Div([
                                            html.Div([
                                                html.Span("Total Return: ", className="font-semibold"),
                                                html.Span(f"{result['Total Return']:.2f}%", 
                                                        className=f"ml-1 font-bold {'text-green-600' if result['Total Return'] >= 0 else 'text-red-600'}")
                                            ], className="mr-4"),
                                            html.Div([
                                                html.Span("Win Rate: ", className="font-semibold"),
                                                html.Span(f"{result['Win Rate']:.1f}%", className="ml-1 text-blue-600")
                                            ], className="mr-4"),
                                            html.Div([
                                                html.Span("Total Trades: ", className="font-semibold"),
                                                html.Span(f"{result['Total Trades']}", className="ml-1 text-gray-700")
                                            ])
                                        ], className="flex mb-3"),
                                    ], className="p-3 bg-green-50 rounded-lg border border-green-200 mb-2"),
                                    
                                    # Tabel detail transaksi
                                    dash_table.DataTable(
                                        data=result['Trades'],
                                        columns=[
                                            {'name': col, 'id': col} for col in [
                                                'Entry Date', 'Entry Price', 'Exit Date', 'Exit Price',
                                                'Shares', 'Profit/Loss', 'Return %', 'Price Change %',
                                                'Holding Period'
                                            ]
                                        ],
                                        style_table={'overflowX': 'auto'},
                                        style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '12px'},
                                        style_header={
                                            'backgroundColor': 'rgb(240, 240, 240)',
                                            'fontWeight': 'bold'
                                        },
                                        style_data_conditional=[
                                            {
                                                'if': {'filter_query': '{Profit/Loss} contains "-"'},
                                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                                'color': 'red'
                                            },
                                            {
                                                'if': {'filter_query': '{Profit/Loss} > "0.00"'},
                                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                                'color': 'green'
                                            }
                                        ],
                                        sort_action='native',
                                        page_size=15,
                                        filter_action='native'
                                    )
                                ], className="mb-6 p-4 bg-white rounded-lg shadow-sm border") 
                                for i, result in enumerate(formatted_individual_results[:10])  # Tampilkan top 10
                            ])
                        ], className="mt-4")
                    ]),

                    # Tab untuk Combination Strategy Trades
                    dcc.Tab(label="ðŸ”— Transaksi Strategi Kombinasi", 
                        className="font-semibold py-3 px-4",
                        selected_className="bg-purple-50 border-t-2 border-purple-600",
                        children=[
                        html.Div([
                            html.H3("ðŸ“Š Transaksi Strategi Kombinasi", className="text-xl font-bold mb-4 text-purple-700"),
                            html.P(f"Menampilkan detail transaksi dari {len(formatted_combination_results)} strategi kombinasi terbaik.", 
                                className="text-gray-600 mb-4"),
                            
                            # Accordion untuk setiap strategi kombinasi
                            html.Div([
                                html.Div([
                                    # Header untuk setiap strategi kombinasi
                                    html.Div([
                                        html.H4(f"ðŸŽ¯ {combo['Strategy']}", className="text-lg font-semibold mb-2 text-purple-600"),
                                        html.Div([
                                            html.Div([
                                                html.Span("Total Return: ", className="font-semibold"),
                                                html.Span(f"{combo['Total Return']:.2f}%", 
                                                        className=f"ml-1 font-bold {'text-green-600' if combo['Total Return'] >= 0 else 'text-red-600'}")
                                            ], className="mr-4"),
                                            html.Div([
                                                html.Span("Win Rate: ", className="font-semibold"),
                                                html.Span(f"{combo['Win Rate']:.1f}%", className="ml-1 text-blue-600")
                                            ], className="mr-4"),
                                            html.Div([
                                                html.Span("Total Trades: ", className="font-semibold"),
                                                html.Span(f"{combo['Total Trades']}", className="ml-1 text-gray-700")
                                            ])
                                        ], className="flex mb-3"),
                                    ], className="p-3 bg-purple-50 rounded-lg border border-purple-200 mb-2"),
                                    
                                    # Tabel detail transaksi kombinasi
                                    dash_table.DataTable(
                                        data=combo['Trades'],
                                        columns=[
                                            {'name': col, 'id': col} for col in [
                                                'Entry Date', 'Entry Price', 'Exit Date', 'Exit Price',
                                                'Shares', 'Profit/Loss', 'Return %', 'Buy Indicator',
                                                'Sell Indicator', 'Holding Period'
                                            ]
                                        ],
                                        style_table={'overflowX': 'auto'},
                                        style_cell={'textAlign': 'left', 'padding': '10px', 'fontSize': '12px'},
                                        style_header={
                                            'backgroundColor': 'rgb(240, 240, 240)',
                                            'fontWeight': 'bold'
                                        },
                                        style_data_conditional=[
                                            {
                                                'if': {'filter_query': '{Profit/Loss} contains "-"'},
                                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                                'color': 'red'
                                            },
                                            {
                                                'if': {'filter_query': '{Profit/Loss} > "0.00"'},
                                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                                'color': 'green'
                                            }
                                        ],
                                        sort_action='native',
                                        page_size=15,
                                        filter_action='native'
                                    )
                                ], className="mb-6 p-4 bg-white rounded-lg shadow-sm border") 
                                for combo in formatted_combination_results[:10]  # Tampilkan top 10
                            ])
                        ], className="mt-4")
                    ]),
                    
                    # Tab untuk Summary Comparison
                    dcc.Tab(label="ðŸ“ˆ Perbandingan Summary", 
                        className="font-semibold py-3 px-4",
                        selected_className="bg-blue-50 border-t-2 border-blue-600",
                        children=[
                        html.Div([
                            html.H3("ðŸ“Š Perbandingan Performa Semua Strategi", className="text-xl font-bold mb-4 text-blue-700"),
                            
                            # Tabel perbandingan semua strategi
                            html.Div([
                                html.H4("ðŸ† Top 20 Strategi Terbaik (Individual + Kombinasi)", className="text-lg font-semibold mb-3"),
                                
                                # Gabungkan dan sort semua strategi
                                dash_table.DataTable(
                                    data=[{
                                        'Rank': i+1,
                                        'Type': 'Individual',
                                        'Strategy': result['Strategy'],
                                        'Total Return': f"{result['Total Return']:.2f}%",
                                        'Win Rate': f"{result['Win Rate']:.1f}%",
                                        'Total Trades': result['Total Trades']
                                    } for i, result in enumerate(formatted_individual_results[:10])] +
                                    [{
                                        'Rank': i+len(formatted_individual_results[:10])+1,
                                        'Type': 'Combination',
                                        'Strategy': result['Strategy'],
                                        'Total Return': f"{result['Total Return']:.2f}%",
                                        'Win Rate': f"{result['Win Rate']:.1f}%",
                                        'Total Trades': result['Total Trades']
                                    } for i, result in enumerate(formatted_combination_results[:10])],
                                    columns=[
                                        {'name': '#', 'id': 'Rank'},
                                        {'name': 'Type', 'id': 'Type'},
                                        {'name': 'Strategy', 'id': 'Strategy'},
                                        {'name': 'Total Return', 'id': 'Total Return'},
                                        {'name': 'Win Rate', 'id': 'Win Rate'},
                                        {'name': 'Total Trades', 'id': 'Total Trades'}
                                    ],
                                    style_table={'overflowX': 'auto'},
                                    style_cell={'textAlign': 'left', 'padding': '10px'},
                                    style_header={
                                        'backgroundColor': 'rgb(240, 240, 240)',
                                        'fontWeight': 'bold'
                                    },
                                    style_data_conditional=[
                                        {
                                            'if': {'filter_query': '{Type} = "Individual"'},
                                            'backgroundColor': 'rgba(34, 197, 94, 0.1)'
                                        },
                                        {
                                            'if': {'filter_query': '{Type} = "Combination"'},
                                            'backgroundColor': 'rgba(147, 51, 234, 0.1)'
                                        },
                                        {
                                            'if': {'filter_query': '{Total Return} contains "-"'},
                                            'color': 'red'
                                        },
                                        {
                                            'if': {'filter_query': '{Total Return} > "0"'},
                                            'color': 'green'
                                        }
                                    ],
                                    sort_action='native',
                                    page_size=20
                                )
                            ], className="mb-6"),
                            
                            # Insight summary
                            html.Div([
                                html.H4("ðŸ’¡ Ringkasan Insights", className="text-lg font-semibold mb-3"),
                                html.Div([
                                    html.P([
                                        "ðŸ“Š Total strategi yang dianalisis: ",
                                        html.Strong(f"{len(formatted_individual_results)} individual"),
                                        " dan ",
                                        html.Strong(f"{len(formatted_combination_results)} kombinasi"),
                                        " strategi."
                                    ], className="mb-2"),
                                    html.P([
                                        "ðŸŽ¯ Strategi terbaik: ",
                                        html.Strong(formatted_individual_results[0]['Strategy'] if formatted_individual_results and 
                                                (not formatted_combination_results or formatted_individual_results[0]['Total Return'] >= formatted_combination_results[0]['Total Return'])
                                                else (formatted_combination_results[0]['Strategy'] if formatted_combination_results else 'N/A')),
                                        " dengan return ",
                                        html.Strong(f"{max([r['Total Return'] for r in formatted_individual_results + formatted_combination_results]):.2f}%" if (formatted_individual_results or formatted_combination_results) else "0%"),
                                        "."
                                    ], className="mb-2"),
                                    html.P([
                                        "ðŸ“ˆ Rata-rata win rate: ",
                                        html.Strong(f"{sum([r['Win Rate'] for r in formatted_individual_results + formatted_combination_results]) / len(formatted_individual_results + formatted_combination_results):.1f}%" if (formatted_individual_results or formatted_combination_results) else "0%"),
                                        "."
                                    ], className="mb-2")
                                ], className="p-4 bg-blue-50 rounded-lg border border-blue-200")
                            ])
                        ], className="mt-4")
                    ])
                ])
            ], className="mt-6 mb-6 p-4 bg-white rounded shadow-sm")
        ])


    # individual combination
    def analyze_individual_indicator(ticker, indicator_name, trades, indicator_result, all_combinations_log=None):
        """
        Analisis mendalam untuk indikator individual.
        DIPERBARUI: Menerima dan meneruskan `all_combinations_log` untuk analisis volume detail.
        """
        if not trades:
            return None
        
        # ... (kode yang sudah ada dari awal sampai akhir, tidak perlu diubah) ...
        buy_trades = [t for t in trades if t['type'] == 'Buy']
        sell_trades = [t for t in trades if t['type'] == 'Sell']
        
        trade_pairs = []
        current_buy = None
        sorted_trades = sorted(trades, key=lambda x: x['date'])
        
        for trade in sorted_trades:
            if trade['type'] == 'Buy':
                current_buy = trade
            elif trade['type'] == 'Sell' and current_buy:
                try:
                    if hasattr(current_buy['date'], 'date') and hasattr(trade['date'], 'date'):
                        holding_period = (trade['date'] - current_buy['date']).days
                    else:
                        buy_date = pd.to_datetime(current_buy['date'])
                        sell_date = pd.to_datetime(trade['date'])
                        holding_period = (sell_date - buy_date).days
                except:
                    holding_period = 1
                        
                price_change = (trade['price'] - current_buy['price']) / current_buy['price'] * 100
                
                if 'value' in trade and 'value' in current_buy:
                    profit = trade['value'] - current_buy['value']
                else:
                    shares = current_buy.get('shares', 0)
                    profit = shares * (trade['price'] - current_buy['price'])
                
                trade_pairs.append({
                    'buy_date': current_buy['date'],
                    'sell_date': trade['date'],
                    'buy_price': current_buy['price'],
                    'sell_price': trade['price'],
                    'holding_period': max(1, holding_period),
                    'price_change': price_change,
                    'profit': profit,
                    'shares': current_buy.get('shares', 0)
                })
                current_buy = None
        
        total_trades_count = len(trade_pairs)
        if total_trades_count == 0:
            return None
        
        profitable_trades = [t for t in trade_pairs if t['profit'] > 0]
        losing_trades = [t for t in trade_pairs if t['profit'] <= 0]
        
        avg_holding_period = sum(t['holding_period'] for t in trade_pairs) / total_trades_count
        avg_profit_per_trade = sum(t['profit'] for t in trade_pairs) / total_trades_count
        win_rate = (len(profitable_trades) / total_trades_count * 100)
        
        total_profit = indicator_result.get('total_profit', sum(t['profit'] for t in trade_pairs))
        return_percentage = indicator_result.get('profit_percentage', 0)
        
        return {
            'ticker': ticker,
            'indicator': indicator_name,
            'strategy': f"{ticker} - {indicator_name}", # Tambahkan kunci strategi untuk konsistensi
            'total_trades': total_trades_count,
            'profitable_trades': len(profitable_trades),
            'losing_trades': len(losing_trades),
            'win_rate': win_rate,
            'avg_holding_period': avg_holding_period,
            'avg_profit_per_trade': avg_profit_per_trade,
            'total_profit': total_profit,
            'return_percentage': return_percentage,
            'trade_pairs': trade_pairs,
            'buy_signals': len(buy_trades),
            'sell_signals': len(sell_trades),
            # 'volume_analysis_summary': indicator_result.get('volume_analysis_summary', 'N/A'),
            # 'detailed_combinations_log': all_combinations_log
            'volume_analysis_summary': indicator_result.get('volume_analysis_summary', 'N/A'),
            # KUNCI PERBAIKAN: Selalu sertakan kunci ini, bahkan jika nilainya None atau []
            'detailed_combinations_log': all_combinations_log if all_combinations_log is not None else []
            # BARU: Simpan log detail untuk tab analisis volume
            # 'detailed_combinations_log': all_combinations_log 
        }


    def analyze_indicator_combinations(processed_data, ticker_details, trade_details):
        """
        Analisis kombinasi indikator DENGAN BATAS GLOBAL untuk efisiensi.
        Fungsi ini sekarang dirancang untuk dipanggil SATU KALI dengan data gabungan.
        """
        # --- PERUBAHAN: Tambahkan Batas Global ---
        MAX_DIFFERENT_COMBINATIONS = 5000

        df = pd.DataFrame(processed_data)
        combination_results = []
        
        all_indicators = df['Analysis_info'].unique()
        all_tickers = df['Title'].unique()
        
        # Test kombinasi indikator untuk setiap ticker
        for ticker in all_tickers:
            ticker_df = df[df['Title'] == ticker]
            
            for buy_indicator in all_indicators:
                for sell_indicator in all_indicators:
                    if buy_indicator == sell_indicator:
                        continue
                    
                    # --- PERUBAHAN: Cek batas SEBELUM melakukan kalkulasi berat ---
                    if len(combination_results) >= MAX_DIFFERENT_COMBINATIONS:
                        print(f"INFO: Batas global {MAX_DIFFERENT_COMBINATIONS} kombinasi tercapai. Menghentikan analisis kombinasi.")
                        return combination_results # Keluar dari fungsi secepatnya
                    
                    buy_signals = ticker_df[
                        (ticker_df['Analysis_info'] == buy_indicator) & 
                        (ticker_df['Signal'] == 'Buy')
                    ].sort_values('Datetime')
                    
                    sell_signals = ticker_df[
                        (ticker_df['Analysis_info'] == sell_indicator) & 
                        (ticker_df['Signal'] == 'Sell')
                    ].sort_values('Datetime')
                    
                    if buy_signals.empty or sell_signals.empty:
                        continue
                    
                    combo_result = simulate_combination_trading_advanced(
                        ticker, buy_indicator, sell_indicator, buy_signals, sell_signals
                    )
                    
                    if combo_result:
                        combination_results.append(combo_result)
        
        return combination_results


    # def simulate_combination_trading(ticker, buy_indicator, sell_indicator, buy_signals, sell_signals):
    #     """Simulasi trading dengan kombinasi indikator"""
    #     initial_capital = 10000000
    #     current_capital = initial_capital
    #     position = None
    #     trades = []
        
    #     # Gabungkan dan urutkan sinyal berdasarkan waktu
    #     all_signals = pd.concat([
    #         buy_signals[['Datetime', 'Price', 'Signal', 'Volume', 'Analysis_info']],
    #         sell_signals[['Datetime', 'Price', 'Signal', 'Volume', 'Analysis_info']]
    #     ]).sort_values('Datetime')
        
    #     # Jalankan simulasi trading
    #     for idx, row in all_signals.iterrows():
    #         if position is None and row['Signal'] == 'Buy' and row['Analysis_info'] == buy_indicator:
    #             # Buka posisi
    #             shares = current_capital // row['Price']
    #             if shares > 0:
    #                 position = {
    #                     'entry_date': row['Datetime'],
    #                     'entry_price': row['Price'],
    #                     'entry_volume': row['Volume'],
    #                     'shares': shares,
    #                     'cost': shares * row['Price'],
    #                     'buy_indicator': row['Analysis_info']
    #                 }
    #                 current_capital -= position['cost']
                    
    #         elif position is not None and row['Signal'] == 'Sell' and row['Analysis_info'] == sell_indicator:
    #             # Tutup posisi
    #             proceeds = position['shares'] * row['Price']
    #             profit = proceeds - position['cost']
                
    #             trades.append({
    #                 'entry_date': position['entry_date'],
    #                 'exit_date': row['Datetime'],
    #                 'entry_price': position['entry_price'],
    #                 'exit_price': row['Price'],
    #                 'shares': position['shares'],
    #                 'profit': profit,
    #                 'return_pct': (profit / position['cost']) * 100,
    #                 'holding_period': (row['Datetime'] - position['entry_date']).days,
    #                 'buy_indicator': position['buy_indicator'],
    #                 'sell_indicator': row['Analysis_info']
    #             })
    #             current_capital += proceeds
    #             position = None
        
    #     # Hitung metrik
    #     if not trades:
    #         return None
        
    #     total_profit = sum(t['profit'] for t in trades)
    #     winning_trades = len([t for t in trades if t['profit'] > 0])
    #     return_percentage = ((current_capital - initial_capital) / initial_capital) * 100
        
    #     return {
    #         'ticker': ticker,
    #         'strategy': f"{buy_indicator} (Buy) + {sell_indicator} (Sell)",
    #         'buy_indicator': buy_indicator,
    #         'sell_indicator': sell_indicator,
    #         'total_trades': len(trades),
    #         'winning_trades': winning_trades,
    #         'win_rate': (winning_trades / len(trades)) * 100,
    #         'total_profit': total_profit,
    #         'return_percentage': return_percentage,
    #         'final_capital': current_capital,
    #         'trades': trades
    #     }

    # def simulate_combination_trading(ticker, buy_indicator, sell_indicator, buy_signals, sell_signals):
    #     """
    #     Simulasi trading dengan kombinasi indikator.
    #     DIPERBAIKI: Sekarang menghitung metrik detail seperti avg_holding_period dan analisis volume
    #     untuk konsistensi dengan analisis individual.
    #     """
    #     initial_capital = 10000000
    #     current_capital = initial_capital
    #     position = None
    #     trades = []
        
    #     # Gabungkan dan urutkan sinyal berdasarkan waktu
    #     all_signals = pd.concat([
    #         buy_signals[['Datetime', 'Price', 'Signal', 'Volume', 'Analysis_info']],
    #         sell_signals[['Datetime', 'Price', 'Signal', 'Volume', 'Analysis_info']]
    #     ]).sort_values('Datetime')
        
    #     # Jalankan simulasi trading
    #     for idx, row in all_signals.iterrows():
    #         # Buka posisi hanya jika tidak ada posisi, sinyalnya 'Buy', dan dari indikator yang benar
    #         if position is None and row['Signal'] == 'Buy' and row['Analysis_info'] == buy_indicator:
    #             shares = current_capital // row['Price']
    #             if shares > 0:
    #                 position = {
    #                     'entry_date': row['Datetime'],
    #                     'entry_price': row['Price'],
    #                     'entry_volume': row['Volume'], # Simpan volume beli
    #                     'shares': shares,
    #                     'cost': shares * row['Price'],
    #                     'buy_indicator': row['Analysis_info']
    #                 }
    #                 current_capital -= position['cost']
                    
    #         # Tutup posisi hanya jika ada posisi, sinyalnya 'Sell', dan dari indikator yang benar
    #         elif position is not None and row['Signal'] == 'Sell' and row['Analysis_info'] == sell_indicator:
    #             # Pastikan tanggal jual setelah tanggal beli
    #             if row['Datetime'] > position['entry_date']:
    #                 proceeds = position['shares'] * row['Price']
    #                 profit = proceeds - position['cost']
                    
    #                 trades.append({
    #                     'entry_date': position['entry_date'],
    #                     'exit_date': row['Datetime'],
    #                     'entry_price': position['entry_price'],
    #                     'exit_price': row['Price'],
    #                     'entry_volume': position['entry_volume'], # Tambahkan volume beli
    #                     'exit_volume': row['Volume'], # Tambahkan volume jual
    #                     'shares': position['shares'],
    #                     'profit': profit,
    #                     'return_pct': (profit / position['cost']) * 100 if position['cost'] > 0 else 0,
    #                     'holding_period': (row['Datetime'] - position['entry_date']).days or 1, # Minimal 1 hari
    #                     'buy_indicator': position['buy_indicator'],
    #                     'sell_indicator': row['Analysis_info']
    #                 })
    #                 current_capital += proceeds
    #                 position = None
        
    #     # --- MULAI LOGIKA ANALISIS BARU ---
    #     if not trades:
    #         return None
        
    #     # Hitung metrik performa
    #     total_profit = sum(t['profit'] for t in trades)
    #     winning_trades_list = [t for t in trades if t['profit'] > 0]
    #     losing_trades_list = [t for t in trades if t['profit'] <= 0]
        
    #     total_trades_count = len(trades)
    #     winning_trades_count = len(winning_trades_list)
    #     win_rate = (winning_trades_count / total_trades_count) * 100 if total_trades_count > 0 else 0
    #     return_percentage = ((current_capital - initial_capital) / initial_capital) * 100
        
    #     # Hitung avg holding period
    #     avg_holding_period = sum(t['holding_period'] for t in trades) / total_trades_count if total_trades_count > 0 else 0
        
    #     # Analisis Volume Sederhana (berdasarkan trade yang dieksekusi)
    #     avg_buy_volume_win = sum(t['entry_volume'] for t in winning_trades_list) / len(winning_trades_list) if winning_trades_list else 0
    #     avg_buy_volume_loss = sum(t['entry_volume'] for t in losing_trades_list) / len(losing_trades_list) if losing_trades_list else 0
        
    #     avg_sell_volume_win = sum(t['exit_volume'] for t in winning_trades_list) / len(winning_trades_list) if winning_trades_list else 0
    #     avg_sell_volume_loss = sum(t['exit_volume'] for t in losing_trades_list) / len(losing_trades_list) if losing_trades_list else 0

    #     volume_conclusion = []
    #     if avg_buy_volume_win > 0 and avg_buy_volume_loss > 0:
    #         if avg_buy_volume_win > avg_buy_volume_loss:
    #             volume_conclusion.append("Higher buy volume correlated with wins.")
    #         else:
    #             volume_conclusion.append("Lower buy volume correlated with wins.")
        
    #     if avg_sell_volume_win > 0 and avg_sell_volume_loss > 0:
    #         if avg_sell_volume_win > avg_sell_volume_loss:
    #             volume_conclusion.append("Higher sell volume on wins (profit taking).")
    #         else:
    #             volume_conclusion.append("Lower sell volume on wins.")

    #     volume_summary = " ".join(volume_conclusion) if volume_conclusion else "Insufficient data for volume analysis."
        
    #     # --- AKHIR LOGIKA ANALISIS BARU ---

    #     return {
    #         'ticker': ticker,
    #         'strategy': f"{buy_indicator} (Buy) + {sell_indicator} (Sell)",
    #         'buy_indicator': buy_indicator,
    #         'sell_indicator': sell_indicator,
    #         'total_trades': total_trades_count,
    #         'winning_trades': winning_trades_count,
    #         'win_rate': win_rate,
    #         'total_profit': total_profit,
    #         'return_percentage': return_percentage,
    #         'final_capital': current_capital,
    #         'trades': trades,
    #         # --- KUNCI BARU UNTUK KONSISTENSI ---
    #         'avg_holding_period': avg_holding_period,
    #         'num_executed_cycles': total_trades_count, # Untuk kombinasi, 1 trade = 1 siklus
    #         'volume_analysis_summary': volume_summary
    #     }

    def simulate_combination_trading_advanced(ticker, buy_indicator, sell_indicator, buy_signals, sell_signals):
        """
        Simulasi trading dengan kombinasi indikator yang SANGAT DIOPTIMALKAN.

        PERUBAHAN:
        - Menambahkan BATAS GLOBAL (MAX_TOTAL_TRADES) untuk menghentikan simulasi 
        setelah sejumlah trade tertentu dieksekusi, demi kecepatan maksimum.
        """
        initial_capital = 1000000
        # Batas per siklus (seperti sebelumnya, untuk kecepatan di dalam siklus)
        MAX_COMBINATIONS_TO_LOG = 1
        # --- PERUBAHAN UNTUK BATAS GLOBAL ---
        # Batas total trade yang akan dieksekusi sebelum simulasi berhenti
        MAX_TOTAL_TRADES = 5000
        
        try:
            cash = float(initial_capital)
        except (ValueError, TypeError):
            print(f"ERROR: Invalid capital value for combination trading")
            return None

        all_signals = pd.concat([buy_signals, sell_signals]).sort_values('Datetime').reset_index(drop=True)
        
        trades = []
        all_combinations_log = []
        
        in_buy_cycle = False
        cycle_start_index = -1

        for i, row in all_signals.iterrows():
            is_buy_signal = (row['Signal'] == 'Buy' and row['Analysis_info'] == buy_indicator)
            
            if not in_buy_cycle and is_buy_signal:
                future_sells = all_signals[
                    (all_signals.index > i) &
                    (all_signals['Signal'] == 'Sell') &
                    (all_signals['Analysis_info'] == sell_indicator)
                ]
                if not future_sells.empty:
                    in_buy_cycle = True
                    cycle_start_index = i
                else:
                    break

            elif in_buy_cycle and (row['Signal'] == 'Sell' and row['Analysis_info'] == sell_indicator):
                cycle_df = all_signals.loc[cycle_start_index:i]
                
                buy_signals_in_cycle = cycle_df[(cycle_df['Signal'] == 'Buy') & (cycle_df['Analysis_info'] == buy_indicator)]
                sell_signals_in_cycle = cycle_df[(cycle_df['Signal'] == 'Sell') & (cycle_df['Analysis_info'] == sell_indicator)]

                if buy_signals_in_cycle.empty or sell_signals_in_cycle.empty:
                    in_buy_cycle = False
                    continue

                combinations_found_in_cycle = []
                stop_searching = False
                for _, buy_row in buy_signals_in_cycle.iterrows():
                    valid_sells = sell_signals_in_cycle[sell_signals_in_cycle['Datetime'] > buy_row['Datetime']]
                    if valid_sells.empty: continue
                    for _, sell_row in valid_sells.iterrows():
                        if len(combinations_found_in_cycle) >= MAX_COMBINATIONS_TO_LOG:
                            stop_searching = True
                            break
                        
                        profit_per_share = sell_row['Price'] - buy_row['Price']
                        combinations_found_in_cycle.append({
                            'cycle_id': len(trades) + 1,
                            'buy_date': buy_row['Datetime'], 'buy_price': buy_row['Price'], 'buy_volume': buy_row['Volume'],
                            'sell_date': sell_row['Datetime'], 'sell_price': sell_row['Price'], 'sell_volume': sell_row['Volume'],
                            'profit_per_share': profit_per_share
                        })
                    if stop_searching:
                        break

                if not combinations_found_in_cycle:
                    in_buy_cycle = False
                    continue
                
                all_combinations_log.extend(combinations_found_in_cycle)
                best_combination_for_execution = max(combinations_found_in_cycle, key=lambda x: x['profit_per_share'])

                if cash > 0:
                    best_buy_price = best_combination_for_execution['buy_price']
                    best_sell_price = best_combination_for_execution['sell_price']
                    
                    shares_to_buy = int(cash / best_buy_price)
                    if shares_to_buy > 0:
                        cost = shares_to_buy * best_buy_price
                        proceeds = shares_to_buy * best_sell_price
                        profit = proceeds - cost
                        
                        cash += profit

                        trade_summary = {
                            'entry_date': best_combination_for_execution['buy_date'],
                            'exit_date': best_combination_for_execution['sell_date'],
                            'entry_price': best_buy_price,
                            'exit_price': best_sell_price,
                            'shares': shares_to_buy,
                            'profit': profit,
                            'return_pct': (profit / cost) * 100 if cost > 0 else 0,
                            'holding_period': max(1, (best_combination_for_execution['sell_date'] - best_combination_for_execution['buy_date']).days)
                        }
                        trades.append(trade_summary)

                in_buy_cycle = False

            # --- PERUBAHAN UNTUK BATAS GLOBAL ---
            # Setelah setiap iterasi, periksa apakah batas total trade telah tercapai
            if len(trades) >= MAX_TOTAL_TRADES:
                print(f"INFO: Batas global {MAX_TOTAL_TRADES} trade telah tercapai. Menghentikan simulasi untuk efisiensi.")
                break # Keluar dari loop utama 'for i, row...'

        # Kalkulasi sisa tetap sama, hanya akan berjalan pada data yang sudah diproses
        if not trades:
            return None

        final_portfolio_value = cash
        total_profit = final_portfolio_value - initial_capital
        profit_percentage = (total_profit / initial_capital) * 100 if initial_capital > 0 else 0
        
        total_executed_cycles = len(trades)
        winning_trades_executed = len([t for t in trades if t['profit'] > 0])
        total_holding_period_days = sum(t['holding_period'] for t in trades)

        win_rate = (winning_trades_executed / total_executed_cycles) * 100 if total_executed_cycles > 0 else 0
        avg_holding_period = total_holding_period_days / total_executed_cycles if total_executed_cycles > 0 else 0
        
        volume_summary = "Tidak cukup data untuk analisis volume."
        if all_combinations_log:
            analysis_df = pd.DataFrame(all_combinations_log)
            if not analysis_df.empty:
                analysis_df['is_win'] = analysis_df['profit_per_share'] > 0
                
                has_wins = 'buy_volume' in analysis_df.columns and analysis_df['is_win'].any()
                has_losses = 'buy_volume' in analysis_df.columns and (~analysis_df['is_win']).any()

                avg_buy_volume_win = analysis_df[analysis_df['is_win']]['buy_volume'].mean() if has_wins else np.nan
                avg_buy_volume_loss = analysis_df[~analysis_df['is_win']]['buy_volume'].mean() if has_losses else np.nan
                avg_sell_volume_win = analysis_df[analysis_df['is_win']]['sell_volume'].mean() if has_wins else np.nan
                avg_sell_volume_loss = analysis_df[~analysis_df['is_win']]['sell_volume'].mean() if has_losses else np.nan

                summary_lines = []
                if not pd.isna(avg_buy_volume_win) and not pd.isna(avg_buy_volume_loss):
                    if avg_buy_volume_win > avg_buy_volume_loss:
                        summary_lines.append(f"Analisis Volume Beli: Rata-rata volume pada sinyal Beli yang profit ({avg_buy_volume_win:,.0f}) lebih TINGGI daripada yang rugi ({avg_buy_volume_loss:,.0f}).")
                    else:
                        summary_lines.append(f"Analisis Volume Beli: Rata-rata volume pada sinyal Beli yang profit ({avg_buy_volume_win:,.0f}) lebih RENDAH/serupa daripada yang rugi ({avg_buy_volume_loss:,.0f}).")
                
                if not pd.isna(avg_sell_volume_win) and not pd.isna(avg_sell_volume_loss):
                    if avg_sell_volume_win > avg_sell_volume_loss:
                        summary_lines.append(f"Analisis Volume Jual: Rata-rata volume pada sinyal Jual yang profit ({avg_sell_volume_win:,.0f}) lebih TINGGI daripada yang rugi ({avg_sell_volume_loss:,.0f}).")
                    else:
                        summary_lines.append(f"Analisis Volume Jual: Rata-rata volume pada sinyal Jual yang profit ({avg_sell_volume_win:,.0f}) lebih RENDAH/serupa daripada yang rugi ({avg_sell_volume_loss:,.0f}).")
                
                volume_summary = "\n".join(summary_lines) if summary_lines else "Korelasi volume tidak dapat disimpulkan."

        return {
            'ticker': ticker,
            'strategy': f"{ticker} - {buy_indicator} (Buy) + {sell_indicator} (Sell)",
            'buy_indicator': buy_indicator,
            'sell_indicator': sell_indicator,
            'initial_capital': initial_capital,
            'final_capital': final_portfolio_value,
            'total_profit': total_profit,
            'return_percentage': profit_percentage,
            'num_executed_cycles': total_executed_cycles,
            'total_trades': total_executed_cycles,
            'winning_trades': winning_trades_executed,
            'win_rate': win_rate,
            'avg_holding_period': avg_holding_period,
            'volume_analysis_summary': volume_summary,
            'trades': trades,
            'all_possible_combinations': all_combinations_log,
        }

    # OLDDD
    # def simulate_combination_trading_advanced(ticker, buy_indicator, sell_indicator, buy_signals, sell_signals):
    #     """
    #     Simulasi trading dengan kombinasi indikator menggunakan LOGIKA IDENTIK
    #     dengan 'run_backtest_for_indicator' dan struktur output yang konsisten.
        
    #     PERBAIKAN:
    #     1. Mengatasi `KeyError: 'entry_date'` dengan mengubah struktur output 'trades' menjadi 
    #     list dari dictionary transaksi lengkap (seperti 'trade_pairs').
    #     2. Menghilangkan `FutureWarning` dari Pandas dengan memperbaiki logika pemfilteran.
    #     """
    #     initial_capital = 10000000
    #     cash = float(initial_capital)
        
    #     # Gabungkan sinyal dan urutkan, reset index untuk pengindeksan yang lebih mudah
    #     all_signals = pd.concat([buy_signals, sell_signals]).sort_values('Datetime').reset_index(drop=True)
        
    #     # REVISED: Menggunakan list untuk menyimpan pasangan trade yang sudah lengkap, bukan aksi terpisah
    #     executed_trades = []
    #     all_combinations_log = []
        
    #     in_buy_cycle = False
    #     cycle_start_index = -1

    #     for i, row in all_signals.iterrows():
    #         is_buy_signal = (row['Signal'] == 'Buy' and row['Analysis_info'] == buy_indicator)
    #         is_sell_signal = (row['Signal'] == 'Sell' and row['Analysis_info'] == sell_indicator)

    #         if not in_buy_cycle and is_buy_signal:
    #             # FIX: Mengatasi FutureWarning dengan menggunakan filter boolean yang lebih eksplisit
    #             # Ini memastikan index selalu selaras.
    #             future_sells = all_signals[
    #                 (all_signals.index > i) & 
    #                 (all_signals['Signal'] == 'Sell') & 
    #                 (all_signals['Analysis_info'] == sell_indicator)
    #             ]
    #             if not future_sells.empty:
    #                 in_buy_cycle = True
    #                 cycle_start_index = i
            
    #         elif in_buy_cycle and is_sell_signal:
    #             cycle_df = all_signals.loc[cycle_start_index:i]
                
    #             buy_signals_in_cycle = cycle_df[cycle_df['Analysis_info'] == buy_indicator]
    #             sell_signals_in_cycle = cycle_df[cycle_df['Analysis_info'] == sell_indicator]

    #             if buy_signals_in_cycle.empty or sell_signals_in_cycle.empty:
    #                 in_buy_cycle = False
    #                 continue

    #             best_combination_for_execution = None
    #             max_profit_per_share = -np.inf

    #             for _, buy_row in buy_signals_in_cycle.iterrows():
    #                 valid_sells = sell_signals_in_cycle[sell_signals_in_cycle['Datetime'] > buy_row['Datetime']]
    #                 if valid_sells.empty: continue

    #                 for _, sell_row in valid_sells.iterrows():
    #                     profit_per_share = sell_row['Price'] - buy_row['Price']
                        
    #                     current_combination = {
    #                         'cycle_id': len(executed_trades) + 1,
    #                         'buy_date': buy_row['Datetime'], 'buy_price': buy_row['Price'], 'buy_volume': buy_row['Volume'],
    #                         'sell_date': sell_row['Datetime'], 'sell_price': sell_row['Price'], 'sell_volume': sell_row['Volume'],
    #                         'profit_per_share': profit_per_share
    #                     }
    #                     all_combinations_log.append(current_combination)
                        
    #                     if profit_per_share > max_profit_per_share:
    #                         max_profit_per_share = profit_per_share
    #                         best_combination_for_execution = current_combination
                
    #             if best_combination_for_execution:
    #                 if cash > 0:
    #                     best_buy_price = best_combination_for_execution['buy_price']
    #                     best_sell_price = best_combination_for_execution['sell_price']
                        
    #                     shares_to_buy = int(cash / best_buy_price)
    #                     if shares_to_buy > 0:
    #                         cost = shares_to_buy * best_buy_price
    #                         proceeds = shares_to_buy * best_sell_price
    #                         profit = proceeds - cost
                            
    #                         # REVISED: Membuat satu log lengkap untuk setiap trade yang dieksekusi
    #                         # Ini menyelesaikan 'KeyError' karena strukturnya sekarang konsisten.
    #                         trade_log = {
    #                             'entry_date': best_combination_for_execution['buy_date'],
    #                             'exit_date': best_combination_for_execution['sell_date'],
    #                             'entry_price': best_buy_price,
    #                             'exit_price': best_sell_price,
    #                             'shares': shares_to_buy,
    #                             'profit': profit,
    #                             'return_pct': (profit / cost) * 100 if cost > 0 else 0,
    #                             'holding_period': max(1, (best_combination_for_execution['sell_date'] - best_combination_for_execution['buy_date']).days)
    #                         }
    #                         executed_trades.append(trade_log)
                            
    #                         cash += profit
                
    #             in_buy_cycle = False

    #     # REVISED: Kalkulasi metrik dari list trade pairs yang sudah lengkap
    #     if not executed_trades:
    #         return None

    #     total_executed_cycles = len(executed_trades)
    #     final_capital = cash
    #     total_profit = final_capital - initial_capital
    #     profit_percentage = (total_profit / initial_capital) * 100 if initial_capital > 0 else 0
        
    #     winning_trades_executed = len([t for t in executed_trades if t['profit'] > 0])
    #     total_holding_period = sum(t['holding_period'] for t in executed_trades)

    #     win_rate = (winning_trades_executed / total_executed_cycles) * 100 if total_executed_cycles > 0 else 0
    #     avg_holding_period = total_holding_period / total_executed_cycles if total_executed_cycles > 0 else 0

    #     # --- PERUBAHAN DIMULAI DI SINI ---
    #     # Analisis Volume yang lebih informatif dan selaras
    #     volume_summary = "Tidak cukup data untuk analisis volume."
    #     if all_combinations_log:
    #         analysis_df = pd.DataFrame(all_combinations_log)
    #         if not analysis_df.empty:
    #             analysis_df['is_win'] = analysis_df['profit_per_share'] > 0
                
    #             # Cek apakah ada data untuk kelompok menang dan kalah
    #             has_wins = 'buy_volume' in analysis_df.columns and analysis_df['is_win'].any()
    #             has_losses = 'buy_volume' in analysis_df.columns and (~analysis_df['is_win']).any()

    #             avg_buy_volume_win = analysis_df[analysis_df['is_win']]['buy_volume'].mean() if has_wins else np.nan
    #             avg_buy_volume_loss = analysis_df[~analysis_df['is_win']]['buy_volume'].mean() if has_losses else np.nan
                
    #             summary_lines = []
    #             # Analisis Volume Beli
    #             if not pd.isna(avg_buy_volume_win) and not pd.isna(avg_buy_volume_loss):
    #                 if avg_buy_volume_win > avg_buy_volume_loss:
    #                     summary_lines.append(f"Analisis Volume Beli: Rata-rata volume pada sinyal Beli yang profit ({avg_buy_volume_win:,.0f}) lebih TINGGI daripada yang rugi ({avg_buy_volume_loss:,.0f}). Ini mengindikasikan sinyal beli lebih valid saat didukung volume besar.")
    #                 else:
    #                     summary_lines.append(f"Analisis Volume Beli: Rata-rata volume pada sinyal Beli yang profit ({avg_buy_volume_win:,.0f}) lebih RENDAH/serupa daripada yang rugi ({avg_buy_volume_loss:,.0f}). Ini bisa berarti pembelian yang menguntungkan terjadi di kondisi pasar yang lebih tenang.")
    #             else:
    #                 summary_lines.append("Analisis Volume Beli: Korelasi volume beli dengan profit tidak dapat disimpulkan (data tidak lengkap).")
                
    #             volume_summary = "\n".join(summary_lines)
    #     # --- PERUBAHAN SELESAI DI SINI ---

    #     return {
    #         'ticker': ticker,
    #         'strategy': f"{ticker} - {buy_indicator} (Buy) + {sell_indicator} (Sell)", # Buat kunci strategi yang unik
    #         'buy_indicator': buy_indicator,
    #         'sell_indicator': sell_indicator,
    #         'total_trades': total_executed_cycles,
    #         'winning_trades': winning_trades_executed,
    #         'win_rate': win_rate,
    #         'total_profit': total_profit,
    #         'return_percentage': profit_percentage,
    #         'final_capital': final_capital,
    #         'avg_holding_period': avg_holding_period,
    #         'num_executed_cycles': total_executed_cycles,
    #         'volume_analysis_summary': volume_summary,
    #         'trades': executed_trades,
    #         # BARU: Ganti nama kunci agar konsisten dan mudah diakses
    #         'detailed_combinations_log': all_combinations_log 
    #     }


    # def generate_enhanced_global_analysis_results(df, ticker_details, all_tickers, all_indicators, individual_results, combination_results):
    #     """Generate hasil analisis global yang diperkaya dengan penjelasan lengkap"""
    #     try:
    #         components = []
            
    #         # === RINGKASAN EKSEKUTIF ===
    #         components.append(html.Div([
    #             html.H3("ðŸ“‹ Ringkasan Eksekutif", className="text-xl font-bold mb-3 text-blue-700"),
    #             html.Div([
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Total Ticker Dianalisis", className="block text-sm text-gray-500"),
    #                         html.Span(f"{len(all_tickers)}", className="block text-2xl font-bold text-blue-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Indikator Teknikal", className="block text-sm text-gray-500"),
    #                         html.Span(f"{len(all_indicators)}", className="block text-2xl font-bold text-green-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Strategi Individual", className="block text-sm text-gray-500"),
    #                         html.Span(f"{len(individual_results)}", className="block text-2xl font-bold text-purple-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #                 html.Div([
    #                     html.Div([
    #                         html.Span("Strategi Kombinasi", className="block text-sm text-gray-500"),
    #                         html.Span(f"{len(combination_results)}", className="block text-2xl font-bold text-orange-600")
    #                     ], className="p-4 border rounded bg-white shadow-sm text-center")
    #                 ], className="w-1/4 px-2"),
    #             ], className="flex -mx-2 mb-6"),
                
    #             # Penjelasan metodologi
    #             html.Div([
    #                 html.H4("ðŸ”¬ Metodologi Analisis", className="text-lg font-semibold mb-3"),
    #                 html.P("Sistem melakukan backtesting komprehensif dengan menguji setiap indikator teknikal secara individual maupun dalam kombinasi. "
    #                     "Analisis mencakup evaluasi entry point, exit point, holding period, dan performa profitabilitas untuk setiap strategi.", 
    #                     className="text-gray-700 mb-2"),
    #                 html.P("Kombinasi indikator diuji dengan menggunakan sinyal buy dari satu indikator dan sinyal sell dari indikator lain, "
    #                     "memberikan fleksibilitas strategi yang lebih beragam dibandingkan pendekatan konvensional.", 
    #                     className="text-gray-700"),
    #             ], className="p-4 bg-blue-50 rounded-lg border border-blue-200 mb-6")
    #         ]))
            
    #         # === ANALISIS STRATEGI INDIVIDUAL ===
    #         if individual_results:
    #             # Sort berdasarkan return percentage
    #             individual_results_sorted = sorted(individual_results, key=lambda x: x['return_percentage'], reverse=True)
    #             best_individual = individual_results_sorted[0]
                
    #             components.append(html.Div([
    #                 html.H3("ðŸŽ¯ Analisis Strategi Individual", className="text-xl font-bold mb-3 text-green-700"),
                    
    #                 # Best individual strategy
    #                 html.Div([
    #                     html.H4("ðŸ¥‡ Strategi Individual Terbaik", className="text-lg font-semibold mb-2 text-green-600"),
    #                     html.Div([
    #                         html.Div([
    #                             html.Span("Ticker: ", className="font-semibold"),
    #                             html.Span(best_individual['ticker'], className="ml-1 text-blue-600 text-lg")
    #                         ], className="mb-2"),
    #                         html.Div([
    #                             html.Span("Indikator: ", className="font-semibold"),
    #                             html.Span(best_individual['indicator'], className="ml-1 text-blue-600 text-lg")
    #                         ], className="mb-2"),
    #                         html.Div([
    #                             html.Span("Return: ", className="font-semibold"),
    #                             html.Span(f"{best_individual['return_percentage']:.2f}%", 
    #                                     className=f"ml-1 text-lg font-bold {'text-green-600' if best_individual['return_percentage'] >= 0 else 'text-red-600'}")
    #                         ], className="mb-2"),
    #                         html.Div([
    #                             html.Span("Win Rate: ", className="font-semibold"),
    #                             html.Span(f"{best_individual['win_rate']:.1f}%", className="ml-1 text-blue-600")
    #                         ], className="mb-2"),
    #                     ], className="p-4 bg-gradient-to-r from-green-50 to-blue-50 rounded-lg border border-green-200 mb-4")
    #                 ]),
                    
    #                 # Individual insights
    #                 html.Div([
    #                     html.H4("ðŸ’¡ Insights Strategi Individual", className="text-lg font-semibold mb-3"),
    #                     html.P([
    #                         f"Strategi individual terbaik menggunakan indikator ",
    #                         html.Strong(best_individual['indicator']),
    #                         f" pada ticker ",
    #                         html.Strong(best_individual['ticker']),
    #                         f" berhasil menghasilkan return sebesar ",
    #                         html.Strong(f"{best_individual['return_percentage']:.2f}%"),
    #                         f" dengan melakukan ",
    #                         html.Strong(f"{best_individual['total_trades']} transaksi"),
    #                         "."
    #                     ], className="mb-3"),
    #                     html.P([
    #                         f"Dari total {best_individual['total_trades']} transaksi, ",
    #                         html.Strong(f"{best_individual['profitable_trades']} transaksi menghasilkan profit"),
    #                         f" dan ",
    #                         html.Strong(f"{best_individual['losing_trades']} transaksi mengalami kerugian"),
    #                         f", memberikan win rate sebesar ",
    #                         html.Strong(f"{best_individual['win_rate']:.1f}%"),
    #                         "."
    #                     ], className="mb-3"),
    #                     html.P([
    #                         f"Rata-rata holding period untuk strategi ini adalah ",
    #                         html.Strong(f"{best_individual['avg_holding_period']:.1f} hari"),
    #                         f" dengan rata-rata profit per transaksi sebesar ",
    #                         html.Strong(f"Rp {best_individual['avg_profit_per_trade']:,.0f}"),
    #                         "."
    #                     ], className="mb-3"),
    #                 ], className="p-4 bg-green-50 rounded-lg border border-green-200 mb-4"),
                    
    #                 # Top 10 individual strategies table
    #                 html.Div([
    #                     html.H4("ðŸ“Š Top 10 Strategi Individual", className="text-lg font-semibold mb-3"),
    #                     dash_table.DataTable(
    #                         data=[{
    #                             'Rank': i+1,
    #                             'Ticker': r['ticker'],
    #                             'Indikator': r['indicator'],
    #                             'Return %': f"{r['return_percentage']:.2f}%",
    #                             'Total Profit': f"Rp {r['total_profit']:,.0f}",
    #                             'Win Rate': f"{r['win_rate']:.1f}%",
    #                             'Total Trades': r['total_trades'],
    #                             'Avg Holding': f"{r['avg_holding_period']:.1f} hari"
    #                         } for i, r in enumerate(individual_results_sorted[:10])],
    #                         columns=[
    #                             {'name': '#', 'id': 'Rank'},
    #                             {'name': 'Ticker', 'id': 'Ticker'},
    #                             {'name': 'Indikator', 'id': 'Indikator'},
    #                             {'name': 'Return %', 'id': 'Return %'},
    #                             {'name': 'Total Profit', 'id': 'Total Profit'},
    #                             {'name': 'Win Rate', 'id': 'Win Rate'},
    #                             {'name': 'Total Trades', 'id': 'Total Trades'},
    #                             {'name': 'Avg Holding', 'id': 'Avg Holding'}
    #                         ],
    #                         style_table={'overflowX': 'auto'},
    #                         style_cell={'textAlign': 'left', 'padding': '10px'},
    #                         style_header={
    #                             'backgroundColor': 'rgb(240, 240, 240)',
    #                             'fontWeight': 'bold'
    #                         },
    #                         style_data_conditional=[
    #                             {
    #                                 'if': {'row_index': 0},
    #                                 'backgroundColor': 'rgba(255, 215, 0, 0.3)',
    #                                 'fontWeight': 'bold'
    #                             },
    #                             {
    #                                 'if': {'filter_query': '{Return %} contains "-"'},
    #                                 'color': 'red'
    #                             },
    #                             {
    #                                 'if': {'filter_query': '{Return %} > "0"'},
    #                                 'color': 'green'
    #                             }
    #                         ],
    #                         sort_action='native',
    #                         page_size=10
    #                     )
    #                 ], className="mb-6")
    #             ]))
            
    #         # === ANALISIS STRATEGI KOMBINASI ===
    #         if combination_results:
    #             combination_results_sorted = sorted(combination_results, key=lambda x: x['return_percentage'], reverse=True)
    #             best_combination = combination_results_sorted[0]
                
    #             components.append(html.Div([
    #                 html.H3("ðŸ”— Analisis Strategi Kombinasi", className="text-xl font-bold mb-3 text-purple-700"),
                    
    #                 # Best combination strategy
    #                 html.Div([
    #                     html.H4("ðŸ¥‡ Strategi Kombinasi Terbaik", className="text-lg font-semibold mb-2 text-purple-600"),
    #                     html.Div([
    #                         html.Div([
    #                             html.Span("Ticker: ", className="font-semibold"),
    #                             html.Span(best_combination['ticker'], className="ml-1 text-blue-600 text-lg")
    #                         ], className="mb-2"),
    #                         html.Div([
    #                             html.Span("Strategi: ", className="font-semibold"),
    #                             html.Span(best_combination['strategy'], className="ml-1 text-blue-600 text-lg")
    #                         ], className="mb-2"),
    #                         html.Div([
    #                             html.Span("Return: ", className="font-semibold"),
    #                             html.Span(f"{best_combination['return_percentage']:.2f}%", 
    #                                     className=f"ml-1 text-lg font-bold {'text-green-600' if best_combination['return_percentage'] >= 0 else 'text-red-600'}")
    #                         ], className="mb-2"),
    #                         html.Div([
    #                             html.Span("Win Rate: ", className="font-semibold"),
    #                             html.Span(f"{best_combination['win_rate']:.1f}%", className="ml-1 text-blue-600")
    #                         ], className="mb-2"),
    #                     ], className="p-4 bg-gradient-to-r from-purple-50 to-blue-50 rounded-lg border border-purple-200 mb-4")
    #                 ]),
                    
    #                 # Combination insights
    #                 html.Div([
    #                     html.H4("ðŸ’¡ Insights Strategi Kombinasi", className="text-lg font-semibold mb-3"),
    #                     html.P([
    #                         f"Strategi kombinasi terbaik menggunakan ",
    #                         html.Strong(f"{best_combination['buy_indicator']} untuk sinyal buy"),
    #                         f" dan ",
    #                         html.Strong(f"{best_combination['sell_indicator']} untuk sinyal sell"),
    #                         f" pada ticker ",
    #                         html.Strong(best_combination['ticker']),
    #                         f" menghasilkan return sebesar ",
    #                         html.Strong(f"{best_combination['return_percentage']:.2f}%"),
    #                         "."
    #                     ], className="mb-3"),
                        
    #                     # Perbandingan dengan strategi individual
    #                     html.P([
    #                         "Dibandingkan dengan strategi individual terbaik (",
    #                         html.Strong(f"{best_individual['indicator']}"),
    #                         f"), strategi kombinasi ini ",
    #                         html.Strong("berkinerja lebih baik") if best_combination['return_percentage'] > best_individual['return_percentage'] else html.Strong("berkinerja lebih rendah"),
    #                         f" dengan selisih ",
    #                         html.Strong(f"{abs(best_combination['return_percentage'] - best_individual['return_percentage']):.2f}%"),
    #                         "."
    #                     ], className="mb-3"),
                        
    #                     html.P([
    #                         f"Strategi kombinasi menunjukkan win rate sebesar ",
    #                         html.Strong(f"{best_combination['win_rate']:.1f}%"),
    #                         f" dengan total ",
    #                         html.Strong(f"{best_combination['total_trades']} transaksi"),
    #                         f", dimana ",
    #                         html.Strong(f"{best_combination['winning_trades']} transaksi menghasilkan profit"),
    #                         "."
    #                     ], className="mb-3"),
    #                 ], className="p-4 bg-purple-50 rounded-lg border border-purple-200 mb-4"),
                    
    #                 # Top 10 combination strategies table
    #                 html.Div([
    #                     html.H4("ðŸ“Š Top 10 Strategi Kombinasi", className="text-lg font-semibold mb-3"),
    #                     dash_table.DataTable(
    #                         data=[{
    #                             'Rank': i+1,
    #                             'Ticker': r['ticker'],
    #                             'Buy Indicator': r['buy_indicator'],
    #                             'Sell Indicator': r['sell_indicator'],
    #                             'Return %': f"{r['return_percentage']:.2f}%",
    #                             'Total Profit': f"Rp {r['total_profit']:,.0f}",
    #                             'Win Rate': f"{r['win_rate']:.1f}%",
    #                             'Total Trades': r['total_trades']
    #                         } for i, r in enumerate(combination_results_sorted[:10])],
    #                         columns=[
    #                             {'name': '#', 'id': 'Rank'},
    #                             {'name': 'Ticker', 'id': 'Ticker'},
    #                             {'name': 'Buy Indicator', 'id': 'Buy Indicator'},
    #                             {'name': 'Sell Indicator', 'id': 'Sell Indicator'},
    #                             {'name': 'Return %', 'id': 'Return %'},
    #                             {'name': 'Total Profit', 'id': 'Total Profit'},
    #                             {'name': 'Win Rate', 'id': 'Win Rate'},
    #                             {'name': 'Total Trades', 'id': 'Total Trades'}
    #                         ],
    #                         style_table={'overflowX': 'auto'},
    #                         style_cell={'textAlign': 'left', 'padding': '10px'},
    #                         style_header={
    #                             'backgroundColor': 'rgb(240, 240, 240)',
    #                             'fontWeight': 'bold'
    #                         },
    #                         style_data_conditional=[
    #                             {
    #                                 'if': {'row_index': 0},
    #                                 'backgroundColor': 'rgba(147, 51, 234, 0.3)',
    #                                 'fontWeight': 'bold'
    #                             },
    #                             {
    #                                 'if': {'filter_query': '{Return %} contains "-"'},
    #                                 'color': 'red'
    #                             },
    #                             {
    #                                 'if': {'filter_query': '{Return %} > "0"'},
    #                                 'color': 'green'
    #                             }
    #                         ],
    #                         sort_action='native',
    #                         page_size=10
    #                     )
    #                 ], className="mb-6")
    #             ]))
            
    #         # === KESIMPULAN ANALISIS ===
    #         all_strategies = individual_results + combination_results
    #         if all_strategies:
    #             best_overall = max(all_strategies, key=lambda x: x['return_percentage'])
                
    #             components.append(html.Div([
    #                 html.H3("ðŸŽ¯ Kesimpulan dan Rekomendasi", className="text-xl font-bold mb-3 text-red-700"),
    #                 html.Div([
    #                     html.H4("ðŸ“ˆ Strategi Optimal", className="text-lg font-semibold mb-3"),
    #                     html.P([
    #                         "Berdasarkan hasil backtesting komprehensif, ",
    #                         html.Strong(f"strategi {'kombinasi' if best_overall in combination_results else 'individual'} terbaik"),
    #                         " adalah ",
    #                         html.Strong(best_overall.get('strategy', best_overall['indicator'])),
    #                         f" pada ticker ",
    #                         html.Strong(best_overall['ticker']),
    #                         f" dengan return sebesar ",
    #                         html.Strong(f"{best_overall['return_percentage']:.2f}%"),
    #                         "."
    #                     ], className="mb-3"),
                        
    #                     html.P([
    #                         "Analisis menunjukkan bahwa ",
    #                         html.Strong("strategi kombinasi lebih unggul") if len(combination_results) > 0 and combination_results_sorted[0]['return_percentage'] > individual_results_sorted[0]['return_percentage'] else html.Strong("strategi individual lebih stabil"),
    #                         " untuk dataset ini dalam periode yang dianalisis."
    #                     ], className="mb-3"),
                        
    #                     html.P([
    #                         "Rekomendasi: Gunakan strategi optimal yang telah diidentifikasi dengan tetap mempertimbangkan ",
    #                         html.Strong("manajemen risiko yang tepat"),
    #                         " dan melakukan ",
    #                         html.Strong("monitoring berkala"),
    #                         " terhadap performa strategi di kondisi pasar yang berubah."
    #                     ], className="mb-3"),
    #                 ], className="p-4 bg-red-50 rounded-lg border border-red-200")
    #             ]))
            
    #         return html.Div(components)
            
    #     except Exception as e:
    #         return html.Div([
    #             html.H3("âŒ Error dalam analisis global", className="text-xl font-bold text-red-600 mb-2"),
    #             html.P(f"Terjadi kesalahan: {str(e)}", className="text-red-500")
    #         ])
    








    # Callback untuk mengupdate hasil berdasarkan filter
    @app.callback(
        Output('filtered-backtesting-results', 'children'),
        [Input('backtesting-analysis-filter', 'value')],
        [State('backtesting-analysis-data-store', 'children')]
    )
    def update_filtered_backtesting_results(filter_value, stored_data):
        if not filter_value or not stored_data:
            return html.Div("Pilih filter untuk melihat hasil analisis", className="text-gray-500 text-center p-8")
        
        try:
            # Parse stored data
            data = json.loads(stored_data)
            processed_data = data['processed_data']
            ticker_details = data['ticker_details']
            all_tickers = data['all_tickers']
            all_indicators = data['all_indicators']
            
            df = pd.DataFrame(processed_data)
            
            if filter_value == 'global':
                # Return global analysis (sudah ditampilkan di initial-global-results)
                return html.Div([
                    html.Div([
                        html.H4("â„¹ï¸ Hasil Analisis Global", className="text-lg font-semibold text-blue-600 mb-2"),
                        html.P("Analisis global ditampilkan di atas. Pilih ticker atau kombinasi spesifik untuk analisis yang lebih detail.", 
                            className="text-gray-600")
                    ], className="p-4 bg-blue-50 rounded-lg border border-blue-200")
                ])
            
            elif filter_value.startswith('ticker:'):
                # Filter by specific ticker
                selected_ticker = filter_value.split(':', 1)[1]
                return generate_ticker_specific_analysis(df, selected_ticker, ticker_details, all_indicators)
            
            elif '|' in filter_value:
                # Filter by specific ticker-indicator combination
                ticker, indicator = filter_value.split('|', 1)
                return generate_combination_specific_analysis(df, ticker, indicator, ticker_details)
            
            else:
                return html.Div("Filter tidak valid", className="text-red-500 text-center p-4")
                
        except Exception as e:
            return html.Div([
                html.H4("Error", className="text-lg font-bold text-red-600 mb-2"),
                html.P(f"Terjadi kesalahan: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="bg-gray-100 p-2 rounded text-xs mt-2")
            ])

    def generate_ticker_specific_analysis(df, selected_ticker, ticker_details, all_indicators):
        """Generate analisis spesifik untuk ticker tertentu"""
        # Filter data untuk ticker yang dipilih
        ticker_df = df[df['Title'] == selected_ticker]
        
        if ticker_df.empty:
            return html.Div(f"Tidak ada data untuk ticker {selected_ticker}", className="text-red-500 text-center p-4")
        
        # Dapatkan modal awal
        capital = 10000000
        if ticker_details.get(selected_ticker) and len(ticker_details[selected_ticker]) > 0:
            capital = ticker_details[selected_ticker][0].get('initial_capital', 10000000)
        
        # Analisis setiap indikator untuk ticker ini
        indicator_results = []
        available_indicators = ticker_df['Analysis_info'].unique()
        
        for indicator in available_indicators:
            indicator_df = ticker_df[ticker_df['Analysis_info'] == indicator]
            
            if indicator_df.empty:
                continue
            
            # Pastikan kolom Datetime dalam format datetime - FIX 1
            try:
                if 'Datetime' in indicator_df.columns:
                    indicator_df = indicator_df.copy()
                    indicator_df['Datetime'] = pd.to_datetime(indicator_df['Datetime'])
                else:
                    print(f"Warning: No Datetime column for {selected_ticker} - {indicator}")
                    continue
            except Exception as e:
                print(f"Error converting datetime for {selected_ticker} - {indicator}: {e}")
                continue
            
            # Proses analisis seperti sebelumnya
            indicator_df = indicator_df.sort_values('Datetime')
            buy_signals = indicator_df[indicator_df['Signal'] == 'Buy']
            sell_signals = indicator_df[indicator_df['Signal'] == 'Sell']
            
            if len(buy_signals) == 0 or len(sell_signals) == 0:
                continue
            
            # Simulasi trading
            all_signals = pd.concat([
                buy_signals[['Datetime', 'Price', 'Signal', 'Volume']],
                sell_signals[['Datetime', 'Price', 'Signal', 'Volume']]
            ]).sort_values('Datetime')
            
            initial_capital = float(capital)
            current_capital = initial_capital
            position = None
            trades = []
            
            for idx, row in all_signals.iterrows():
                if position is None and row['Signal'] == 'Buy':
                    shares = current_capital // row['Price']
                    if shares > 0:
                        position = {
                            'entry_date': row['Datetime'],
                            'entry_price': row['Price'],
                            'entry_volume': row['Volume'],
                            'shares': shares,
                            'cost': shares * row['Price'],
                            'indicator': indicator
                        }
                        current_capital -= position['cost']
                        
                elif position is not None and row['Signal'] == 'Sell':
                    proceeds = position['shares'] * row['Price']
                    profit = proceeds - position['cost']
                    
                    # FIX 2 - Safe calculation of price and volume changes
                    try:
                        price_change_pct = ((row['Price'] - position['entry_price']) / position['entry_price']) * 100
                    except (TypeError, ZeroDivisionError):
                        price_change_pct = 0
                    
                    try:
                        volume_change_pct = ((row['Volume'] - position['entry_volume']) / position['entry_volume']) * 100 if position['entry_volume'] > 0 else 0
                    except (TypeError, ZeroDivisionError):
                        volume_change_pct = 0
                    
                    trades.append({
                        'Entry Date': position['entry_date'],
                        'Entry Price': position['entry_price'],
                        'Exit Date': row['Datetime'],
                        'Exit Price': row['Price'],
                        'Shares': position['shares'],
                        'Profit/Loss': profit,
                        'Return %': (profit / position['cost']) * 100,
                        'Price Change %': price_change_pct,
                        'Volume Change %': volume_change_pct
                    })
                    current_capital += proceeds
                    position = None
            
            # Hitung metrik
            total_trades = len(trades)
            if total_trades > 0:
                winning_trades = len([t for t in trades if t['Profit/Loss'] > 0])
                total_profit = sum(t['Profit/Loss'] for t in trades)
                profit_percentage = ((current_capital - initial_capital) / initial_capital) * 100
                
                indicator_results.append({
                    'Indicator': indicator,
                    'Return %': profit_percentage,
                    'Total Profit': total_profit,
                    'Total Trades': total_trades,
                    'Win Rate': (winning_trades/total_trades*100) if total_trades > 0 else 0,
                    'Final Capital': current_capital,
                    'Trades': trades
                })
        
        # Sort berdasarkan return
        indicator_results = sorted(indicator_results, key=lambda x: x['Return %'], reverse=True)
        
        if not indicator_results:
            return html.Div(f"Tidak ada hasil valid untuk ticker {selected_ticker}", className="text-red-500 text-center p-4")
        
        # Buat komponen hasil - sama seperti sebelumnya
        components = [
            html.H3(f"ðŸ“Š Analisis Lengkap untuk {selected_ticker}", className="text-xl font-bold mb-4 text-blue-700"),
            
            # Best strategy untuk ticker ini
            html.Div([
                html.H4("ðŸ¥‡ Strategi Terbaik", className="text-lg font-semibold mb-2 text-green-600"),
                html.Div([
                    html.Div([
                        html.Span("Indikator: ", className="font-semibold"),
                        html.Span(indicator_results[0]['Indicator'], className="ml-1 text-blue-600 text-lg")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Return: ", className="font-semibold"),
                        html.Span(f"{indicator_results[0]['Return %']:.2f}%", 
                                className=f"ml-1 text-lg font-bold {'text-green-600' if indicator_results[0]['Return %'] >= 0 else 'text-red-600'}")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Total Profit: ", className="font-semibold"),
                        html.Span(f"Rp {indicator_results[0]['Total Profit']:,.0f}", 
                                className=f"ml-1 {'text-green-600' if indicator_results[0]['Total Profit'] >= 0 else 'text-red-600'}")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Win Rate: ", className="font-semibold"),
                        html.Span(f"{indicator_results[0]['Win Rate']:.1f}%", className="ml-1 text-blue-600")
                    ])
                ], className="p-4 bg-green-50 rounded-lg border border-green-200 mb-4")
            ]),
            
            # Tabel perbandingan semua indikator
            html.Div([
                html.H4("ðŸ“ˆ Perbandingan Semua Indikator", className="text-lg font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'Rank': i+1,
                        'Indicator': r['Indicator'],
                        'Return %': f"{r['Return %']:.2f}%",
                        'Total Profit': f"Rp {r['Total Profit']:,.0f}",
                        'Win Rate': f"{r['Win Rate']:.1f}%",
                        'Total Trades': r['Total Trades'],
                        'Final Capital': f"Rp {r['Final Capital']:,.0f}"
                    } for i, r in enumerate(indicator_results)],
                    columns=[
                        {'name': '#', 'id': 'Rank'},
                        {'name': 'Indicator', 'id': 'Indicator'},
                        {'name': 'Return %', 'id': 'Return %'},
                        {'name': 'Total Profit', 'id': 'Total Profit'},
                        {'name': 'Win Rate', 'id': 'Win Rate'},
                        {'name': 'Total Trades', 'id': 'Total Trades'},
                        {'name': 'Final Capital', 'id': 'Final Capital'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'row_index': 0},
                            'backgroundColor': 'rgba(255, 215, 0, 0.3)',
                            'fontWeight': 'bold'
                        },
                        {
                            'if': {'filter_query': '{Return %} contains "-"'},
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Return %} > "0"'},
                            'color': 'green'
                        }
                    ]
                )
            ], className="mb-6"),
            
            # Chart perbandingan
            html.Div([
                html.H4("ðŸ“Š Visualisasi Performa", className="text-lg font-semibold mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Bar(
                                x=[r['Indicator'] for r in indicator_results],
                                y=[r['Return %'] for r in indicator_results],
                                marker_color=['gold' if i == 0 else 'green' if r['Return %'] > 0 else 'red' 
                                            for i, r in enumerate(indicator_results)],
                                text=[f"{r['Return %']:.1f}%" for r in indicator_results],
                                textposition='outside'
                            )
                        ],
                        layout=go.Layout(
                            title=f"Performa Indikator untuk {selected_ticker}",
                            xaxis_title="Indikator",
                            yaxis_title="Return %",
                            height=400,
                            template="plotly_white"
                        )
                    )
                )
            ])
        ]
        
        return html.Div(components)

    def generate_combination_specific_analysis(df, ticker, indicator, ticker_details):
        """Generate analisis spesifik untuk kombinasi ticker-indicator tertentu"""
        # Filter data untuk kombinasi spesifik
        combo_df = df[(df['Title'] == ticker) & (df['Analysis_info'] == indicator)]
        
        if combo_df.empty:
            return html.Div(f"Tidak ada data untuk {ticker} - {indicator}", className="text-red-500 text-center p-4")
        
        # Dapatkan modal awal
        capital = 10000000
        if ticker_details.get(ticker) and len(ticker_details[ticker]) > 0:
            capital = ticker_details[ticker][0].get('initial_capital', 10000000)
        
        # FIX 3 - Pastikan datetime conversion yang aman
        try:
            combo_df = combo_df.copy()
            if 'Datetime' in combo_df.columns:
                combo_df['Datetime'] = pd.to_datetime(combo_df['Datetime'])
            else:
                return html.Div(f"Tidak ada kolom Datetime untuk {ticker} - {indicator}", className="text-red-500 text-center p-4")
        except Exception as e:
            return html.Div(f"Error converting datetime: {str(e)}", className="text-red-500 text-center p-4")
        
        # Proses data
        combo_df = combo_df.sort_values('Datetime')
        buy_signals = combo_df[combo_df['Signal'] == 'Buy']
        sell_signals = combo_df[combo_df['Signal'] == 'Sell']
        
        if len(buy_signals) == 0 or len(sell_signals) == 0:
            return html.Div(f"Tidak ada sinyal yang cukup untuk {ticker} - {indicator}", className="text-red-500 text-center p-4")
        
        # Simulasi trading detail
        all_signals = pd.concat([
            buy_signals[['Datetime', 'Price', 'Signal', 'Volume']],
            sell_signals[['Datetime', 'Price', 'Signal', 'Volume']]
        ]).sort_values('Datetime')
        
        initial_capital = float(capital)
        current_capital = initial_capital
        position = None
        trades = []
        capital_history = [{'date': all_signals.iloc[0]['Datetime'], 'capital': initial_capital}]
        
        for idx, row in all_signals.iterrows():
            if position is None and row['Signal'] == 'Buy':
                shares = current_capital // row['Price']
                if shares > 0:
                    position = {
                        'entry_date': row['Datetime'],
                        'entry_price': row['Price'],
                        'entry_volume': row['Volume'],
                        'shares': shares,
                        'cost': shares * row['Price']
                    }
                    current_capital -= position['cost']
                    capital_history.append({'date': row['Datetime'], 'capital': current_capital})
                    
            elif position is not None and row['Signal'] == 'Sell':
                proceeds = position['shares'] * row['Price']
                profit = proceeds - position['cost']
                
                # FIX 4 - Safe calculation of holding days
                try:
                    holding_days = (row['Datetime'] - position['entry_date']).days
                except (TypeError, AttributeError):
                    holding_days = 0
                
                trades.append({
                    'Entry Date': position['entry_date'],
                    'Entry Price': position['entry_price'],
                    'Exit Date': row['Datetime'],
                    'Exit Price': row['Price'],
                    'Shares': position['shares'],
                    'Investment': position['cost'],
                    'Proceeds': proceeds,
                    'Profit/Loss': profit,
                    'Return %': (profit / position['cost']) * 100,
                    'Holding Days': holding_days
                })
                current_capital += proceeds
                capital_history.append({'date': row['Datetime'], 'capital': current_capital})
                position = None
        
        # Kalkulasi metrik detail
        total_trades = len(trades)
        if total_trades == 0:
            return html.Div(f"Tidak ada trade yang completed untuk {ticker} - {indicator}", className="text-red-500 text-center p-4")
        
        winning_trades = len([t for t in trades if t['Profit/Loss'] > 0])
        losing_trades = total_trades - winning_trades
        total_profit = sum(t['Profit/Loss'] for t in trades)
        profit_percentage = ((current_capital - initial_capital) / initial_capital) * 100
        
        avg_holding_days = sum(t['Holding Days'] for t in trades) / total_trades
        avg_profit_per_trade = total_profit / total_trades
        win_rate = (winning_trades / total_trades) * 100
        
        max_profit = max(t['Profit/Loss'] for t in trades)
        max_loss = min(t['Profit/Loss'] for t in trades)
        
        # Buat komponen hasil detail - FIXED DATATABLE FILTER SYNTAX
        components = [
            html.H3(f"ðŸ” Analisis Detail: {ticker} - {indicator}", className="text-xl font-bold mb-4 text-blue-700"),
            
            # Metrics Overview
            html.Div([
                html.H4("ðŸ“‹ Ringkasan Performa", className="text-lg font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Div([
                            html.Span("Modal Awal", className="block text-sm text-gray-500"),
                            html.Span(f"Rp {initial_capital:,.0f}", className="block text-lg font-bold text-blue-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/5 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Modal Akhir", className="block text-sm text-gray-500"),
                            html.Span(f"Rp {current_capital:,.0f}", className="block text-lg font-bold text-green-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/5 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Total Return", className="block text-sm text-gray-500"),
                            html.Span(f"{profit_percentage:.2f}%", 
                                    className=f"block text-lg font-bold {'text-green-600' if profit_percentage > 0 else 'text-red-600'}")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/5 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Total Profit", className="block text-sm text-gray-500"),
                            html.Span(f"Rp {total_profit:,.0f}", 
                                    className=f"block text-lg font-bold {'text-green-600' if total_profit > 0 else 'text-red-600'}")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/5 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Win Rate", className="block text-sm text-gray-500"),
                            html.Span(f"{win_rate:.1f}%", className="block text-lg font-bold text-blue-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/5 px-2"),
                ], className="flex -mx-2 mb-6")
            ]),
            
            # Trading Statistics
            html.Div([
                html.H4("ðŸ“Š Statistik Trading", className="text-lg font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Div([
                            html.Span("Total Transaksi", className="block text-sm text-gray-500"),
                            html.Span(f"{total_trades}", className="block text-xl font-bold text-blue-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/6 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Transaksi Profit", className="block text-sm text-gray-500"),
                            html.Span(f"{winning_trades}", className="block text-xl font-bold text-green-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/6 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Transaksi Loss", className="block text-sm text-gray-500"),
                            html.Span(f"{losing_trades}", className="block text-xl font-bold text-red-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/6 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Rata-rata Holding", className="block text-sm text-gray-500"),
                            html.Span(f"{avg_holding_days:.1f} hari", className="block text-xl font-bold text-blue-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/6 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Profit Terbesar", className="block text-sm text-gray-500"),
                            html.Span(f"Rp {max_profit:,.0f}", className="block text-xl font-bold text-green-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/6 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Loss Terbesar", className="block text-sm text-gray-500"),
                            html.Span(f"Rp {max_loss:,.0f}", className="block text-xl font-bold text-red-600")
                        ], className="p-3 border rounded bg-white shadow-sm text-center")
                    ], className="w-1/6 px-2"),
                ], className="flex -mx-2 mb-6")
            ]),
            
            # Capital Growth Chart
            html.Div([
                html.H4("ðŸ“ˆ Pertumbuhan Modal", className="text-lg font-semibold mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Scatter(
                                x=[item['date'] for item in capital_history],
                                y=[item['capital'] for item in capital_history],
                                mode='lines+markers',
                                name='Modal',
                                line=dict(color='blue', width=2),
                                marker=dict(size=6)
                            ),
                            go.Scatter(
                                x=[capital_history[0]['date'], capital_history[-1]['date']],
                                y=[initial_capital, initial_capital],
                                mode='lines',
                                name='Modal Awal',
                                line=dict(color='gray', width=1, dash='dash')
                            )
                        ],
                        layout=go.Layout(
                            title=f"Pertumbuhan Modal - {ticker} ({indicator})",
                            xaxis_title="Tanggal",
                            yaxis_title="Modal (Rp)",
                            height=400,
                            template="plotly_white",
                            hovermode='x unified'
                        )
                    )
                )
            ], className="mb-6"),
            
            # Detailed Trade Table - FIXED FILTER SYNTAX
            html.Div([
                html.H4("ðŸ“ Detail Semua Transaksi", className="text-lg font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'No': i+1,
                        'Entry Date': t['Entry Date'].strftime('%Y-%m-%d') if hasattr(t['Entry Date'], 'strftime') else str(t['Entry Date']),
                        'Entry Price': f"Rp {t['Entry Price']:,.0f}",
                        'Exit Date': t['Exit Date'].strftime('%Y-%m-%d') if hasattr(t['Exit Date'], 'strftime') else str(t['Exit Date']),
                        'Exit Price': f"Rp {t['Exit Price']:,.0f}",
                        'Shares': f"{t['Shares']:,}",
                        'Investment': f"Rp {t['Investment']:,.0f}",
                        'Proceeds': f"Rp {t['Proceeds']:,.0f}",
                        'Profit/Loss': f"Rp {t['Profit/Loss']:,.0f}",
                        'Return %': f"{t['Return %']:.2f}%",
                        'Holding Days': f"{t['Holding Days']} hari",
                        'Profit_Status': 'Profit' if t['Profit/Loss'] >= 0 else 'Loss'  # Add helper column for filtering
                    } for i, t in enumerate(trades)],
                    columns=[
                        {'name': 'No', 'id': 'No'},
                        {'name': 'Entry Date', 'id': 'Entry Date'},
                        {'name': 'Entry Price', 'id': 'Entry Price'},
                        {'name': 'Exit Date', 'id': 'Exit Date'},
                        {'name': 'Exit Price', 'id': 'Exit Price'},
                        {'name': 'Shares', 'id': 'Shares'},
                        {'name': 'Investment', 'id': 'Investment'},
                        {'name': 'Proceeds', 'id': 'Proceeds'},
                        {'name': 'Profit/Loss', 'id': 'Profit/Loss'},
                        {'name': 'Return %', 'id': 'Return %'},
                        {'name': 'Holding Days', 'id': 'Holding Days'}
                        # Don't include Profit_Status in visible columns
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '8px', 'fontSize': '12px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Profit_Status} = Loss'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Profit_Status} = Profit'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        }
                    ],
                    page_size=15,
                    sort_action='native'
                )
            ])
        ]
        
        return html.Div(components)
    





    # @app.callback(
    #     [Output('selected-indicator-trades', 'children'),
    #     Output('capital-growth-chart-container', 'children')],
    #     [Input('indicator-trade-selection', 'value')],
    #     [State('backtesting-results-store', 'data')] # Asumsi Anda menyimpan hasil di dcc.Store
    # )
    # def update_trade_details_and_chart(selected_value, stored_data):
    #     if not selected_value or not stored_data:
    #         return html.Div("Pilih strategi untuk melihat detail."), html.Div()

    #     ticker, indicator = selected_value.split('|')
        
    #     # Ambil data trade yang relevan dari data yang disimpan
    #     # Anda perlu menyesuaikan struktur `stored_data` sesuai dengan bagaimana Anda menyimpannya
    #     # Untuk contoh ini, kita asumsikan 'trade_details' disimpan
    #     trade_details_all = stored_data.get('trade_details', {})
    #     trades = trade_details_all.get(ticker, {}).get(indicator, [])

    #     if not trades:
    #         return html.Div(f"Tidak ada data trade untuk {ticker} - {indicator}."), html.Div()

    #     # Buat tabel detail
    #     trade_table = dash_table.DataTable(
    #         data=[{
    #             'Date': t['date'].strftime('%Y-%m-%d') if hasattr(t['date'], 'strftime') else str(t['date']),
    #             'Type': t['type'],
    #             'Price': f"{t['price']:.2f}",
    #             'Shares': f"{t['shares']:.2f}",
    #             'Value': f"{t['value']:.2f}",
    #             'Capital': f"{t['remaining_cash']:.2f}"
    #         } for t in trades],
    #         columns=[{'name': c, 'id': c} for c in ['Date', 'Type', 'Price', 'Shares', 'Value', 'Capital']],
    #         page_size=10,
    #         style_table={'overflowX': 'auto'},
    #         style_data_conditional=[
    #             {'if': {'filter_query': '{Type} = "Buy"'}, 'backgroundColor': 'rgba(0, 255, 0, 0.1)'},
    #             {'if': {'filter_query': '{Type} = "Sell"'}, 'backgroundColor': 'rgba(255, 0, 0, 0.1)'}
    #         ]
    #     )
        
    #     # Buat grafik pertumbuhan modal
    #     # Anda perlu menemukan detail strategi yang lengkap (termasuk modal awal, dll.)
    #     ticker_details_list = stored_data.get('ticker_details_list', [])
    #     result_details = next((item for item in ticker_details_list if item['ticker'] == ticker and item['indicator'] == indicator), None)
        
    #     capital_chart = dcc.Graph(figure=create_capital_growth_chart(result_details, ticker, indicator))

    #     return trade_table, capital_chart












    @app.callback(
        Output("selected-indicator-trades", "children"),
        [Input("indicator-trade-selection", "value"),
         Input("stored-results", "data")]
    )
    def update_selected_trades(selection, all_results):
        if not selection:
            return html.Div("Please select a ticker-indicator combination", className="text-gray-500")
        
        try:
            ticker, indicator = selection.split('|')
            
            # Find the appropriate trades
            if ticker in all_results['trade_details'] and indicator in all_results['trade_details'][ticker]:
                trades = all_results['trade_details'][ticker][indicator]
                
                # Get the result details
                result = next((item for item in all_results['ticker_details'].get(ticker, []) 
                            if item['indicator'] == indicator), None)
                
                if not result or not trades:
                    return html.Div(f"No trade data found for {ticker} - {indicator}", className="text-red-500")
                
                # Create the trade summary section
                trade_summary = html.Div([
                    html.H4(f"Trade Summary for {ticker} - {indicator}", className="text-lg font-semibold mb-3"),
                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Initial Capital", className="block text-sm text-gray-500"),
                                html.Span(f"{result['initial_capital']:,.2f}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Final Capital", className="block text-sm text-gray-500"),
                                html.Span(f"{result['final_capital']:,.2f}", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Total Profit", className="block text-sm text-gray-500"),
                                html.Span(f"{result['total_profit']:,.2f}", 
                                        className=f"block text-xl font-bold {'text-green-600' if result['total_profit'] > 0 else 'text-red-600'}")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Win Rate", className="block text-sm text-gray-500"),
                                html.Span(f"{result['win_rate']:.2f}%", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                    ], className="flex -mx-2 mb-4")
                ])
                
                # Create capital growth chart
                capital_chart = dcc.Graph(
                    figure=create_capital_growth_chart(result, ticker, indicator)
                )
                
                # Create trade table
                trade_table = dash_table.DataTable(
                    data=[{
                        'Date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
                        'Type': t['type'],
                        'Price': f"{t['price']:.2f}",
                        'Shares': t['shares'],
                        'Value': f"{t['value']:,.2f}",
                        'Cash': f"{t['remaining_cash']:,.2f}",
                        'Portfolio Value': f"{t['remaining_cash'] + (t['shares'] * t['price'] if t['type'] == 'Buy' else 0):,.2f}",
                        'Profit/Loss': f"{t['value'] - (t.get('cost_basis', 0)):,.2f}" if t['type'] == 'Sell' else "-"
                    } for t in trades],
                    columns=[
                        {'name': 'Date', 'id': 'Date'},
                        {'name': 'Type', 'id': 'Type'},
                        {'name': 'Price', 'id': 'Price'},
                        {'name': 'Shares', 'id': 'Shares'},
                        {'name': 'Value', 'id': 'Value'},
                        {'name': 'Cash', 'id': 'Cash'},
                        {'name': 'Portfolio Value', 'id': 'Portfolio Value'},
                        {'name': 'Profit/Loss', 'id': 'Profit/Loss'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Type} = "Buy"'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{Type} = "Sell"'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Profit/Loss} contains "-" && {Profit/Loss} != "-"'},
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Profit/Loss} > "0" && {Profit/Loss} != "-"'},
                            'color': 'green'
                        }
                    ],
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    sort_action='native',
                    page_size=15
                )
                
                # Analyze trading patterns
                buy_hold_periods = []
                price_movements = []
                current_buy = None
                
                for i, trade in enumerate(trades):
                    if trade['type'] == 'Buy':
                        current_buy = trade
                    elif trade['type'] == 'Sell' and current_buy:
                        # Calculate holding period
                        try:
                            hold_days = (trade['date'] - current_buy['date']).days if hasattr(trade['date'], 'days') else 0
                            buy_hold_periods.append(hold_days)
                            
                            # Calculate price movement
                            price_change_pct = (trade['price'] - current_buy['price']) / current_buy['price'] * 100
                            price_movements.append(price_change_pct)
                        except:
                            pass
                        current_buy = None
                
                # Create additional insights
                avg_hold_period = sum(buy_hold_periods) / len(buy_hold_periods) if buy_hold_periods else 0
                avg_price_movement = sum(price_movements) / len(price_movements) if price_movements else 0
                
                insights = html.Div([
                    html.H4("Trading Insights", className="text-lg font-semibold mt-6 mb-3"),
                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Avg Holding Period", className="block text-sm text-gray-500"),
                                html.Span(f"{avg_hold_period:.1f} days", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/3 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Avg Price Movement", className="block text-sm text-gray-500"),
                                html.Span(f"{avg_price_movement:.2f}%", 
                                        className=f"block text-xl font-bold {'text-green-600' if avg_price_movement > 0 else 'text-red-600'}")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/3 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Total Trades", className="block text-sm text-gray-500"),
                                html.Span(f"{len(trades)}", className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/3 px-2"),
                    ], className="flex -mx-2 mb-4")
                ])
                
                return html.Div([
                    trade_summary,
                    insights,
                    capital_chart,
                    html.H4("Detailed Trade History", className="text-lg font-semibold mt-6 mb-3"),
                    trade_table
                ])
                
            return html.Div(f"No data found for {ticker} - {indicator}", className="text-red-500")
            
        except Exception as e:
            return html.Div([
                html.P(f"Error displaying trades: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])


    # pattern analysis
    @app.callback(
        Output("trade-pattern-content", "children"),
        [Input("pattern-analysis-selection", "value"),
        Input("stored-results", "data")]
    )
    def update_trade_pattern_analysis(selection, all_results):
        if not selection:
            return html.Div("Please select a ticker-indicator combination", className="text-gray-500")
        
        try:
            ticker, indicator = selection.split('|')

            if ticker in all_results['trade_details'] and indicator in all_results['trade_details'][ticker]:
                trades = all_results['trade_details'][ticker][indicator]

                if not trades:
                    return html.Div(f"No trade data found for {ticker} - {indicator}", className="text-red-500")

                buy_trades = [t for t in trades if t['type'] == 'Buy']
                sell_trades = [t for t in trades if t['type'] == 'Sell']

                paired_trades = []
                current_buy = None

                for trade in trades:
                    if trade['type'] == 'Buy':
                        current_buy = trade
                    elif trade['type'] == 'Sell' and current_buy:
                        holding_period = (trade['date'] - current_buy['date']).days if hasattr(trade['date'], 'days') else 0
                        price_change = (trade['price'] - current_buy['price']) / current_buy['price'] * 100
                        profit = trade['value'] - current_buy['value']

                        paired_trades.append({
                            'buy': current_buy,
                            'sell': trade,
                            'holding_period': holding_period,
                            'price_change': price_change,
                            'profit': profit
                        })
                        current_buy = None

                profitable_trades = [t for t in paired_trades if t['profit'] > 0]
                losing_trades = [t for t in paired_trades if t['profit'] <= 0]

                avg_profit = sum(t['profit'] for t in profitable_trades) / len(profitable_trades) if profitable_trades else 0
                avg_loss = sum(t['profit'] for t in losing_trades) / len(losing_trades) if losing_trades else 0
                avg_hold_profitable = sum(t['holding_period'] for t in profitable_trades) / len(profitable_trades) if profitable_trades else 0
                avg_hold_losing = sum(t['holding_period'] for t in losing_trades) / len(losing_trades) if losing_trades else 0

                profit_loss_ratio = abs(avg_profit / avg_loss) if avg_loss != 0 else None

                pattern_summary = html.Div([
                    html.H4(f"Trade Pattern Analysis for {ticker} - {indicator}", className="text-lg font-semibold mb-3"),
                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Profitable Trades", className="block text-sm text-gray-500"),
                                html.Span(f"{len(profitable_trades)}", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Losing Trades", className="block text-sm text-gray-500"),
                                html.Span(f"{len(losing_trades)}", className="block text-xl font-bold text-red-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Avg Profit", className="block text-sm text-gray-500"),
                                html.Span(f"{avg_profit:,.2f}", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Avg Loss", className="block text-sm text-gray-500"),
                                html.Span(f"{avg_loss:,.2f}", className="block text-xl font-bold text-red-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/4 px-2"),
                    ], className="flex -mx-2 mb-4"),

                    html.Div([
                        html.Div([
                            html.Div([
                                html.Span("Avg Hold (Profitable)", className="block text-sm text-gray-500"),
                                html.Span(f"{avg_hold_profitable:.1f} days", className="block text-xl font-bold text-green-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/3 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Avg Hold (Losing)", className="block text-sm text-gray-500"),
                                html.Span(f"{avg_hold_losing:.1f} days", className="block text-xl font-bold text-red-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/3 px-2"),
                        html.Div([
                            html.Div([
                                html.Span("Profit/Loss Ratio", className="block text-sm text-gray-500"),
                                html.Span(f"{profit_loss_ratio:.2f}" if profit_loss_ratio is not None else "N/A",
                                        className="block text-xl font-bold text-blue-600")
                            ], className="p-3 border rounded bg-white shadow-sm")
                        ], className="w-1/3 px-2"),
                    ], className="flex -mx-2 mb-4")
                ])

                hold_periods = [t['holding_period'] for t in paired_trades]
                hold_period_fig = go.Figure(
                    data=[go.Histogram(
                        x=hold_periods,
                        marker_color='blue',
                        opacity=0.7
                    )],
                    layout=go.Layout(
                        title="Holding Period Distribution",
                        xaxis_title="Days Held",
                        yaxis_title="Number of Trades",
                        height=400
                    )
                )

                profit_scatter_fig = go.Figure(
                    data=[go.Scatter(
                        x=[t['holding_period'] for t in paired_trades],
                        y=[t['profit'] for t in paired_trades],
                        mode='markers',
                        marker=dict(
                            color=['green' if t['profit'] > 0 else 'red' for t in paired_trades],
                            size=10
                        ),
                        text=[f"Buy: {t['buy']['date']}<br>Sell: {t['sell']['date']}<br>Profit: {t['profit']:.2f}" 
                            for t in paired_trades],
                        hoverinfo='text'
                    )],
                    layout=go.Layout(
                        title="Profit vs Holding Period",
                        xaxis_title="Days Held",
                        yaxis_title="Profit",
                        height=400
                    )
                )

                if paired_trades:
                    best_trade = max(paired_trades, key=lambda x: x['profit'])
                    worst_trade = min(paired_trades, key=lambda x: x['profit'])

                    insights = html.Div([
                        html.H4("Trading Pattern Insights", className="text-lg font-semibold mt-6 mb-3"),
                        html.P([
                            "Based on the analysis, the optimal holding period appears to be ",
                            html.Strong(f"{avg_hold_profitable:.1f} days"),
                            ". The strategy shows a profit/loss ratio of ",
                            html.Strong(f"{profit_loss_ratio:.2f}" if profit_loss_ratio is not None else "N/A"),
                            "."
                        ], className="mb-2"),
                        html.P([
                            "The best trade had a profit of ",
                            html.Strong(f"{best_trade['profit']:,.2f}"),
                            " with a holding period of ",
                            html.Strong(f"{best_trade['holding_period']} days"),
                            ", while the worst trade had a loss of ",
                            html.Strong(f"{worst_trade['profit']:,.2f}"),
                            " with a holding period of ",
                            html.Strong(f"{worst_trade['holding_period']} days"),
                            "."
                        ], className="mb-2"),
                        html.P("This suggests that the optimal strategy might be to...", className="italic")
                    ], className="p-4 bg-blue-50 rounded border border-blue-200")
                else:
                    insights = html.Div("Not enough paired trades to generate insights", className="text-gray-500")

                return html.Div([
                    pattern_summary,
                    dcc.Graph(figure=hold_period_fig),
                    dcc.Graph(figure=profit_scatter_fig),
                    insights
                ])

            return html.Div(f"No data found for {ticker} - {indicator}", className="text-red-500")

        except Exception as e:
            return html.Div([
                html.P(f"Error analyzing trade patterns: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])










    # BACKTESTING PROFIT SECTION
    def generate_backtesting_profit_results(all_results):
        """Generate backtesting profit results with linear scenarios"""
        if 'trade_details' not in all_results or not all_results['trade_details']:
            return html.Div("No backtesting profit results available", className="text-center text-gray-500 p-4")
        
        components = []
        
        all_scenarios_list = [] # Renamed for clarity
        scenario_id_counter = 1 
        best_scenario_data = None # Renamed for clarity
        max_final_capital = float('-inf')
        
        # Keep track of scenarios by ticker for filtering and potential ticker-specific aggregations
        ticker_scenarios_map = {} # Renamed for clarity
        
        for ticker_name, indicators_map in all_results['trade_details'].items():
            ticker_scenarios_map[ticker_name] = []
            
            for indicator_name, trades_list in indicators_map.items():
                if not trades_list:
                    continue
                
                trades_df = pd.DataFrame(trades_list)
                if trades_df.empty:
                    continue
                    
                if 'date' in trades_df.columns:
                    trades_df['Datetime'] = pd.to_datetime(trades_df['date'])
                    trades_df = trades_df.sort_values(by='Datetime').reset_index(drop=True)
                else:
                    # Log or handle missing 'date' column appropriately
                    print(f"Warning: 'date' column missing for {ticker_name} - {indicator_name}. Skipping.")
                    continue
                
                buy_signals_df = trades_df[trades_df['type'] == 'Buy'].reset_index(drop=True)
                sell_signals_df = trades_df[trades_df['type'] == 'Sell'].reset_index(drop=True)
                
                if buy_signals_df.empty or sell_signals_df.empty:
                    continue
                
                # Derive initial capital for this ticker/indicator combination
                # This assumes 'value' and 'remaining_cash' are present in the first buy signal
                # and represent the total capital available at the start of trading for this specific sub-backtest.
                # If this interpretation is incorrect, this logic needs to be adjusted.
                if not buy_signals_df.empty and 'value' in buy_signals_df.columns and 'remaining_cash' in buy_signals_df.columns:
                    initial_capital_for_pair = buy_signals_df.iloc[0]['value'] + buy_signals_df.iloc[0]['remaining_cash']
                else:
                    # Fallback or error if capital cannot be determined
                    print(f"Warning: Could not determine initial capital for {ticker_name} - {indicator_name}. Skipping.")
                    continue

                if initial_capital_for_pair <= 0:
                    print(f"Warning: Initial capital is zero or negative for {ticker_name} - {indicator_name}. Skipping.")
                    continue
                
                for buy_start_idx in range(len(buy_signals_df)):
                    for sell_start_idx in range(len(sell_signals_df)):
                        if sell_signals_df.iloc[sell_start_idx]['Datetime'] <= buy_signals_df.iloc[buy_start_idx]['Datetime']:
                            continue

                        current_scenario_transactions = []
                        current_run_capital = float(initial_capital_for_pair) 
                        initial_scenario_capital_value = current_run_capital # Store for this specific scenario's calculation

                        current_buy_idx = buy_start_idx
                        current_sell_idx = sell_start_idx
                        transaction_dates_set = set()
                        
                        while current_buy_idx < len(buy_signals_df) and current_sell_idx < len(sell_signals_df):
                            buy_signal_data = buy_signals_df.iloc[current_buy_idx]
                            sell_signal_data = sell_signals_df.iloc[current_sell_idx]
                            
                            if sell_signal_data['Datetime'] <= buy_signal_data['Datetime']:
                                found_valid_sell = False
                                for next_sell_idx in range(current_sell_idx + 1, len(sell_signals_df)):
                                    if sell_signals_df.iloc[next_sell_idx]['Datetime'] > buy_signal_data['Datetime']:
                                        current_sell_idx = next_sell_idx
                                        sell_signal_data = sell_signals_df.iloc[current_sell_idx]
                                        found_valid_sell = True
                                        break
                                if not found_valid_sell:
                                    break
                            
                            buy_datetime = buy_signal_data['Datetime']
                            buy_price_val = buy_signal_data['price'] # Ensure 'price' key exists
                            sell_datetime = sell_signal_data['Datetime']
                            sell_price_val = sell_signal_data['price'] # Ensure 'price' key exists
                            
                            if buy_datetime in transaction_dates_set or sell_datetime in transaction_dates_set:
                                current_buy_idx += 1
                                continue
                            
                            num_shares = int(current_run_capital // buy_price_val) if buy_price_val > 0 else 0
                            if num_shares == 0:
                                break
                                
                            investment_amount = num_shares * buy_price_val
                            proceeds_amount = num_shares * sell_price_val
                            profit_amount = proceeds_amount - investment_amount
                            percentage_profit_val = ((sell_price_val - buy_price_val) / buy_price_val) * 100 if buy_price_val > 0 else 0
                            current_run_capital = current_run_capital - investment_amount + proceeds_amount
                            
                            buy_date_str = buy_datetime.strftime('%Y-%m-%d %H:%M:%S') if hasattr(buy_datetime, 'strftime') else str(buy_datetime)
                            sell_date_str = sell_datetime.strftime('%Y-%m-%d %H:%M:%S') if hasattr(sell_datetime, 'strftime') else str(sell_datetime)
                            
                            transaction_details = {
                                'Buy Date': buy_date_str, 'Buy Price': float(buy_price_val),
                                'Sell Date': sell_date_str, 'Sell Price': float(sell_price_val),
                                'Shares': int(num_shares), 
                                'Investment': float(investment_amount),
                                'Proceeds': float(proceeds_amount),
                                'Profit': float(profit_amount),
                                'Percentage Profit': float(percentage_profit_val),
                                'Capital After Trade': float(current_run_capital)
                            }
                            current_scenario_transactions.append(transaction_details)
                            transaction_dates_set.add(buy_datetime)
                            transaction_dates_set.add(sell_datetime)
                            
                            found_valid_buy = False
                            for next_buy_idx in range(current_buy_idx + 1, len(buy_signals_df)): 
                                if buy_signals_df.iloc[next_buy_idx]['Datetime'] > sell_datetime:
                                    current_buy_idx = next_buy_idx
                                    found_valid_buy = True
                                    break
                            if not found_valid_buy:
                                break
                        
                        if not current_scenario_transactions:
                            continue
                            
                        final_scenario_capital = current_scenario_transactions[-1]['Capital After Trade']
                        total_scenario_profit = final_scenario_capital - initial_scenario_capital_value
                        total_scenario_percentage_profit = (total_scenario_profit / initial_scenario_capital_value) * 100 if initial_scenario_capital_value > 0 else 0
                        num_total_trades = len(current_scenario_transactions)
                        
                        summary_row = {
                            'Buy Date': "SUMMARY", 'Buy Price': "", 'Sell Date': "", 'Sell Price': "",
                            'Shares': "", 'Investment': "", 'Proceeds': "", 'Profit': float(total_scenario_profit),
                            'Percentage Profit': float(total_scenario_percentage_profit), 'Capital After Trade': float(final_scenario_capital)
                        }
                        current_scenario_transactions.append(summary_row)
                        
                        # Use a prefix for global scenario IDs to avoid potential clashes if you add other types later
                        internal_scenario_id = f"g_s-{scenario_id_counter}" 
                        scenario_object = {
                            'Scenario ID': internal_scenario_id, # Internal unique ID
                            'Ticker': ticker_name, 
                            'Indicator': indicator_name, 
                            'Transactions': current_scenario_transactions,
                            'Initial Capital': float(initial_scenario_capital_value), 
                            'Final Capital': float(final_scenario_capital),
                            'Total Profit': float(total_scenario_profit), 
                            'Total Percentage Profit': float(total_scenario_percentage_profit),
                            'Number of Trades': num_total_trades
                        }
                        
                        all_scenarios_list.append(scenario_object)
                        ticker_scenarios_map[ticker_name].append(scenario_object)
                        scenario_id_counter += 1
                        
                        if final_scenario_capital > max_final_capital:
                            max_final_capital = final_scenario_capital
                            best_scenario_data = scenario_object

        # Sort all scenarios globally
        all_scenarios_list.sort(key=lambda x: x['Final Capital'], reverse=True)
        
        # Sort scenarios within each ticker group (already done if ticker_scenarios_map is primary source for dropdown)
        # This loop is redundant if ticker_scenarios_map was built sorted or sorted later by the dropdown callback
        # for ticker_key_iter in ticker_scenarios_map:
        #     ticker_scenarios_map[ticker_key_iter].sort(key=lambda x: x['Final Capital'], reverse=True)

        # Prepare data for display
        top_scenarios_global_for_summary_table = all_scenarios_list[:10]
        top_scenarios_global_for_collapsible_and_chart = all_scenarios_list[:5] 

        # --- Best Scenario Summary ---
        if best_scenario_data:
            best_scenario_summary_div = html.Div([
                html.H2(f"Best Linear Scenario: {best_scenario_data['Ticker']} with {best_scenario_data['Indicator']}", className="text-2xl font-bold mb-4 text-green-600"),
                html.Div([
                    html.Div([html.Span("Ticker: ", className="font-semibold"), html.Span(best_scenario_data['Ticker'], className="ml-1 text-blue-600")], className="mb-2"),
                    html.Div([html.Span("Technical Indicator: ", className="font-semibold"), html.Span(best_scenario_data['Indicator'], className="ml-1 text-blue-600")], className="mb-2"),
                    html.Div([html.Span("Initial Capital: ", className="font-semibold"), html.Span(f"{best_scenario_data['Initial Capital']:.2f}", className="ml-1")], className="mb-2"),
                    html.Div([html.Span("Final Capital: ", className="font-semibold"), html.Span(f"{best_scenario_data['Final Capital']:.2f}", className="ml-1 text-green-600")], className="mb-2"),
                    html.Div([html.Span("Total Profit: ", className="font-semibold"), html.Span(f"{best_scenario_data['Total Profit']:.2f}", className="ml-1 text-green-600")], className="mb-2"),
                    html.Div([html.Span("Total Percentage Profit: ", className="font-semibold"), html.Span(f"{best_scenario_data['Total Percentage Profit']:.2f}%", className="ml-1 text-blue-600")], className="mb-2"),
                    html.Div([html.Span("Number of Trades: ", className="font-semibold"), html.Span(str(best_scenario_data['Number of Trades']), className="ml-1")], className="mb-2")
                ], className="p-4 bg-white rounded shadow-sm")
            ], className="mb-6")
            components.append(best_scenario_summary_div)

        # --- Top Global Scenarios Table and Details ---
        if top_scenarios_global_for_summary_table:
            # Data for the summary table, using '#' for display
            global_summary_table_data = []
            for i, s_data in enumerate(top_scenarios_global_for_summary_table, 1):
                global_summary_table_data.append({
                    '#': i, # User-friendly display number
                    'Ticker': s_data['Ticker'], 
                    'Indicator': s_data['Indicator'],
                    'Initial Capital': f"{s_data['Initial Capital']:.2f}", 
                    'Final Capital': f"{s_data['Final Capital']:.2f}",
                    'Total Profit': f"{s_data['Total Profit']:.2f}", 
                    'Total % Profit': f"{s_data['Total Percentage Profit']:.2f}%",
                    'Trades': s_data['Number of Trades']
                })
            
            # Columns for the summary table
            global_summary_table_cols = [
                {'name': '#', 'id': '#'}, {'name': 'Ticker', 'id': 'Ticker'},
                {'name': 'Indicator', 'id': 'Indicator'}, {'name': 'Initial Capital', 'id': 'Initial Capital'},
                {'name': 'Final Capital', 'id': 'Final Capital'}, {'name': 'Total Profit', 'id': 'Total Profit'},
                {'name': 'Total % Profit', 'id': 'Total % Profit'}, {'name': 'Trades', 'id': 'Trades'}
            ]

            # Collapsible details for the top global scenarios
            global_collapsible_details_list = []
            for i, scenario_data_item in enumerate(top_scenarios_global_for_collapsible_and_chart, 1):
                internal_id_for_pattern = scenario_data_item['Scenario ID'] # Used for MATCH
                
                if 'Transactions' in scenario_data_item:
                    transaction_list_for_table = scenario_data_item['Transactions']
                    global_collapsible_details_list.append(html.Div([
                        html.Div( # Clickable header for collapse
                            children=[
                                html.Span(f"Global Top Scenario #{i} - {scenario_data_item['Ticker']} with {scenario_data_item['Indicator']} (Profit: {scenario_data_item['Total Percentage Profit']:.2f}%)", 
                                        className="font-semibold"),
                                html.I(className="fas fa-chevron-down ml-2", id={'type': 'global-icon', 'index': internal_id_for_pattern})
                            ],
                            id={'type': 'global-btn-scenario', 'index': internal_id_for_pattern},
                            className="flex w-full justify-between items-center p-3 bg-blue-50 hover:bg-blue-100 text-left border rounded mb-1 cursor-pointer",
                        ),
                        html.Div( # Collapsible content
                            children=[
                                dcc.Graph(
                                    figure=create_scenario_chart(scenario_data_item, scenario_data_item['Ticker']),
                                    config={'displayModeBar': True}, className="mb-4"
                                ),
                                dash_table.DataTable(
                                    data=[t for t in transaction_list_for_table], # Assumes summary row is handled by styling
                                    columns=[
                                        {'name': 'Buy Date', 'id': 'Buy Date'},
                                        {'name': 'Buy Price', 'id': 'Buy Price', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Sell Date', 'id': 'Sell Date'},
                                        {'name': 'Sell Price', 'id': 'Sell Price', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Shares', 'id': 'Shares'},
                                        {'name': 'Investment', 'id': 'Investment', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Proceeds', 'id': 'Proceeds', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Profit', 'id': 'Profit', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Percentage Profit', 'id': 'Percentage Profit', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Capital After Trade', 'id': 'Capital After Trade', 'type': 'numeric', 'format': {'specifier': '.2f'}}
                                    ],
                                    page_size=10, style_table={'overflowX': 'auto'},
                                    style_cell={'textAlign': 'left', 'padding': '10px'},
                                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                                    style_data_conditional=[
                                        {'if': {'filter_query': '{Buy Date} contains "SUMMARY"'}, 'backgroundColor': 'rgba(0, 255, 0, 0.1)', 'fontWeight': 'bold'},
                                        {'if': {'filter_query': '{Profit} > 0 && {Buy Date} != "SUMMARY"'}, 'color': 'green'},
                                        {'if': {'filter_query': '{Profit} < 0 && {Buy Date} != "SUMMARY"'}, 'color': 'red'}
                                    ]
                                )
                            ],
                            id={'type': 'global-collapse', 'index': internal_id_for_pattern},
                            className="overflow-hidden bg-white p-4 border rounded-b",
                            style={'display': 'none'} # Initially hidden
                        )
                    ], className="mb-3"))
            
            # Profit/Loss Bar Chart for Top Global Scenarios
            global_profit_loss_barchart_figure = create_profit_loss_barchart(
                top_scenarios_global_for_collapsible_and_chart, 
                title_text="Profitability by Ticker & Indicator (Top Global Scenarios)",
                x_axis_label="Ticker - Indicator",
                group_by_ticker=True
            )

            # Assemble the global scenarios section
            global_scenarios_section_div = html.Div([
                html.H2("Top Performing Scenarios (All Tickers)", className="text-xl font-bold mb-3"),
                dash_table.DataTable(
                    id="global-top-scenarios-table", # Static ID
                    data=global_summary_table_data,
                    columns=global_summary_table_cols,
                    page_size=10, style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[{'if': {'row_index': 0}, 'backgroundColor': 'rgba(0, 255, 0, 0.1)'}]
                ),
                html.Div([ # Container for the bar chart
                    html.H4("Global Scenario Profitability Breakdown", className="text-lg font-semibold mt-6 mb-3"),
                    dcc.Graph(figure=global_profit_loss_barchart_figure)
                ], className="mt-4 mb-6"),
                html.Div([ # Container for collapsible details
                    html.H4("Detailed Transaction History of Top Global Scenarios", className="text-lg font-semibold mt-4 mb-3"),
                    html.P("Click on a scenario to view its detailed transactions and chart.", className="text-sm text-gray-600 mb-3"),
                    html.Div(global_collapsible_details_list)
                ], className="mt-4"),
                
                # --- Ticker Filter Dropdown --- MOVED HERE
                html.Div([
                    html.H3("Filter Results by Ticker", className="text-xl font-bold mt-6 mb-3"),
                    dcc.Dropdown(
                        id='ticker-profit-filter',
                        options=[{'label': t_name, 'value': t_name} for t_name in ticker_scenarios_map.keys()] + 
                               [{'label': 'All Tickers', 'value': 'all'}],
                        value='all', # Default to 'all'
                        className="w-full mb-4"
                    ),
                ], className="mb-6")
            ], className="mb-6")
            components.append(global_scenarios_section_div)

        # --- Placeholder for Ticker-Specific Results (populated by callback) ---
        ticker_specific_results_placeholder_div = html.Div([
            html.H2("Top Scenarios by Ticker", className="text-xl font-bold mb-3"),
            html.Div(id="ticker-specific-scenarios-table") # Content updated by callback
        ], className="mb-6")
        components.append(ticker_specific_results_placeholder_div)

        # --- Overall Summary and Stored Data ---
        if all_scenarios_list:
            components.insert(0, html.Div([ # Insert overall summary at the very beginning
                html.H1("Backtesting Profit Results", className="text-2xl font-bold mb-6"),
                html.Div(f"Total scenarios evaluated: {len(all_scenarios_list)}", className="mb-4 text-gray-600")
            ]))
        
        if not components: # If still no components (e.g., only filter was added but no best/top scenarios)
            if not all_scenarios_list: # No scenarios at all
                return html.Div("No valid trading scenarios found for the given parameters.", className="text-center text-red-500 p-4")

        # Serialize all scenarios for storage, using the internal scenario ID as the key
        all_scenarios_for_storage = {}
        for scenario_data_to_store in all_scenarios_list:
            internal_id_for_storage = scenario_data_to_store['Scenario ID']
            all_scenarios_for_storage[internal_id_for_storage] = {
                # Store all necessary fields for the callback to reconstruct views
                'Ticker': scenario_data_to_store['Ticker'], 
                'Indicator': scenario_data_to_store['Indicator'],
                'Initial Capital': float(scenario_data_to_store['Initial Capital']), 
                'Final Capital': float(scenario_data_to_store['Final Capital']),
                'Total Profit': float(scenario_data_to_store['Total Profit']), 
                'Total Percentage Profit': float(scenario_data_to_store['Total Percentage Profit']),
                'Number of Trades': scenario_data_to_store['Number of Trades'], 
                'Transactions': scenario_data_to_store['Transactions'] # Assumes dates are already strings
            }
                
        all_scenarios_hidden_store_div = html.Div(
            id='all-profit-scenarios-store', # Static ID for the store
            style={'display': 'none'},
            children=json.dumps(all_scenarios_for_storage)
        )
        components.append(all_scenarios_hidden_store_div)

        return html.Div(components, className="p-4 bg-white rounded shadow-sm")



    # UPDATE TICKER SPECIFIC SCENARIO
    @app.callback(
        Output("ticker-specific-scenarios-table", "children"),
        [Input("ticker-profit-filter", "value")],
        [State("all-profit-scenarios-store", "children")]
    )
    def update_ticker_specific_scenarios(selected_ticker_value, all_scenarios_json_data):
        if not selected_ticker_value or selected_ticker_value == 'all' or not all_scenarios_json_data:
            # If "All Tickers" is selected or no ticker, show a prompt or keep the section empty/hidden
            return html.Div("Select a specific ticker to see its top scenarios and breakdown.", className="text-gray-500 p-4 text-center")
        
        try:
            all_scenarios_from_store = json.loads(all_scenarios_json_data)
            
            # Filter scenarios for the selected ticker
            # The keys in all_scenarios_from_store are the internal Scenario IDs (e.g., "g_s-1")
            filtered_ticker_scenarios = [
                {**scenario_data, 'Scenario ID': internal_id} # Add internal_id back for pattern matching
                for internal_id, scenario_data in all_scenarios_from_store.items() 
                if scenario_data.get('Ticker') == selected_ticker_value # Use .get() for safety
            ]
            
            if not filtered_ticker_scenarios:
                return html.Div(f"No scenarios found for ticker: {selected_ticker_value}", className="text-gray-500 p-4 text-center")
                
            # Sort by profitability (Final Capital)
            filtered_ticker_scenarios.sort(key=lambda x: x.get('Final Capital', float('-inf')), reverse=True)
            
            # Prepare subsets for different display elements
            top_scenarios_for_summary_table = filtered_ticker_scenarios[:20]
            # Use a consistent subset for collapsible details and charts (e.g., top 10)
            top_scenarios_for_details_and_charts = filtered_ticker_scenarios[:10] 
            top_scenarios_for_combined_plot = filtered_ticker_scenarios[:5] # For the combined entry/exit plot
            
            # --- Data for Summary Table (Top 20) ---
            ticker_summary_table_data = []
            for i, s_data in enumerate(top_scenarios_for_summary_table, 1): # Start numbering from 1
                ticker_summary_table_data.append({
                    '#': i, # User-friendly display number
                    'Indicator': s_data.get('Indicator', 'N/A'),
                    'Initial Capital': f"{s_data.get('Initial Capital', 0):.2f}", 
                    'Final Capital': f"{s_data.get('Final Capital', 0):.2f}",
                    'Total Profit': f"{s_data.get('Total Profit', 0):.2f}", 
                    'Total % Profit': f"{s_data.get('Total Percentage Profit', 0):.2f}%",
                    'Trades': s_data.get('Number of Trades', 0)
                })
            
            ticker_summary_table_cols = [
                {'name': '#', 'id': '#'}, {'name': 'Indicator', 'id': 'Indicator'},
                {'name': 'Initial Capital', 'id': 'Initial Capital'}, {'name': 'Final Capital', 'id': 'Final Capital'},
                {'name': 'Total Profit', 'id': 'Total Profit'}, {'name': 'Total % Profit', 'id': 'Total % Profit'},
                {'name': 'Trades', 'id': 'Trades'}
            ]
                
            # --- Combined Entry/Exit Points Chart (Top 5) ---
            fig_combined_entry_exit = go.Figure()
            # (Your existing logic for fig_combined_entry_exit using top_scenarios_for_combined_plot)
            # Simplified example:
            if top_scenarios_for_combined_plot:
                # Assume first scenario provides a base price line if needed
                base_scenario_for_price = top_scenarios_for_combined_plot[0]
                if base_scenario_for_price.get('Transactions'):
                    all_plot_dates, all_plot_prices = [], []
                    for t in base_scenario_for_price['Transactions']:
                        if t['Buy Date'] != "SUMMARY": # Exclude summary row
                            all_plot_dates.extend([pd.to_datetime(t['Buy Date']), pd.to_datetime(t['Sell Date'])])
                            all_plot_prices.extend([t['Buy Price'], t['Sell Price']])
                    
                    if all_plot_dates:
                        # Sort by date for line plot
                        sorted_plot_points = sorted(zip(all_plot_dates, all_plot_prices))
                        sorted_dates = [p[0] for p in sorted_plot_points]
                        sorted_prices = [p[1] for p in sorted_plot_points]
                        fig_combined_entry_exit.add_trace(go.Scatter(
                            x=sorted_dates, y=sorted_prices, mode='lines', name='Price (Example)',
                            line=dict(color='lightgrey', width=1)
                        ))

                for i, scenario_plot_data in enumerate(top_scenarios_for_combined_plot):
                    if scenario_plot_data.get('Transactions'):
                        buy_dates, buy_prices, sell_dates, sell_prices = [], [], [], []
                        for t in scenario_plot_data['Transactions']:
                            if t['Buy Date'] != "SUMMARY":
                                buy_dates.append(pd.to_datetime(t['Buy Date']))
                                buy_prices.append(t['Buy Price'])
                                sell_dates.append(pd.to_datetime(t['Sell Date']))
                                sell_prices.append(t['Sell Price'])
                        
                        color_val = i * 50 
                        fig_combined_entry_exit.add_trace(go.Scatter(
                            x=buy_dates, y=buy_prices, mode='markers', name=f'Sc. {i+1} Buy ({scenario_plot_data.get("Indicator", "")[:10]})',
                            marker=dict(symbol='triangle-up', size=10, color=f'rgba(0, {100+color_val%155}, 0, 0.8)')
                        ))
                        fig_combined_entry_exit.add_trace(go.Scatter(
                            x=sell_dates, y=sell_prices, mode='markers', name=f'Sc. {i+1} Sell ({scenario_plot_data.get("Indicator", "")[:10]})',
                            marker=dict(symbol='triangle-down', size=10, color=f'rgba({100+color_val%155}, 0, 0, 0.8)')
                        ))
                
            fig_combined_entry_exit.update_layout(
                title_text=f"Transaction Points for Top Scenarios - {selected_ticker_value}",
                xaxis_title="Date", yaxis_title="Price", height=500,
                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                template="plotly_white"
            )
            
            # --- Collapsible Details for Ticker Scenarios (Top 10) ---
            ticker_collapsible_details_list = []
            for i, scenario_detail_data in enumerate(top_scenarios_for_details_and_charts, 1):
                internal_id_for_pattern = scenario_detail_data['Scenario ID'] # Internal ID for MATCH
                
                if scenario_detail_data.get('Transactions'):
                    transactions_for_table = scenario_detail_data['Transactions']
                    ticker_collapsible_details_list.append(html.Div([
                        html.Div( # Clickable header
                            children=[
                                html.Span(f"Ticker Scenario #{i} - {scenario_detail_data.get('Indicator', 'N/A')} (Profit: {scenario_detail_data.get('Total Percentage Profit', 0):.2f}%)", 
                                        className="font-semibold"),
                                html.I(className="fas fa-chevron-down ml-2", id={'type': 'ticker-icon', 'index': internal_id_for_pattern})
                            ],
                            id={'type': 'ticker-btn-scenario', 'index': internal_id_for_pattern},
                            className="flex w-full justify-between items-center p-3 bg-blue-50 hover:bg-blue-100 text-left border rounded mb-1 cursor-pointer",
                        ),
                        html.Div( # Collapsible content
                            children=[
                                dcc.Graph(
                                    figure=create_scenario_chart(scenario_detail_data, selected_ticker_value),
                                    config={'displayModeBar': True}, className="mb-4"
                                ),
                                dash_table.DataTable(
                                    data=[t for t in transactions_for_table],
                                    columns=[ # Ensure these match the structure in create_backtesting_profit_results
                                        {'name': 'Buy Date', 'id': 'Buy Date'},
                                        {'name': 'Buy Price', 'id': 'Buy Price', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Sell Date', 'id': 'Sell Date'},
                                        {'name': 'Sell Price', 'id': 'Sell Price', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Shares', 'id': 'Shares'},
                                        {'name': 'Investment', 'id': 'Investment', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Proceeds', 'id': 'Proceeds', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Profit', 'id': 'Profit', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Percentage Profit', 'id': 'Percentage Profit', 'type': 'numeric', 'format': {'specifier': '.2f'}},
                                        {'name': 'Capital After Trade', 'id': 'Capital After Trade', 'type': 'numeric', 'format': {'specifier': '.2f'}}
                                    ],
                                    page_size=10, style_table={'overflowX': 'auto'},
                                    style_cell={'textAlign': 'left', 'padding': '10px'},
                                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                                    style_data_conditional=[
                                        {'if': {'filter_query': '{Buy Date} contains "SUMMARY"'}, 'backgroundColor': 'rgba(0, 255, 0, 0.1)', 'fontWeight': 'bold'},
                                        {'if': {'filter_query': '{Profit} > 0 && {Buy Date} != "SUMMARY"'},'color': 'green'},
                                        {'if': {'filter_query': '{Profit} < 0 && {Buy Date} != "SUMMARY"'},'color': 'red'}
                                    ]
                                )
                            ],
                            id={'type': 'ticker-collapse', 'index': internal_id_for_pattern},
                            className="overflow-hidden bg-white p-4 border rounded-b",
                            style={'display': 'none'} # Initially hidden
                        )
                    ], className="mb-3"))
            
            # --- Ticker-Specific Profit/Loss Bar Chart (Top 10) ---
            ticker_profit_loss_barchart_figure = create_profit_loss_barchart(
                top_scenarios_for_details_and_charts, 
                title_text=f"Indicator Profitability for {selected_ticker_value}",
                x_axis_label="Indicator",
                group_by_ticker=False # Data is already filtered for one ticker
            )
            
            # --- Assemble all components for the ticker-specific section ---
            return html.Div([
                html.H3(f"Top Scenarios for {selected_ticker_value}", className="text-xl font-semibold mb-4"),
                
                # Summary Table
                dash_table.DataTable(
                    id=f"ticker-summary-table-{selected_ticker_value.replace(' ', '_')}", # Unique ID for table
                    data=ticker_summary_table_data,
                    columns=ticker_summary_table_cols,
                    page_size=10, style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={'backgroundColor': 'rgb(240, 240, 240)', 'fontWeight': 'bold'},
                    style_data_conditional=[{'if': {'row_index': 0}, 'backgroundColor': 'rgba(0, 255, 0, 0.1)'}]
                ),
                
                # Combined Transaction Entry/Exit Chart
                # html.Div([
                #     html.H4("Transaction Entry & Exit Points (Top 5 Ticker Scenarios)", className="text-lg font-semibold mt-6 mb-3"),
                #     dcc.Graph(figure=fig_combined_entry_exit)
                # ], className="mt-4 mb-6"),
                
                # Ticker-Specific Profit/Loss Bar Chart
                html.Div([
                    html.H4(f"Indicator Profitability Breakdown for {selected_ticker_value}", className="text-lg font-semibold mt-6 mb-3"),
                    dcc.Graph(figure=ticker_profit_loss_barchart_figure)
                ], className="mt-4 mb-6"),

                # Detailed Transaction Tables (Collapsible)
                html.Div([
                    html.H4("Detailed Transaction History (Top 10 Ticker Scenarios)", className="text-lg font-semibold mt-4 mb-3"),
                    html.P("Click on a scenario to view its detailed transactions and chart.", className="text-sm text-gray-600 mb-3"),
                    html.Div(ticker_collapsible_details_list)
                ], className="mt-4"),
            ])
        except json.JSONDecodeError:
            return html.Div("Error: Could not decode stored scenario data. Please re-run backtesting.", className="text-red-500 p-4")
        except Exception as e:
            print(f"Error in update_ticker_specific_scenarios for {selected_ticker_value}: {e}")
            return html.Div([
                html.P(f"An error occurred while generating results for {selected_ticker_value}:", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded whitespace-pre-wrap")
            ])


    @app.callback(
        [Output({'type': 'global-collapse', 'index': MATCH}, "style"),
        Output({'type': 'global-icon', 'index': MATCH}, "className")],
        [Input({'type': 'global-btn-scenario', 'index': MATCH}, "n_clicks")],
        [State({'type': 'global-collapse', 'index': MATCH}, "style")],
        prevent_initial_call=True
    )
    def toggle_global_scenario_collapse(n_clicks, current_style):
        if not n_clicks: # n_clicks can be None on first load even with prevent_initial_call
            raise dash.exceptions.PreventUpdate
        
        is_open = current_style and current_style.get('display') == 'block'
        
        if is_open:
            new_style = {'display': 'none'}
            new_icon_class = "fas fa-chevron-down ml-2"
        else:
            new_style = {'display': 'block'}
            new_icon_class = "fas fa-chevron-up ml-2"
            
        return new_style, new_icon_class

    @app.callback(
        [Output({'type': 'ticker-collapse', 'index': MATCH}, "style"),
        Output({'type': 'ticker-icon', 'index': MATCH}, "className")],
        [Input({'type': 'ticker-btn-scenario', 'index': MATCH}, "n_clicks")],
        [State({'type': 'ticker-collapse', 'index': MATCH}, "style")],
        prevent_initial_call=True
    )
    def toggle_ticker_scenario_collapse(n_clicks, current_style):
        if not n_clicks:
            raise dash.exceptions.PreventUpdate

        is_open = current_style and current_style.get('display') == 'block'

        if is_open:
            new_style = {'display': 'none'}
            new_icon_class = "fas fa-chevron-down ml-2"
        else:
            new_style = {'display': 'block'}
            new_icon_class = "fas fa-chevron-up ml-2"
            
        return new_style, new_icon_class




    # Add this new helper function to create a chart for a specific scenario
    def create_scenario_chart(scenario_data, ticker_name):
        """Create a chart showing transactions for a specific scenario"""
        fig = go.Figure()
        
        transactions_list = [t for t in scenario_data.get('Transactions', []) if t.get('Buy Date') != "SUMMARY"]
        
        if not transactions_list:
            fig.update_layout(title_text=f"No transaction data for Scenario {scenario_data.get('Scenario ID', '')}")
            return fig 

        dates, prices, buy_dates, buy_prices, sell_dates, sell_prices = [], [], [], [], [], []
        
        for t in transactions_list:
            buy_dt = pd.to_datetime(t['Buy Date'])
            sell_dt = pd.to_datetime(t['Sell Date'])
            buy_dates.append(buy_dt); buy_prices.append(t['Buy Price'])
            dates.append(buy_dt); prices.append(t['Buy Price'])
            sell_dates.append(sell_dt); sell_prices.append(t['Sell Price'])
            dates.append(sell_dt); prices.append(t['Sell Price'])
        
        if dates:
            date_price_pairs = sorted(zip(dates, prices), key=lambda pair: pair[0])
            sorted_dates = [pair[0] for pair in date_price_pairs]
            sorted_prices = [pair[1] for pair in date_price_pairs]
            fig.add_trace(go.Scatter(x=sorted_dates, y=sorted_prices, mode='lines', name='Price Path', line=dict(color='lightgray', width=1.5)))
        
        fig.add_trace(go.Scatter(
            x=buy_dates, y=buy_prices, mode='markers', name='Buy',
            marker=dict(symbol='triangle-up', size=12, color='green'),
            text=[f"Buy: {p:.2f}<br>Date: {d.strftime('%Y-%m-%d')}" for p, d in zip(buy_prices, buy_dates)], hoverinfo='text'
        ))
        fig.add_trace(go.Scatter(
            x=sell_dates, y=sell_prices, mode='markers', name='Sell',
            marker=dict(symbol='triangle-down', size=12, color='red'),
            text=[f"Sell: {p:.2f}<br>Date: {d.strftime('%Y-%m-%d')}<br>Profit: {t.get('Profit',0):.2f}" 
                for p, d, t in zip(sell_prices, sell_dates, transactions_list)], hoverinfo='text'
        ))
        
        capital_values, capital_dates = [], []
        current_capital_val = scenario_data.get('Initial Capital', 0)
        # Add initial capital point
        if transactions_list:
            first_buy_date = pd.to_datetime(transactions_list[0]['Buy Date'])
            capital_dates.append(first_buy_date - pd.Timedelta(days=1)) # Slightly before first trade
            capital_values.append(current_capital_val)


        for t in transactions_list: # Re-calculate capital progression for plot if needed
            # This part assumes 'Shares' is correctly reflecting the trade for capital calculation.
            # If 'Capital After Trade' is reliable, it could be used directly.
            # For plotting a smooth line, it's often better to plot points before buy, after buy, before sell, after sell.
            # Simplified for this example:
            capital_dates.append(pd.to_datetime(t['Buy Date']))
            capital_values.append(t['Capital After Trade'] - t['Profit']) # Capital before this trade's profit/loss
            capital_dates.append(pd.to_datetime(t['Sell Date']))
            capital_values.append(t['Capital After Trade'])


        if capital_dates:
            # Sort capital points by date
            sorted_capital_points = sorted(zip(capital_dates, capital_values), key=lambda x: x[0])
            final_capital_dates = [p[0] for p in sorted_capital_points]
            final_capital_values = [p[1] for p in sorted_capital_points]

            fig.add_trace(go.Scatter(
                x=final_capital_dates, y=final_capital_values, mode='lines+markers', name='Capital',
                line=dict(color='blue', width=1.5, dash='dot'), marker=dict(size=6), yaxis="y2"
            ))
        
        fig.update_layout(
            title_text=f"Scenario Details: {ticker_name} with {scenario_data.get('Indicator', 'N/A')}",
            xaxis_title="Date", yaxis_title="Price",
            yaxis2=dict(title="Capital", overlaying="y", side="right", showgrid=False, zeroline=False),
            height=400, margin=dict(l=50, r=60, t=50, b=40), # Adjusted right margin for y2 axis
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            hovermode="x unified" # Or "closest"
        )
        return fig

    def create_profit_loss_barchart(scenarios_data_list, title_text, x_axis_label="Indicator", group_by_ticker=False):
        if not scenarios_data_list:
            return go.Figure(layout_title_text=f"{title_text} (No data available)")

        chart_df_input_data = []
        for s_item in scenarios_data_list:
            label = f"{s_item.get('Ticker', '')} - {s_item['Indicator']}" if group_by_ticker else s_item['Indicator']
            # Use percentage profit for better comparability
            chart_df_input_data.append({'Label': label, 'Profit %': s_item.get('Total Percentage Profit', 0)})
        
        df_for_chart = pd.DataFrame(chart_df_input_data)
        if df_for_chart.empty:
            return go.Figure(layout_title_text=f"{title_text} (No data to plot)")

        df_for_chart = df_for_chart.sort_values(by='Profit %', ascending=False)
        bar_colors = ['green' if p >= 0 else 'red' for p in df_for_chart['Profit %']]

        fig_bar = go.Figure(data=[
            go.Bar(
                x=df_for_chart['Label'], 
                y=df_for_chart['Profit %'], 
                marker_color=bar_colors,
                text=df_for_chart['Profit %'].apply(lambda x: f"{x:.2f}%"), 
                textposition='auto'
            )
        ])
        
        # Enhance the layout for better readability
        fig_bar.update_layout(
            title_text=title_text, 
            xaxis_title=x_axis_label, 
            yaxis_title="Profit Percentage (%)",
            template="plotly_white", 
            xaxis_tickangle=-30,
            hoverlabel=dict(
                bgcolor="white",
                font_size=12,
                font_family="Arial"
            ),
            # Add reference line at 0%
            shapes=[
                dict(
                    type="line",
                    xref="paper",
                    x0=0,
                    x1=1,
                    y0=0,
                    y1=0,
                    line=dict(
                        color="gray",
                        width=1,
                        dash="dash",
                    )
                )
            ]
        )
        
        return fig_bar









    @app.callback(
        Output("selected-scenario-details", "children"),
        [Input("ticker-scenarios-table", "selected_rows")],
        [State("ticker-scenarios-table", "data"),
        State("all-profit-scenarios-store", "children")]
    )
    def display_selected_scenario(selected_rows, table_data, all_scenarios_json):
        if not selected_rows or not table_data or not all_scenarios_json:
            return html.Div()
        
        try:
            # Get the selected scenario ID
            selected_scenario_id = table_data[selected_rows[0]]['Scenario ID']
            
            # Get the scenario details
            all_scenarios = json.loads(all_scenarios_json)
            if selected_scenario_id not in all_scenarios:
                return html.Div(f"Scenario {selected_scenario_id} not found", className="text-red-500")
            
            scenario = all_scenarios[selected_scenario_id]
            transactions = scenario['Transactions']
            
            # Create transaction chart
            fig = go.Figure()
            
            # Extract transaction data for chart (excluding summary row)
            chart_transactions = [t for t in transactions if t['Buy Date'] != "SUMMARY"]
            
            if chart_transactions:
                # Add price line
                dates = []
                prices = []
                
                for t in chart_transactions:
                    # Add buy point
                    dates.append(t['Buy Date'])
                    prices.append(t['Buy Price'])
                    
                    # Add sell point
                    dates.append(t['Sell Date'])
                    prices.append(t['Sell Price'])
                
                fig.add_trace(go.Scatter(
                    x=dates,
                    y=prices,
                    mode='lines',
                    name='Price',
                    line=dict(color='blue', width=2)
                ))
                
                # Add buy markers
                fig.add_trace(go.Scatter(
                    x=[t['Buy Date'] for t in chart_transactions],
                    y=[t['Buy Price'] for t in chart_transactions],
                    mode='markers',
                    name='Buy',
                    marker=dict(
                        symbol='triangle-up',
                        size=12,
                        color='green',
                    ),
                    text=[f"Buy: {t['Buy Price']:.2f}<br>Shares: {t['Shares']}" for t in chart_transactions],
                    hoverinfo='text'
                ))
                
                # Add sell markers
                fig.add_trace(go.Scatter(
                    x=[t['Sell Date'] for t in chart_transactions],
                    y=[t['Sell Price'] for t in chart_transactions],
                    mode='markers',
                    name='Sell',
                    marker=dict(
                        symbol='triangle-down',
                        size=12,
                        color='red',
                    ),
                    text=[f"Sell: {t['Sell Price']:.2f}<br>Profit: {t['Profit']:.2f}" for t in chart_transactions],
                    hoverinfo='text'
                ))
                
                fig.update_layout(
                    title=f"Transactions Chart - Scenario {selected_scenario_id}",
                    xaxis_title="Date",
                    yaxis_title="Price",
                    height=400,
                    margin=dict(l=50, r=50, t=80, b=50),
                    legend=dict(
                        orientation="h",
                        yanchor="bottom",
                        y=1.02,
                        xanchor="right",
                        x=1
                    )
                )
            
            # Create transactions table
            table = dash_table.DataTable(
                data=transactions,
                columns=[{'name': col, 'id': col} for col in transactions[0].keys()],
                page_size=10,
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Buy Date} contains "SUMMARY"'},
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                        'fontWeight': 'bold'
                    }
                ]
            )
            
            return html.Div([
                html.H3(f"Detailed View - Scenario {selected_scenario_id}", className="text-lg font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Span("Ticker: ", className="font-semibold"),
                        html.Span(scenario['Ticker'], className="ml-1 text-blue-600")
                    ], className="mr-6"),
                    html.Div([
                        html.Span("Indicator: ", className="font-semibold"),
                        html.Span(scenario['Indicator'], className="ml-1 text-blue-600")
                    ], className="mr-6"),
                    html.Div([
                        html.Span("Total Profit: ", className="font-semibold"),
                        html.Span(f"{scenario['Total Profit']:.2f} ({scenario['Total Percentage Profit']:.2f}%)", 
                                className="ml-1 text-green-600")
                    ], className="mr-6"),
                    html.Div([
                        html.Span("Trades: ", className="font-semibold"),
                        html.Span(f"{scenario['Number of Trades']}", className="ml-1")
                    ]),
                ], className="flex mb-4"),
                
                # Transaction chart
                dcc.Graph(figure=fig),
                
                # Transaction table
                html.H4("Transaction Details", className="text-lg font-semibold mt-4 mb-3"),
                table
            ], className="p-4 bg-white rounded shadow-sm")
            
        except Exception as e:
            return html.Div([
                html.P(f"Error displaying scenario details: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])










    # RAW DATA CALLBACKS
    @app.callback(
        Output("selected-ticker-data", "children"),
        [Input("raw-data-ticker-selector", "value"),
        Input("raw-data-search", "value"),
        Input("raw-data-signal-filter", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_selected_ticker_data(selected_ticker, search_term, signal_filter, n_clicks):
        if not n_clicks or not selected_ticker:
            raise dash.exceptions.PreventUpdate
        
        ctx = callback_context
        if not ctx.triggered:
            raise dash.exceptions.PreventUpdate
        
        try:
            # Fetch the data for the selected ticker
            start_date = pd.Timestamp(year=2024, month=1, day=1)  # Example default date range
            end_date = pd.Timestamp(year=2025, month=1, day=1)    # Example default date range
            
            # Get data for this ticker
            ticker_data = fetch_ticker_data(selected_ticker, start_date, end_date)
            
            if ticker_data.empty:
                return html.Div(f"No data found for {selected_ticker}", className="text-center text-gray-500 p-4")
            
            # Apply technical indicators to generate signals
            indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
            ticker_data = apply_technical_indicators(ticker_data, indicators)
            
            # Apply search filter if provided
            if search_term:
                search_term = str(search_term).lower()
                filtered_data = ticker_data[ticker_data.astype(str).apply(
                    lambda row: row.str.contains(search_term, case=False).any(), axis=1
                )]
            else:
                filtered_data = ticker_data
            
            # Apply signal filter if not 'all'
            if signal_filter != 'all' and 'Combined_Signal' in filtered_data.columns:
                filtered_data = filtered_data[filtered_data['Combined_Signal'] == signal_filter]
            
            # Calculate signal counts if Combined_Signal exists
            signal_counts = {'Buy': 0, 'Sell': 0, 'Hold': 0}
            if 'Combined_Signal' in ticker_data.columns:
                signal_counts = ticker_data['Combined_Signal'].value_counts().to_dict()
            
            # Create data table
            return html.Div([
                html.H3(f"Data for {selected_ticker}", className="text-lg font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Span("Total Rows: ", className="font-semibold"),
                        html.Span(str(len(ticker_data)), id="ticker-data-row-count")
                    ], className="mr-4"),
                    html.Div([
                        html.Span("Filtered Rows: ", className="font-semibold"),
                        html.Span(str(len(filtered_data)))
                    ], className="mr-4"),
                    html.Div([
                        html.Span("Date Range: ", className="font-semibold"),
                        html.Span(f"{ticker_data['Datetime'].min()} to {ticker_data['Datetime'].max()}")
                    ], className="mr-4"),
                    html.Div([
                        html.Span("Buy Signals: ", className="font-semibold"),
                        html.Span(str(signal_counts.get('Buy', 0)), className="text-green-600")
                    ], className="mr-4"),
                    html.Div([
                        html.Span("Sell Signals: ", className="font-semibold"),
                        html.Span(str(signal_counts.get('Sell', 0)), className="text-red-600")
                    ], className="mr-4"),
                    html.Div([
                        html.Span("Hold Signals: ", className="font-semibold"),
                        html.Span(str(signal_counts.get('Hold', 0)), className="text-gray-600")
                    ])
                ], className="flex flex-wrap mb-3"),
                
                # Data table
                dash_table.DataTable(
                    id=f'data-table-{selected_ticker}',
                    columns=[{'name': col, 'id': col} for col in filtered_data.columns],
                    data=filtered_data.to_dict('records'),
                    style_table={'overflowX': 'auto', 'maxHeight': '500px'},
                    style_cell={'textAlign': 'left', 'padding': '5px'},
                    style_data_conditional=[
                        {
                            'if': {'column_id': 'Combined_Signal', 'filter_query': '{Combined_Signal} = "Buy"'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'column_id': 'Combined_Signal', 'filter_query': '{Combined_Signal} = "Sell"'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        }
                    ],
                    page_size=15,
                    sort_action='native',
                    filter_action='native'
                ),
                
                # Download button
                html.Button(
                    "Download Data for This Ticker",
                    id=f"download-{selected_ticker.replace('.', '-')}",
                    className="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded mt-4"
                )
            ])
            
        except Exception as e:
            return html.Div([
                html.P(f"Error displaying data: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])
    


    # Create callbacks to populate the ticker-specific content in detailed results
    @app.callback(
        [Output(f"{ticker.replace('.', '-')}-raw-data", "children") for ticker in AVAILABLE_TICKERS],
        [Input("ticker-tabs", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_ticker_raw_data(selected_ticker, n_clicks):
        if not n_clicks or not selected_ticker:
            return [dash.no_update] * len(AVAILABLE_TICKERS)
        
        outputs = []
        for ticker in AVAILABLE_TICKERS:
            if ticker == selected_ticker:
                try:
                    # Fetch actual data for the selected ticker
                    start_date = pd.Timestamp(year=2022, month=1, day=1)  # Use actual dates from your inputs
                    end_date = pd.Timestamp(year=2023, month=1, day=1)
                    
                    df = fetch_ticker_data(ticker, start_date, end_date)
                    
                    if df.empty:
                        outputs.append(html.Div(f"No data available for {ticker}", className="text-center text-gray-500"))
                        continue
                    
                    # Apply technical indicators
                    indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
                    df = apply_technical_indicators(df, indicators)
                    
                    # Create summary stats
                    summary = html.Div([
                        html.H4("Data Summary", className="text-lg font-semibold mb-2"),
                        html.Div([
                            html.P(f"Total Records: {len(df)}", className="mb-1"),
                            html.P(f"Date Range: {df['Datetime'].min()} to {df['Datetime'].max()}", className="mb-1"),
                            html.P(f"Average Price: {df['Close'].mean():.2f}", className="mb-1"),
                            html.P(f"Price Range: {df['Close'].min():.2f} to {df['Close'].max():.2f}", className="mb-1"),
                            html.P(f"Average Volume: {df['Volume'].mean():.2f}", className="mb-1"),
                        ], className="p-3 bg-gray-50 rounded mb-4")
                    ])
                    
                    # Create data table
                    table = dash_table.DataTable(
                        data=df.head(1000).to_dict('records'),  # Limited to first 1000 rows for performance
                        columns=[{'name': col, 'id': col} for col in df.columns],
                        style_table={'overflowX': 'auto', 'maxHeight': '500px'},
                        style_cell={'textAlign': 'left', 'padding': '5px'},
                        style_data_conditional=[
                            {
                                'if': {'column_id': col, 'filter_query': '{' + col + '} = "Buy"'}
                                for col in [c for c in df.columns if 'Signal' in c]
                            },
                            {
                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                'color': 'green'
                            },
                            {
                                'if': {'column_id': col, 'filter_query': '{' + col + '} = "Sell"'}
                                for col in [c for c in df.columns if 'Signal' in c]
                            },
                            {
                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                'color': 'red'
                            }
                        ],
                        page_size=15,
                        sort_action='native',
                        filter_action='native'
                    )
                    
                    outputs.append(html.Div([summary, table]))
                except Exception as e:
                    outputs.append(html.Div([
                        html.P(f"Error loading raw data for {ticker}: {str(e)}", className="text-red-500"),
                        html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
                    ]))
            else:
                outputs.append(dash.no_update)
        
        return outputs

    # Callback for backtesting analysis content
    @app.callback(
        [Output(f"{ticker.replace('.', '-')}-bollinger-content", "children") for ticker in AVAILABLE_TICKERS],
        [Input("ticker-tabs", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_ticker_bollinger_content(selected_ticker, n_clicks):
        if not n_clicks or not selected_ticker:
            return [dash.no_update] * len(AVAILABLE_TICKERS)
        
        outputs = []
        for ticker in AVAILABLE_TICKERS:
            if ticker == selected_ticker:
                try:
                    # Fetch and process data with Bollinger Band analysis
                    start_date = pd.Timestamp(year=2022, month=1, day=1)
                    end_date = pd.Timestamp(year=2023, month=1, day=1)
                    
                    df = fetch_ticker_data(ticker, start_date, end_date)
                    
                    if df.empty:
                        outputs.append(html.Div(f"No data available for {ticker} Bollinger analysis", className="text-center text-gray-500"))
                        continue
                    
                    # Apply Bollinger indicator
                    df = apply_technical_indicators(df, ['Bollinger_Signal'])
                    
                    if 'Bollinger_Signal' not in df.columns:
                        outputs.append(html.Div("Bollinger Band signals could not be calculated", className="text-red-500"))
                        continue
                    
                    # Calculate performance metrics
                    buy_signals = df[df['Bollinger_Signal'] == 'Buy']
                    sell_signals = df[df['Bollinger_Signal'] == 'Sell']
                    
                    # Run backtest for Bollinger
                    capital = 10000000  # Example initial capital
                    backtest_result = run_backtest_for_indicator(df, 'Bollinger_Signal', capital)
                    
                    if not backtest_result:
                        outputs.append(html.Div("Backtesting failed for Bollinger Bands", className="text-red-500"))
                        continue
                    
                    # Create metrics section
                    metrics = html.Div([
                        html.H4("Bollinger Bands Performance", className="text-lg font-semibold mb-2"),
                        html.Div([
                            html.Div([
                                html.Div([
                                    html.Span("Buy Signals", className="block text-sm text-gray-500"),
                                    html.Span(f"{len(buy_signals)}", className="block text-xl font-bold text-green-600")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Sell Signals", className="block text-sm text-gray-500"),
                                    html.Span(f"{len(sell_signals)}", className="block text-xl font-bold text-red-600")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Total Profit", className="block text-sm text-gray-500"),
                                    html.Span(f"{backtest_result['total_profit']:,.2f}", 
                                            className=f"block text-xl font-bold {'text-green-600' if backtest_result['total_profit'] > 0 else 'text-red-600'}")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Win Rate", className="block text-sm text-gray-500"),
                                    html.Span(f"{backtest_result['win_rate']:.2f}%", className="block text-xl font-bold text-blue-600")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                        ], className="flex -mx-2 mb-4")
                    ])
                    
                    # Create trade table with detailed information
                    trades = backtest_result['trades']
                    trade_table = dash_table.DataTable(
                        data=[{
                            'Date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
                            'Signal': t['type'],
                            'Price': f"{t['price']:.2f}",
                            'Shares': t['shares'],
                            'Value': f"{t['value']:,.2f}",
                            'Cash': f"{t['remaining_cash']:,.2f}",
                            'Profit/Loss': f"{t['value'] - (t['shares'] * df.loc[df['Datetime'] == t['date'], 'Close'].iloc[0]) if t['type'] == 'Sell' else 0:,.2f}"
                        } for t in trades if hasattr(t['date'], 'strftime') or isinstance(t['date'], str)],
                        columns=[
                            {'name': 'Date', 'id': 'Date'},
                            {'name': 'Signal', 'id': 'Signal'},
                            {'name': 'Price', 'id': 'Price'},
                            {'name': 'Shares', 'id': 'Shares'},
                            {'name': 'Value', 'id': 'Value'},
                            {'name': 'Cash', 'id': 'Cash'},
                            {'name': 'Profit/Loss', 'id': 'Profit/Loss'}
                        ],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px'},
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{Signal} = "Buy"'},
                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                'color': 'green'
                            },
                            {
                                'if': {'filter_query': '{Signal} = "Sell"'},
                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                'color': 'red'
                            }
                        ],
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        page_size=10
                    )
                    
                    # Create chart visualization
                    fig = go.Figure()
                    
                    # Price with Bollinger Bands
                    fig.add_trace(go.Scatter(
                        x=df['Datetime'],
                        y=df['Close'],
                        mode='lines',
                        name='Close Price',
                        line=dict(color='blue')
                    ))
                    
                    if 'Upper Band' in df.columns and 'Lower Band' in df.columns and 'Middle Band' in df.columns:
                        fig.add_trace(go.Scatter(
                            x=df['Datetime'],
                            y=df['Upper Band'],
                            mode='lines',
                            name='Upper Band',
                            line=dict(color='red', dash='dot')
                        ))
                        
                        fig.add_trace(go.Scatter(
                            x=df['Datetime'],
                            y=df['Lower Band'],
                            mode='lines',
                            name='Lower Band',
                            line=dict(color='green', dash='dot')
                        ))
                        
                        fig.add_trace(go.Scatter(
                            x=df['Datetime'],
                            y=df['Middle Band'],
                            mode='lines',
                            name='Middle Band',
                            line=dict(color='purple', dash='dash')
                        ))
                    
                    # Add buy/sell markers
                    fig.add_trace(go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals['Close'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='green')
                    ))
                    
                    fig.add_trace(go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals['Close'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='red')
                    ))
                    
                    fig.update_layout(
                        title=f"Bollinger Bands Analysis for {ticker}",
                        xaxis_title="Date",
                        yaxis_title="Price",
                        height=600,
                        legend=dict(
                            yanchor="top",
                            y=0.99,
                            xanchor="left",
                            x=0.01
                        ),
                        margin=dict(l=50, r=50, t=50, b=50)
                    )
                    
                    chart = dcc.Graph(figure=fig)
                    
                    outputs.append(html.Div([metrics, chart, html.H4("Detailed Trade History", className="text-lg font-semibold mt-4 mb-3"), trade_table]))
                except Exception as e:
                    outputs.append(html.Div([
                        html.P(f"Error creating Bollinger analysis for {ticker}: {str(e)}", className="text-red-500"),
                        html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
                    ]))
            else:
                outputs.append(dash.no_update)
        
        return outputs





    # @app.callback(
    #     [Output(f"{ticker.replace('.', '-')}-bollinger-content", "children") for ticker in AVAILABLE_TICKERS],
    #     [Input("ticker-tabs", "value")],
    #     [State("run-bulk-analysis", "n_clicks")]
    # )

    @app.callback(
        [Output(f"{ticker.replace('.', '-')}-ma-content", "children") for ticker in AVAILABLE_TICKERS],
        [Input("ticker-tabs", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_ticker_ma_content(selected_ticker, n_clicks):
        if not n_clicks or not selected_ticker:
            return [dash.no_update] * len(AVAILABLE_TICKERS)
        
        outputs = []
        for ticker in AVAILABLE_TICKERS:
            if ticker == selected_ticker:
                try:
                    # Fetch and process data with Moving Average analysis
                    start_date = pd.Timestamp(year=2022, month=1, day=1)
                    end_date = pd.Timestamp(year=2023, month=1, day=1)
                    
                    df = fetch_ticker_data(ticker, start_date, end_date)
                    
                    if df.empty:
                        outputs.append(html.Div(f"No data available for {ticker} Moving Average analysis", className="text-center text-gray-500"))
                        continue
                    
                    # Apply MA indicator
                    df = apply_technical_indicators(df, ['MA_Signal'])
                    
                    if 'MA_Signal' not in df.columns:
                        outputs.append(html.Div("Moving Average signals could not be calculated", className="text-red-500"))
                        continue
                    
                    # Calculate performance metrics
                    buy_signals = df[df['MA_Signal'] == 'Buy']
                    sell_signals = df[df['MA_Signal'] == 'Sell']
                    
                    # Run backtest for MA
                    capital = 10000000  # Example initial capital
                    backtest_result = run_backtest_for_indicator(df, 'MA_Signal', capital)
                    
                    if not backtest_result:
                        outputs.append(html.Div("Backtesting failed for Moving Average", className="text-red-500"))
                        continue
                    
                    # Create metrics section
                    metrics = html.Div([
                        html.H4("Moving Average Performance", className="text-lg font-semibold mb-2"),
                        html.Div([
                            html.Div([
                                html.Div([
                                    html.Span("Buy Signals", className="block text-sm text-gray-500"),
                                    html.Span(f"{len(buy_signals)}", className="block text-xl font-bold text-green-600")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Sell Signals", className="block text-sm text-gray-500"),
                                    html.Span(f"{len(sell_signals)}", className="block text-xl font-bold text-red-600")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Total Profit", className="block text-sm text-gray-500"),
                                    html.Span(f"{backtest_result['total_profit']:,.2f}", 
                                            className=f"block text-xl font-bold {'text-green-600' if backtest_result['total_profit'] > 0 else 'text-red-600'}")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Win Rate", className="block text-sm text-gray-500"),
                                    html.Span(f"{backtest_result['win_rate']:.2f}%", className="block text-xl font-bold text-blue-600")
                                ], className="p-3 border rounded bg-white shadow-sm")
                            ], className="w-1/4 px-2"),
                        ], className="flex -mx-2 mb-4")
                    ])
                    
                    # Create trade table with detailed information
                    trades = backtest_result['trades']
                    trade_table = dash_table.DataTable(
                        data=[{
                            'Date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
                            'Signal': t['type'],
                            'Price': f"{t['price']:.2f}",
                            'Shares': t['shares'],
                            'Value': f"{t['value']:,.2f}",
                            'Cash': f"{t['remaining_cash']:,.2f}",
                            'Profit/Loss': f"{t['value'] - (t['shares'] * df.loc[df['Datetime'] == t['date'], 'Close'].iloc[0]) if t['type'] == 'Sell' else 0:,.2f}"
                        } for t in trades if hasattr(t['date'], 'strftime') or isinstance(t['date'], str)],
                        columns=[
                            {'name': 'Date', 'id': 'Date'},
                            {'name': 'Signal', 'id': 'Signal'},
                            {'name': 'Price', 'id': 'Price'},
                            {'name': 'Shares', 'id': 'Shares'},
                            {'name': 'Value', 'id': 'Value'},
                            {'name': 'Cash', 'id': 'Cash'},
                            {'name': 'Profit/Loss', 'id': 'Profit/Loss'}
                        ],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px'},
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{Signal} = "Buy"'},
                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                'color': 'green'
                            },
                            {
                                'if': {'filter_query': '{Signal} = "Sell"'},
                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                'color': 'red'
                            }
                        ],
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        page_size=10
                    )
                    
                    # Create chart visualization
                    fig = go.Figure()
                    
                    # Price with Moving Averages
                    fig.add_trace(go.Scatter(
                        x=df['Datetime'],
                        y=df['Close'],
                        mode='lines',
                        name='Close Price',
                        line=dict(color='blue')
                    ))
                    
                    if 'short_MA' in df.columns and 'long_MA' in df.columns:
                        fig.add_trace(go.Scatter(
                            x=df['Datetime'],
                            y=df['short_MA'],
                            mode='lines',
                            name='Short MA',
                            line=dict(color='orange')
                        ))
                        
                        fig.add_trace(go.Scatter(
                            x=df['Datetime'],
                            y=df['long_MA'],
                            mode='lines',
                            name='Long MA',
                            line=dict(color='purple')
                        ))
                    
                    # Add buy/sell markers
                    fig.add_trace(go.Scatter(
                        x=buy_signals['Datetime'],
                        y=buy_signals['Close'],
                        mode='markers',
                        name='Buy Signal',
                        marker=dict(symbol='triangle-up', size=12, color='green')
                    ))
                    
                    fig.add_trace(go.Scatter(
                        x=sell_signals['Datetime'],
                        y=sell_signals['Close'],
                        mode='markers',
                        name='Sell Signal',
                        marker=dict(symbol='triangle-down', size=12, color='red')
                    ))
                    
                    fig.update_layout(
                        title=f"Moving Average Analysis for {ticker}",
                        xaxis_title="Date",
                        yaxis_title="Price",
                        height=600,
                        legend=dict(
                            yanchor="top",
                            y=0.99,
                            xanchor="left",
                            x=0.01
                        ),
                        margin=dict(l=50, r=50, t=50, b=50)
                    )
                    
                    chart = dcc.Graph(figure=fig)
                    
                    outputs.append(html.Div([metrics, chart, html.H4("Detailed Trade History", className="text-lg font-semibold mt-4 mb-3"), trade_table]))
                except Exception as e:
                    outputs.append(html.Div([
                        html.P(f"Error creating MA analysis for {ticker}: {str(e)}", className="text-red-500"),
                        html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
                    ]))
            else:
                outputs.append(dash.no_update)
        
        return outputs







    @app.callback(
        [Output(f"{ticker.replace('.', '-')}-trade-history", "children") for ticker in AVAILABLE_TICKERS],
        [Input("ticker-tabs", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_ticker_trade_history(selected_ticker, n_clicks):
        if not n_clicks or not selected_ticker:
            return [dash.no_update] * len(AVAILABLE_TICKERS)
        
        outputs = []
        for ticker in AVAILABLE_TICKERS:
            if ticker == selected_ticker:
                try:
                    # Fetch and process data for backtesting profit
                    start_date = pd.Timestamp(year=2022, month=1, day=1)
                    end_date = pd.Timestamp(year=2023, month=1, day=1)
                    
                    df = fetch_ticker_data(ticker, start_date, end_date)
                    
                    if df.empty:
                        outputs.append(html.Div(f"No data available for {ticker} trade history", className="text-center text-gray-500"))
                        continue
                    
                    # Apply all indicators
                    indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
                    df = apply_technical_indicators(df, indicators)
                    
                    # Generate combined signal
                    df = calculate_combined_signal(df, indicators)
                    
                    # Run backtest for Combined signal
                    capital = 10000000  # Example initial capital
                    backtest_result = run_backtest_for_indicator(df, 'Combined_Signal', capital)
                    
                    if not backtest_result:
                        outputs.append(html.Div("Backtesting failed for profit analysis", className="text-red-500"))
                        continue
                    
                    trades = backtest_result['trades']
                    
                    # Create detailed trade history table
                    trade_history = html.Div([
                        dash_table.DataTable(
                            data=[{
                                'Date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
                                'Type': t['type'],
                                'Price': f"{t['price']:.2f}",
                                'Shares': t['shares'],
                                'Volume': f"{df.loc[df['Datetime'] == t['date'], 'Volume'].iloc[0]:,.0f}" if not df[df['Datetime'] == t['date']].empty else "N/A",
                                'Transaction Value': f"{t['value']:,.2f}",
                                'Cash After': f"{t['remaining_cash']:,.2f}",
                                'Portfolio Value': f"{t['remaining_cash'] + (t['shares'] * t['price'] if t['type'] == 'Buy' else 0):,.2f}"
                            } for t in trades if hasattr(t['date'], 'strftime') or isinstance(t['date'], str)],
                            columns=[
                                {'name': 'Date', 'id': 'Date'},
                                {'name': 'Type', 'id': 'Type'},
                                {'name': 'Price', 'id': 'Price'},
                                {'name': 'Shares', 'id': 'Shares'},
                                {'name': 'Volume', 'id': 'Volume'},
                                {'name': 'Transaction Value', 'id': 'Transaction Value'},
                                {'name': 'Cash After', 'id': 'Cash After'},
                                {'name': 'Portfolio Value', 'id': 'Portfolio Value'}
                            ],
                            style_table={'overflowX': 'auto'},
                            style_cell={'textAlign': 'left', 'padding': '10px'},
                            style_data_conditional=[
                                {
                                    'if': {'filter_query': '{Type} = "Buy"'},
                                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                    'color': 'green'
                                },
                                {
                                    'if': {'filter_query': '{Type} = "Sell"'},
                                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                    'color': 'red'
                                }
                            ],
                            style_header={
                                'backgroundColor': 'rgb(240, 240, 240)',
                                'fontWeight': 'bold'
                            },
                            page_size=15,
                            sort_action='native'
                        )
                    ])
                    
                    outputs.append(trade_history)
                except Exception as e:
                    outputs.append(html.Div([
                        html.P(f"Error creating trade history for {ticker}: {str(e)}", className="text-red-500"),
                        html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
                    ]))
            else:
                outputs.append(dash.no_update)
        
        return outputs

    @app.callback(
        [Output(f"{ticker.replace('.', '-')}-capital-growth", "figure") for ticker in AVAILABLE_TICKERS],
        [Input("ticker-tabs", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_ticker_capital_growth(selected_ticker, n_clicks):
        if not n_clicks or not selected_ticker:
            return [dash.no_update] * len(AVAILABLE_TICKERS)
        
        outputs = []
        for ticker in AVAILABLE_TICKERS:
            if ticker == selected_ticker:
                try:
                    # Fetch and process data for capital growth
                    start_date = pd.Timestamp(year=2022, month=1, day=1)
                    end_date = pd.Timestamp(year=2023, month=1, day=1)
                    
                    df = fetch_ticker_data(ticker, start_date, end_date)
                    
                    if df.empty:
                        outputs.append({})  # Empty figure
                        continue
                    
                    # Apply all indicators & generate combined signal
                    indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
                    df = apply_technical_indicators(df, indicators)
                    df = calculate_combined_signal(df, indicators)
                    
                    # Run backtests for all indicators
                    capital = 10000000
                    results = {}
                    
                    for indicator in indicators + ['Combined_Signal']:
                        result = run_backtest_for_indicator(df, indicator, capital)
                        if result:
                            results[indicator] = result
                    
                    # Create capital growth figure
                    fig = go.Figure()
                    
                    for indicator, result in results.items():
                        # Create capital values over time
                        x_vals = []
                        y_vals = []
                        colors = []
                        symbols = []
                        
                        for i, trade in enumerate(result['trades']):
                            x_vals.append(i)
                            y_vals.append(trade['remaining_cash'])
                            colors.append('green' if trade['type'] == 'Buy' else 'red')
                            symbols.append('circle-open' if trade['type'] == 'Buy' else 'circle')
                        
                        # Add trace for this indicator
                        fig.add_trace(go.Scatter(
                            x=x_vals,
                            y=y_vals,
                            mode='lines+markers',
                            name=indicator,
                            marker=dict(
                                color=colors,
                                symbol=symbols,
                                size=10
                            )
                        ))
                    
                    # Add initial capital reference line
                    fig.add_shape(
                        type="line",
                        x0=0,
                        y0=capital,
                        x1=max([len(r['trades']) for r in results.values()]) if results else 10,
                        y1=capital,
                        line=dict(
                            color="gray",
                            width=1,
                            dash="dash",
                        )
                    )
                    
                    fig.update_layout(
                        title=f"Capital Growth by Trading Strategy for {ticker}",
                        xaxis_title="Trade Number",
                        yaxis_title="Capital Value",
                        height=500,
                        legend=dict(
                            yanchor="top",
                            y=0.99,
                            xanchor="left",
                            x=0.01
                        )
                    )
                    
                    outputs.append(fig)
                except Exception as e:
                    print(f"Error creating capital growth chart: {str(e)}")
                    # Return empty figure on error
                    outputs.append({})
            else:
                outputs.append(dash.no_update)
        
        return outputs




    @app.callback(
        [Output(f"{ticker.replace('.', '-')}-trade-statistics", "children") for ticker in AVAILABLE_TICKERS],
        [Input("ticker-tabs", "value")],
        [State("run-bulk-analysis", "n_clicks")]
    )
    def update_ticker_trade_statistics(selected_ticker, n_clicks):
        if not n_clicks or not selected_ticker:
            return [dash.no_update] * len(AVAILABLE_TICKERS)
        
        outputs = []
        for ticker in AVAILABLE_TICKERS:
            if ticker == selected_ticker:
                try:
                    # Fetch and process data for trade statistics
                    start_date = pd.Timestamp(year=2022, month=1, day=1)
                    end_date = pd.Timestamp(year=2023, month=1, day=1)
                    
                    df = fetch_ticker_data(ticker, start_date, end_date)
                    
                    if df.empty:
                        outputs.append(html.Div(f"No data available for {ticker} trade statistics", className="text-center text-gray-500"))
                        continue
                    
                    # Apply all indicators
                    indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
                    df = apply_technical_indicators(df, indicators)
                    df = calculate_combined_signal(df, indicators)
                    
                    # Run backtest for all indicators
                    capital = 10000000
                    results = {}
                    
                    for indicator in indicators + ['Combined_Signal']:
                        result = run_backtest_for_indicator(df, indicator, capital)
                        if result:
                            results[indicator] = result
                    
                    # Compile trade statistics
                    stats_data = []
                    for indicator, result in results.items():
                        buy_trades = [t for t in result['trades'] if t['type'] == 'Buy']
                        sell_trades = [t for t in result['trades'] if t['type'] == 'Sell']
                        
                        # Calculate average holding period
                        holding_periods = []
                        for i in range(min(len(buy_trades), len(sell_trades))):
                            if hasattr(buy_trades[i]['date'], 'timestamp') and hasattr(sell_trades[i]['date'], 'timestamp'):
                                days = (sell_trades[i]['date'] - buy_trades[i]['date']).days
                                holding_periods.append(days)
                        
                        avg_holding = sum(holding_periods) / len(holding_periods) if holding_periods else 0
                        
                        # Calculate average profit per trade
                        if sell_trades:
                            avg_profit = result['total_profit'] / len(sell_trades)
                        else:
                            avg_profit = 0
                        
                        # Calculate win/loss ratio
                        winning_trades = sum(1 for i in range(min(len(buy_trades), len(sell_trades))) 
                                            if sell_trades[i]['price'] > buy_trades[i]['price'])
                        losing_trades = min(len(buy_trades), len(sell_trades)) - winning_trades
                        
                        stats_data.append({
                            'Indicator': indicator,
                            'Total Trades': len(result['trades']),
                            'Buy Trades': len(buy_trades),
                            'Sell Trades': len(sell_trades),
                            'Winning Trades': winning_trades,
                            'Losing Trades': losing_trades,
                            'Win Rate': f"{result['win_rate']:.2f}%",
                            'Avg Holding (days)': f"{avg_holding:.1f}",
                            'Avg Profit/Trade': f"{avg_profit:,.2f}",
                            'Total Profit': f"{result['total_profit']:,.2f}",
                            'Return %': f"{result['profit_percentage']:.2f}%"
                        })
                    
                    # Create statistics table
                    stats_table = dash_table.DataTable(
                        data=stats_data,
                        columns=[{'name': col, 'id': col} for col in [
                            'Indicator', 'Total Trades', 'Buy Trades', 'Sell Trades',
                            'Winning Trades', 'Losing Trades', 'Win Rate', 
                            'Avg Holding (days)', 'Avg Profit/Trade', 'Total Profit', 'Return %'
                        ]],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px'},
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{Return %} contains "-"', 'column_id': 'Return %'},
                                'color': 'red'
                            },
                            {
                                'if': {'filter_query': '{Return %} contains "%"', 'column_id': 'Return %'},
                                'color': 'green'
                            },
                            {
                                'if': {'filter_query': '{Total Profit} < 0', 'column_id': 'Total Profit'},
                                'color': 'red'
                            },
                            {
                                'if': {'filter_query': '{Total Profit} >= 0', 'column_id': 'Total Profit'},
                                'color': 'green'
                            }
                        ]
                    )
                    
                    # Add summary
                    best_indicator = max(results.items(), key=lambda x: x[1]['profit_percentage'])[0] if results else "None"
                    best_profit = max([r['profit_percentage'] for r in results.values()]) if results else 0
                    
                    summary = html.Div([
                        html.P([
                            f"Best performing indicator: ", 
                            html.Strong(f"{best_indicator}", className="text-blue-600"),
                            f" with ", 
                            html.Strong(f"{best_profit:.2f}% return", className=f"{'text-green-600' if best_profit > 0 else 'text-red-600'}")
                        ]),
                        html.P(f"Analysis based on data from {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"),
                        html.P(f"Initial capital: {capital:,.2f}")
                    ], className="mt-4")
                    
                    outputs.append(html.Div([stats_table, summary]))
                except Exception as e:
                    outputs.append(html.Div([
                        html.P(f"Error creating trade statistics for {ticker}: {str(e)}", className="text-red-500"),
                        html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
                    ]))
            else:
                outputs.append(dash.no_update)
        
        return outputs








    @app.callback(
        Output("ticker-price-chart", "children"),
        [Input("raw-data-ticker-selector", "value")],
        [State("stored-raw-data", "children")]
    )
    def update_ticker_price_chart(selected_ticker, raw_data_json):
        if not selected_ticker or not raw_data_json:
            return html.Div("Select a ticker to display chart", className="text-gray-500 text-center p-4")
        
        try:
            # Parse stored JSON data
            raw_data = json.loads(raw_data_json)
            
            if selected_ticker not in raw_data:
                return html.Div(f"No data found for ticker {selected_ticker}", className="text-red-500 text-center p-4")
                
            # Get ticker data from stored results
            ticker_data = pd.DataFrame(raw_data[selected_ticker])
            
            # Create candlestick chart with actual data
            fig = go.Figure()
            fig.add_trace(go.Candlestick(
                x=ticker_data['Datetime'],
                open=ticker_data['Open'],
                high=ticker_data['High'],
                low=ticker_data['Low'],
                close=ticker_data['Close'],
                name=selected_ticker
            ))
            
            # Add volume as bar chart at the bottom
            fig.add_trace(go.Bar(
                x=ticker_data['Datetime'],
                y=ticker_data['Volume'],
                name='Volume',
                marker_color='rgba(0,0,0,0.2)',
                yaxis="y2"
            ))
            
            # Add signals if available
            if 'Combined_Signal' in ticker_data.columns:
                buy_signals = ticker_data[ticker_data['Combined_Signal'] == 'Buy']
                sell_signals = ticker_data[ticker_data['Combined_Signal'] == 'Sell']
                
                fig.add_trace(go.Scatter(
                    x=buy_signals['Datetime'],
                    y=buy_signals['Low'] * 0.99,  # Slightly below price for visibility
                    mode='markers',
                    marker=dict(symbol='triangle-up', size=10, color='green'),
                    name='Buy Signal'
                ))
                
                fig.add_trace(go.Scatter(
                    x=sell_signals['Datetime'],
                    y=sell_signals['High'] * 1.01,  # Slightly above price for visibility
                    mode='markers',
                    marker=dict(symbol='triangle-down', size=10, color='red'),
                    name='Sell Signal'
                ))
            
            # Layout with secondary y-axis for volume
            fig.update_layout(
                title=f"{selected_ticker} Price Chart with Signals",
                xaxis_title="Date",
                yaxis_title="Price",
                height=600,
                yaxis2=dict(
                    title="Volume",
                    overlaying="y",
                    side="right",
                    showgrid=False
                ),
                xaxis_rangeslider_visible=False,
                template="plotly_white"
            )
            
            return dcc.Graph(figure=fig)
            
        except Exception as e:
            return html.Div([
                html.P(f"Error creating chart: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])
            
    @app.callback(
        Output("ticker-signal-chart", "children", allow_duplicate = True),
        [Input("raw-data-ticker-selector", "value")],
        [State("raw-data-explorer", "data")],
        prevent_initial_call=True
    )
    def update_ticker_signal_chart(selected_ticker, raw_data):
        if not selected_ticker or not raw_data or selected_ticker not in raw_data:
            return html.Div("Select a ticker to display chart", className="text-gray-500 text-center p-4")
        
        try:
            # Get ticker data
            ticker_data = pd.DataFrame(raw_data[selected_ticker])
            
            if 'Combined_Signal' not in ticker_data.columns:
                return html.Div("No signal data available for this ticker", 
                            className="text-gray-500 text-center p-4")
            
            # Count signals
            signal_counts = ticker_data['Combined_Signal'].value_counts().to_dict()
            signals = ['Buy', 'Sell', 'Hold']
            counts = [signal_counts.get(signal, 0) for signal in signals]
            
            # Create chart
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=signals,
                y=counts,
                name='Signal Distribution',
                marker_color=['green', 'red', 'gray']
            ))
            fig.update_layout(
                title=f"{selected_ticker} Signal Distribution",
                xaxis_title="Signal Type",
                yaxis_title="Count",
                height=400
            )
            
            return dcc.Graph(figure=fig)
            
        except Exception as e:
            return html.Div([
                html.P(f"Error creating chart: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])
            
    @app.callback(
        Output("ticker-indicators-chart", "children"),
        [Input("raw-data-ticker-selector", "value")],
        [State("raw-data-explorer", "data")]
    )
    def update_ticker_indicators_chart(selected_ticker, raw_data):
        if not selected_ticker or not raw_data or selected_ticker not in raw_data:
            return html.Div("Select a ticker to display chart", className="text-gray-500 text-center p-4")
        
        try:
            # Get ticker data
            ticker_data = pd.DataFrame(raw_data[selected_ticker])
            
            # Convert the datetime column back to datetime type if it's a string
            if 'Datetime' in ticker_data.columns and isinstance(ticker_data['Datetime'].iloc[0], str):
                ticker_data['Datetime'] = pd.to_datetime(ticker_data['Datetime'])
            
            # Create a figure with subplots
            fig = make_subplots(rows=2, cols=1, shared_xaxes=True,
                            vertical_spacing=0.1, subplot_titles=('Price Chart', 'Technical Indicators'),
                            row_heights=[0.7, 0.3])
            
            # Add price trace to top subplot
            fig.add_trace(
                go.Candlestick(
                    x=ticker_data['Datetime'],
                    open=ticker_data['Open'],
                    high=ticker_data['High'],
                    low=ticker_data['Low'],
                    close=ticker_data['Close'],
                    name='Price'
                ),
                row=1, col=1
            )
            
            # Add technical indicators to bottom subplot
            indicators_added = False
            
            # Check for different technical indicators
            if 'RSI' in ticker_data.columns:
                fig.add_trace(
                    go.Scatter(x=ticker_data['Datetime'], y=ticker_data['RSI'], name='RSI', line=dict(color='purple')),
                    row=2, col=1
                )
                
                # Add RSI reference lines
                fig.add_shape(
                    type="line", line=dict(dash='dash', color='red'),
                    x0=ticker_data['Datetime'].iloc[0], y0=70, 
                    x1=ticker_data['Datetime'].iloc[-1], y1=70,
                    row=2, col=1
                )
                fig.add_shape(
                    type="line", line=dict(dash='dash', color='green'),
                    x0=ticker_data['Datetime'].iloc[0], y0=30, 
                    x1=ticker_data['Datetime'].iloc[-1], y1=30,
                    row=2, col=1
                )
                indicators_added = True
            
            # Add MACD if available
            if 'MACD' in ticker_data.columns and 'Signal_Line' in ticker_data.columns:
                fig.add_trace(
                    go.Scatter(x=ticker_data['Datetime'], y=ticker_data['MACD'], name='MACD', line=dict(color='blue')),
                    row=2, col=1
                )
                fig.add_trace(
                    go.Scatter(x=ticker_data['Datetime'], y=ticker_data['Signal_Line'], name='Signal Line', line=dict(color='orange')),
                    row=2, col=1
                )
                indicators_added = True
            
            if not indicators_added:
                # Add a message if no indicators available
                fig.add_annotation(
                    x=0.5, y=0.5,
                    xref="paper", yref="paper",
                    text="No technical indicators available for this ticker",
                    showarrow=False,
                    font=dict(size=14),
                    row=2, col=1
                )
            
            # Update layout for better appearance
            fig.update_layout(
                title=f"{selected_ticker} Price and Technical Analysis",
                height=700,
                showlegend=True,
                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                margin=dict(l=50, r=50, t=80, b=50)
            )
            
            # Update Y-axis titles
            fig.update_yaxes(title_text="Price", row=1, col=1)
            fig.update_yaxes(title_text="Indicator Value", row=2, col=1)
            
            return dcc.Graph(figure=fig)
            
        except Exception as e:
            return html.Div([
                html.P(f"Error creating chart: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ])

    # BACKTESTING ANALYSIS CALLBACKS
    @app.callback(
        [Output("ticker-backtesting-metrics", "children"),
         Output("ticker-profit-simulation", "children")],
        [Input("raw-data-ticker-selector", "value")],
        [State("raw-data-explorer", "data")]
    )
    def update_backtesting_analysis(selected_ticker, raw_data):
        """Update the backtesting analysis for selected ticker"""
        if not selected_ticker or not raw_data or selected_ticker not in raw_data:
            return html.Div("Select a ticker to view backtesting metrics", 
                          className="text-gray-500 text-center p-4"), html.Div()
        
        try:
            # Get data for the selected ticker
            ticker_data = pd.DataFrame(raw_data[selected_ticker])
            
            # Check if we have signal data
            if 'Combined_Signal' not in ticker_data.columns:
                return html.Div("No signal data available for backtesting analysis",
                              className="text-gray-500 text-center p-4"), html.Div()
            
            # Calculate signal metrics
            buy_signals = ticker_data[ticker_data['Combined_Signal'] == 'Buy']
            sell_signals = ticker_data[ticker_data['Combined_Signal'] == 'Sell']
            total_signals = len(buy_signals) + len(sell_signals)
            
            # Calculate how many buy signals were followed by profitable sell signals
            profitable_trades = 0
            total_trades = 0
            
            if not buy_signals.empty and not sell_signals.empty:
                # Sort by datetime to ensure proper order
                buy_signals = buy_signals.sort_values('Datetime').reset_index(drop=True)
                sell_signals = sell_signals.sort_values('Datetime').reset_index(drop=True)
                
                # Track each potential buy signal
                for _, buy_row in buy_signals.iterrows():
                    buy_time = buy_row['Datetime']
                    buy_price = buy_row['Close']
                    
                    # Find the next sell signal after this buy
                    next_sell = sell_signals[sell_signals['Datetime'] > buy_time]
                    if not next_sell.empty:
                        sell_price = next_sell.iloc[0]['Close']
                        total_trades += 1
                        if sell_price > buy_price:
                            profitable_trades += 1
            
            win_rate = (profitable_trades / total_trades * 100) if total_trades > 0 else 0
            
            # Create metrics cards
            metrics_cards = html.Div([
                html.Div([
                    html.Div([
                        html.Div([
                            html.Span("Total Signals", className="block text-sm text-gray-500"),
                            html.Span(f"{total_signals}", className="block text-xl font-bold text-blue-600")
                        ], className="p-4 border rounded bg-white shadow-sm")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Buy Signals", className="block text-sm text-gray-500"),
                            html.Span(f"{len(buy_signals)}", className="block text-xl font-bold text-green-600")
                        ], className="p-4 border rounded bg-white shadow-sm")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Sell Signals", className="block text-sm text-gray-500"),
                            html.Span(f"{len(sell_signals)}", className="block text-xl font-bold text-red-600")
                        ], className="p-4 border rounded bg-white shadow-sm")
                    ], className="w-1/4 px-2"),
                    html.Div([
                        html.Div([
                            html.Span("Win Rate", className="block text-sm text-gray-500"),
                            html.Span(f"{win_rate:.2f}%", className="block text-xl font-bold text-blue-600")
                        ], className="p-4 border rounded bg-white shadow-sm")
                    ], className="w-1/4 px-2"),
                ], className="flex -mx-2 mb-6")
            ])
            
            # Create profit simulation
            initial_capital = 10000000  # 10 million
            cash = initial_capital
            position = 0
            trades = []
            
            # Sort by datetime
            ticker_data = ticker_data.sort_values('Datetime').reset_index(drop=True)
            
            # Run simulation
            for idx, row in ticker_data.iterrows():
                signal = row['Combined_Signal'] if 'Combined_Signal' in row else None
                
                if signal == 'Buy' and cash > 0:
                    # Buy as many shares as possible
                    shares_to_buy = int(cash / row['Close'])
                    if shares_to_buy > 0:
                        cost = shares_to_buy * row['Close']
                        cash -= cost
                        position += shares_to_buy
                        
                        trades.append({
                            'type': 'Buy',
                            'date': row['Datetime'],
                            'price': row['Close'],
                            'shares': shares_to_buy,
                            'value': cost,
                            'capital': cash + (position * row['Close'])
                        })
                        
                elif signal == 'Sell' and position > 0:
                    # Sell all shares
                    value = position * row['Close']
                    cash += value
                    
                    trades.append({
                        'type': 'Sell',
                        'date': row['Datetime'],
                        'price': row['Close'],
                        'shares': position,
                        'value': value,
                        'capital': cash
                    })
                    
                    position = 0
            
            # Calculate final capital including any remaining position
            final_capital = cash
            if position > 0:
                final_capital += position * ticker_data['Close'].iloc[-1]
            
            profit = final_capital - initial_capital
            profit_percentage = (profit / initial_capital) * 100
            
            # Create simulation results
            simulation_results = html.Div([
                html.H4("Profit Simulation", className="text-lg font-semibold mb-3"),
                
                # Summary metrics
                html.Div([
                    html.Div([
                        html.Span("Initial Capital: ", className="font-semibold"),
                        html.Span(f"{initial_capital:,.2f}", className="ml-1")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Final Capital: ", className="font-semibold"),
                        html.Span(f"{final_capital:,.2f}", 
                                 className=f"ml-1 {'text-green-600' if profit > 0 else 'text-red-600'}")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Total Profit: ", className="font-semibold"),
                        html.Span(f"{profit:,.2f} ({profit_percentage:.2f}%)",
                                 className=f"ml-1 {'text-green-600' if profit > 0 else 'text-red-600'}")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Total Trades: ", className="font-semibold"),
                        html.Span(f"{len(trades)}", className="ml-1")
                    ]),
                ], className="p-4 bg-gray-50 rounded mb-4"),
                
                # Capital growth chart
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Scatter(
                                x=[i for i in range(len(trades))],
                                y=[trade['capital'] for trade in trades],
                                mode='lines+markers',
                                name='Capital',
                                line=dict(color='blue', width=2),
                                marker=dict(
                                    size=10,
                                    color=['green' if trade['type'] == 'Sell' else 'red' for trade in trades],
                                    symbol=['triangle-up' if trade['type'] == 'Buy' else 'triangle-down' for trade in trades]
                                )
                            ),
                            go.Scatter(
                                x=[0, len(trades)-1],
                                y=[initial_capital, initial_capital],
                                mode='lines',
                                name='Initial Capital',
                                line=dict(color='gray', width=1, dash='dash')
                            )
                        ],
                        layout=go.Layout(
                            title=f"Capital Growth for {selected_ticker}",
                            xaxis_title="Trade Number",
                            yaxis_title="Capital",
                            height=400,
                            margin=dict(l=50, r=50, t=80, b=50)
                        )
                    )
                ),
                
                # Trades table
                html.Div([
                    html.H4("Trade History", className="text-lg font-semibold mt-4 mb-3"),
                    dash_table.DataTable(
                        data=[{
                            'date': str(t['date']),
                            'type': t['type'],
                            'price': f"{t['price']:.2f}",
                            'shares': t['shares'],
                            'value': f"{t['value']:.2f}",
                            'capital': f"{t['capital']:.2f}"
                        } for t in trades],
                        columns=[
                            {'name': 'Date', 'id': 'date'},
                            {'name': 'Type', 'id': 'type'},
                            {'name': 'Price', 'id': 'price'},
                            {'name': 'Shares', 'id': 'shares'},
                            {'name': 'Value', 'id': 'value'},
                            {'name': 'Capital', 'id': 'capital'}
                        ],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px'},
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{type} = "Buy"'},
                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                'color': 'green'
                            },
                            {
                                'if': {'filter_query': '{type} = "Sell"'},
                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                'color': 'red'
                            }
                        ],
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        page_size=10
                    )
                ])
            ])
            
            return metrics_cards, simulation_results
            
        except Exception as e:
            return html.Div([
                html.P(f"Error in backtesting analysis: {str(e)}", className="text-red-500"),
                html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
            ]), html.Div()

    # Download callback
    # @app.callback(
    #     Output("download-bulk-data", "data"),
    #     [Input("download-bulk-results", "n_clicks")],
    #     [State("bulk-ticker-dropdown", "value"),
    #     State("analysis-leaderboard", "children"),
    #     State("profit-leaderboard", "children")]
    # )
    # def download_results(n_clicks, tickers, analysis_leaderboard, profit_leaderboard):
    #     if not n_clicks:
    #         raise dash.exceptions.PreventUpdate
        
    #     if not tickers:
    #         return dash.no_update
        
    #     try:
    #         # Create Excel file with results
    #         output = io.BytesIO()
    #         with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
    #             # Create sheets for each ticker
    #             for ticker in tickers:
    #                 # Create a placeholder dataframe for each ticker
    #                 ticker_df = pd.DataFrame({
    #                     'Ticker': [ticker] * 5,
    #                     'Indicator': ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal', 'Combined'],
    #                     'Profit %': [3.5, 2.8, 4.2, 1.9, 5.1],
    #                     'Trades': [10, 8, 12, 15, 11]
    #                 })
    #                 ticker_df.to_excel(writer, sheet_name=ticker[:31], index=False)  # Excel sheet names limited to 31 chars
                
    #         # Return the Excel file
    #         output.seek(0)
    #         return dcc.send_bytes(output.getvalue(), f"bulk_analysis_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx")
            
    #     except Exception as e:
    #         print(f"Error creating Excel file: {str(e)}")
    #         traceback.print_exc()
    #         return dash.no_update
        
    


    # @app.callback(
    #     Output("tabbed-backtesting-results", "children"),
    #     [Input("run-backtesting", "n_clicks")],
    #     [State("backtesting-title-dropdown", "value"),
    #      State("capital-input", "value"),
    #      State("analysis-dropdown", "value"),
    #      State("bulk-start-year-dropdown", "value"),
    #      State("bulk-start-month-dropdown", "value"),
    #      State("bulk-start-day-dropdown", "value"),
    #      State("bulk-end-year-dropdown", "value"),
    #      State("bulk-end-month-dropdown", "value"),
    #      State("bulk-end-day-dropdown", "value")]
    # )
    # def run_backtesting_tabbed(n_clicks, title, capital, selected_analysis, start_year, start_month, start_day, end_year, end_month, end_day):
    #     if not n_clicks:
    #         raise dash.exceptions.PreventUpdate
        
    #     start_time = time.time()
        
    #     if not title or not capital:
    #         return html.Div("Please provide all inputs.", className="text-red-500")

    #     # Validate and format the date range
    #     try:
    #         start_date = pd.Timestamp(year=start_year, month=start_month, day=start_day)
    #         end_date = pd.Timestamp(year=end_year, month=end_month, day=end_day)
    #     except Exception as e:
    #         return html.Div(f"Invalid date range: {str(e)}", className="text-red-500")

    #     # Fetch data and calculate standard backtesting results
    #     try:
    #         df = fetch_ticker_data(title, start_date, end_date)
            
    #         if df.empty:
    #             return html.Div(f"No data found for the selected ticker: {title}.", className="text-gray-500")

    #         # Apply technical indicators based on selected analysis
    #         indicators_to_apply = []
    #         if selected_analysis == 'Technical Analysis':
    #             indicators_to_apply = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
    #         elif selected_analysis == 'Moving Average':
    #             indicators_to_apply = ['MA_Signal']
    #         elif selected_analysis == 'RSI Analysis':
    #             indicators_to_apply = ['RSI_Signal']
    #         elif selected_analysis == 'MACD Analysis':
    #             indicators_to_apply = ['MACD_Signal']
    #         else:
    #             # Default to all indicators
    #             indicators_to_apply = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
            
    #         # Apply technical indicators
    #         df_with_signals = apply_technical_indicators(df, indicators_to_apply)
            
    #         # RUN THREE DIFFERENT BACKTESTING APPROACHES:
            
    #         # 1. STANDARD BACKTESTING RESULTS
    #         standard_results = generate_standard_backtesting(df_with_signals, title, float(capital), indicators_to_apply)
            
    #         # 2. BACKTESTING ANALYSIS RESULTS 
    #         analysis_results = generate_backtesting_analysis(df_with_signals, title, float(capital), indicators_to_apply)
            
    #         # 3. BACKTESTING PROFIT RESULTS
    #         profit_results = generate_backtesting_profit(df_with_signals, title, float(capital), start_date, end_date)
            
    #         # Calculate execution time
    #         end_time = time.time()
    #         execution_time = end_time - start_time
            
    #         # Create the three tabs for different result types
    #         return html.Div([
    #             html.H2(f"Backtesting Results for {title}", className="text-2xl font-bold mb-4"),
    #             html.Div(f"Time period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", className="mb-2 text-gray-600"),
    #             html.Div(f"Execution time: {execution_time:.2f} seconds", className="mb-4 text-gray-600"),
                
    #             # Create tabs for the three different result types
    #             dcc.Tabs([
    #                 # Tab 1: Standard Backtesting Results
    #                 dcc.Tab(label="Standard Backtesting", children=[
    #                     html.Div(standard_results, className="mt-4")
    #                 ]),
                    
    #                 # Tab 2: Backtesting Analysis Results
    #                 dcc.Tab(label="Backtesting Analysis", children=[
    #                     html.Div(analysis_results, className="mt-4")
    #                 ]),
                    
    #                 # Tab 3: Backtesting Profit Results
    #                 dcc.Tab(label="Backtesting Profit", children=[
    #                     html.Div(profit_results, className="mt-4")
    #                 ])
    #             ], className="mb-4")
    #         ])
            
    #     except Exception as e:
    #         return html.Div([
    #             html.H3("Error", className="text-xl font-bold text-red-600 mb-2"),
    #             html.P(f"An error occurred during backtesting: {str(e)}", className="text-red-500"),
    #             html.Pre(traceback.format_exc(), className="bg-gray-100 p-4 rounded text-sm mt-2")
    #         ])

    # Helper functions to generate the different types of backtesting results
    def generate_standard_backtesting(df, ticker, capital, indicators):
        """Generate standard backtesting results"""
        # Standard backtesting logic
        results = {}
        
        # Run backtest for each indicator
        for indicator in indicators:
            if indicator in df.columns:
                result = run_backtest_for_indicator(df, indicator, capital)
                if result:
                    results[indicator] = result
        
        # Process Combined_Signal if available
        if 'Combined_Signal' in df.columns:
            result = run_backtest_for_indicator(df, 'Combined_Signal', capital)
            if result:
                results['Combined_Signal'] = result
                
        # Create components for the standard backtesting results
        if not results:
            return html.Div("No valid backtesting results generated.", className="text-red-500")
        
        components = [
            # Leaderboard/Summary section
            html.Div([
                html.H3("Performance Summary", className="text-xl font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'Indicator': indicator,
                        'Profit %': f"{result['profit_percentage']:.2f}%",
                        'Total Profit': f"{result['total_profit']:,.2f}",
                        'Final Capital': f"{result['final_capital']:,.2f}",
                        'Trades': result['num_trades'],
                        'Win Rate': f"{result['win_rate']:.2f}%"
                    } for indicator, result in results.items()],
                    columns=[
                        {'name': 'Indicator', 'id': 'Indicator'},
                        {'name': 'Profit %', 'id': 'Profit %'},
                        {'name': 'Total Profit', 'id': 'Total Profit'},
                        {'name': 'Final Capital', 'id': 'Final Capital'},
                        {'name': 'Trades', 'id': 'Trades'},
                        {'name': 'Win Rate', 'id': 'Win Rate'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Profit %} contains "-"'},
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Profit %} contains "%"', 'column_id': 'Profit %'},
                            'color': 'green'
                        }
                    ],
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    sort_action='native'
                )
            ], className="mb-6"),
            
            # Visualization
            html.Div([
                html.H3("Profit Comparison", className="text-xl font-semibold mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Bar(
                                x=list(results.keys()),
                                y=[result['profit_percentage'] for result in results.values()],
                                marker_color=['green' if result['profit_percentage'] > 0 else 'red' 
                                             for result in results.values()],
                                text=[f"{result['profit_percentage']:.2f}%" for result in results.values()],
                                textposition='auto'
                            )
                        ],
                        layout=go.Layout(
                            title=f"Profit Percentage by Indicator for {ticker}",
                            xaxis_title="Indicator",
                            yaxis_title="Profit %",
                            height=400,
                            margin=dict(l=50, r=50, t=80, b=50)
                        )
                    )
                )
            ], className="mb-6"),
            
            # Trade details
            html.Div([
                html.H3("Trade Details", className="text-xl font-semibold mb-3"),
                dcc.Tabs([
                    dcc.Tab(
                        label=indicator,
                        children=[
                            html.Div([
                                html.H4(f"{indicator} Trades", className="text-lg font-semibold mt-3 mb-3"),
                                dash_table.DataTable(
                                    data=[{
                                        'Date': t['date'].strftime('%Y-%m-%d') if hasattr(t['date'], 'strftime') else str(t['date']),
                                        'Type': t['type'],
                                        'Price': f"{t['price']:.2f}",
                                        'Shares': t['shares'],
                                        'Value': f"{t['value']:.2f}",
                                        'Cash': f"{t['remaining_cash']:.2f}"
                                    } for t in result['trades']],
                                    columns=[
                                        {'name': 'Date', 'id': 'Date'},
                                        {'name': 'Type', 'id': 'Type'},
                                        {'name': 'Price', 'id': 'Price'},
                                        {'name': 'Shares', 'id': 'Shares'},
                                        {'name': 'Value', 'id': 'Value'},
                                        {'name': 'Cash', 'id': 'Cash'}
                                    ],
                                    style_table={'overflowX': 'auto'},
                                    style_cell={'textAlign': 'left', 'padding': '10px'},
                                    style_data_conditional=[
                                        {
                                            'if': {'filter_query': '{Type} = "Buy"'},
                                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                            'color': 'green'
                                        },
                                        {
                                            'if': {'filter_query': '{Type} = "Sell"'},
                                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                            'color': 'red'
                                        }
                                    ],
                                    style_header={
                                        'backgroundColor': 'rgb(240, 240, 240)',
                                        'fontWeight': 'bold'
                                    },
                                    page_size=10
                                ),
                                
                                # Capital growth chart
                                html.Div([
                                    html.H4("Capital Growth", className="text-lg font-semibold mt-4 mb-2"),
                                    dcc.Graph(
                                        figure=go.Figure(
                                            data=[
                                                go.Scatter(
                                                    x=[i for i in range(len(result['trades']))],
                                                    y=[t['remaining_cash'] for t in result['trades']],
                                                    mode='lines+markers',
                                                    name='Capital',
                                                    line=dict(color='blue', width=2),
                                                    marker=dict(
                                                        size=8,
                                                        color=['green' if t['type'] == 'Sell' else 'red' for t in result['trades']],
                                                        symbol=['triangle-up' if t['type'] == 'Buy' else 'triangle-down' for t in result['trades']]
                                                    )
                                                ),
                                                go.Scatter(
                                                    x=[0, len(result['trades'])-1],
                                                    y=[capital, capital],
                                                    mode='lines',
                                                    name='Initial Capital',
                                                    line=dict(color='gray', width=1, dash='dash')
                                                )
                                            ],
                                            layout=go.Layout(
                                                title=f"Capital Growth for {ticker} with {indicator}",
                                                xaxis_title="Trade Number",
                                                yaxis_title="Capital",
                                                height=400,
                                                margin=dict(l=50, r=50, t=80, b=50)
                                            )
                                        )
                                    )
                                ], className="mt-4")
                            ])
                        ]
                    ) for indicator, result in results.items()
                ])
            ])
        ]
        
        return html.Div(components)
    
    def generate_backtesting_analysis(df, ticker, capital, indicators):
        """Generate backtesting analysis results comparing different indicators"""
        # Generate analysis metrics
        analysis_results = []
        
        for indicator in indicators:
            if indicator not in df.columns:
                continue
                
            # Run standard backtest
            result = run_backtest_for_indicator(df, indicator, capital)
            if not result:
                continue
                
            # Calculate additional metrics
            buy_signals = df[df[indicator] == 'Buy']
            sell_signals = df[df[indicator] == 'Sell']
            
            avg_price_change = 0
            avg_volume_change = 0
            correct_signals = 0
            
            # Match buy signals with the next price point
            for idx, buy_row in buy_signals.iterrows():
                future_prices = df.loc[idx+1:idx+5, 'Close'] if idx+5 < len(df) else df.loc[idx+1:, 'Close']
                if not future_prices.empty:
                    next_price = future_prices.iloc[-1]
                    price_change = (next_price - buy_row['Close']) / buy_row['Close'] * 100
                    avg_price_change += price_change
                    
                    # Check if signal was correct (price went up after buy)
                    if price_change > 0:
                        correct_signals += 1
            
            # Average price change after buy signals
            avg_price_change = avg_price_change / len(buy_signals) if len(buy_signals) > 0 else 0
            
            # Calculate signal accuracy
            total_signals = len(buy_signals) + len(sell_signals)
            signal_accuracy = correct_signals / total_signals * 100 if total_signals > 0 else 0
            
            # Add to analysis results
            analysis_results.append({
                'Indicator': indicator,
                'Profit %': result['profit_percentage'],
                'Trades': result['num_trades'],
                'Win Rate': result['win_rate'],
                'Avg Price Change %': avg_price_change,
                'Signal Count': total_signals,
                'Signal Accuracy %': signal_accuracy
            })
            
        if not analysis_results:
            return html.Div("No valid analysis results could be generated.", className="text-red-500")
        
        # Sort by profit percentage
        analysis_results.sort(key=lambda x: x['Profit %'], reverse=True)
        
        # Add Combined Signal if available
        if 'Combined_Signal' in df.columns:
            result = run_backtest_for_indicator(df, 'Combined_Signal', capital)
            if result:
                # Calculate same metrics for combined signal
                buy_signals = df[df['Combined_Signal'] == 'Buy']
                sell_signals = df[df['Combined_Signal'] == 'Sell']
                
                avg_price_change = 0
                correct_signals = 0
                
                for idx, buy_row in buy_signals.iterrows():
                    future_prices = df.loc[idx+1:idx+5, 'Close'] if idx+5 < len(df) else df.loc[idx+1:, 'Close']
                    if not future_prices.empty:
                        next_price = future_prices.iloc[-1]
                        price_change = (next_price - buy_row['Close']) / buy_row['Close'] * 100
                        avg_price_change += price_change
                        
                        if price_change > 0:
                            correct_signals += 1
                
                avg_price_change = avg_price_change / len(buy_signals) if len(buy_signals) > 0 else 0
                
                total_signals = len(buy_signals) + len(sell_signals)
                signal_accuracy = correct_signals / total_signals * 100 if total_signals > 0 else 0
                
                analysis_results.append({
                    'Indicator': 'Combined_Signal',
                    'Profit %': result['profit_percentage'],
                    'Trades': result['num_trades'],
                    'Win Rate': result['win_rate'],
                    'Avg Price Change %': avg_price_change,
                    'Signal Count': total_signals,
                    'Signal Accuracy %': signal_accuracy
                })
                
                # Resort by profit percentage
                analysis_results.sort(key=lambda x: x['Profit %'], reverse=True)
        
        # Create components for the analysis results
        components = [
            # Best performing indicator
            html.Div([
                html.H3("Best Performing Strategy", className="text-xl font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Span("Indicator: ", className="font-semibold"),
                        html.Span(analysis_results[0]['Indicator'], className="ml-1 text-blue-600")
                    ], className="mb-1"),
                    html.Div([
                        html.Span("Profit %: ", className="font-semibold"),
                        html.Span(f"{analysis_results[0]['Profit %']:.2f}%", 
                                className=f"ml-1 {'text-green-600' if analysis_results[0]['Profit %'] >= 0 else 'text-red-600'}")
                    ], className="mb-1"),
                    html.Div([
                        html.Span("Win Rate: ", className="font-semibold"),
                        html.Span(f"{analysis_results[0]['Win Rate']:.2f}%", className="ml-1 text-blue-600")
                    ], className="mb-1"),
                    html.Div([
                        html.Span("Signal Accuracy: ", className="font-semibold"),
                        html.Span(f"{analysis_results[0]['Signal Accuracy %']:.2f}%", className="ml-1 text-blue-600")
                    ], className="mb-1"),
                ], className="p-4 bg-green-50 border border-green-200 rounded")
            ], className="mb-6"),
            
            # Comparison table
            html.Div([
                html.H3("Strategy Comparison", className="text-xl font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'Indicator': result['Indicator'],
                        'Profit %': f"{result['Profit %']:.2f}%",
                        'Trades': result['Trades'],
                        'Win Rate': f"{result['Win Rate']:.2f}%",
                        'Avg Price Change': f"{result['Avg Price Change %']:.2f}%",
                        'Signal Count': result['Signal Count'],
                        'Signal Accuracy': f"{result['Signal Accuracy %']:.2f}%"
                    } for result in analysis_results],
                    columns=[
                        {'name': 'Indicator', 'id': 'Indicator'},
                        {'name': 'Profit %', 'id': 'Profit %'},
                        {'name': 'Trades', 'id': 'Trades'},
                        {'name': 'Win Rate', 'id': 'Win Rate'},
                        {'name': 'Avg Price Change', 'id': 'Avg Price Change'},
                        {'name': 'Signal Count', 'id': 'Signal Count'},
                        {'name': 'Signal Accuracy', 'id': 'Signal Accuracy'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'row_index': 0},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'fontWeight': 'bold'
                        }
                    ],
                    sort_action='native'
                )
            ], className="mb-6"),
            
            # Visual comparison
            html.Div([
                html.H3("Performance Visualization", className="text-xl font-semibold mb-3"),
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Bar(
                                x=[result['Indicator'] for result in analysis_results],
                                y=[result['Profit %'] for result in analysis_results],
                                name='Profit %',
                                marker_color='green',
                                opacity=0.7
                            ),
                            go.Bar(
                                x=[result['Indicator'] for result in analysis_results],
                                y=[result['Signal Accuracy %'] for result in analysis_results],
                                name='Signal Accuracy %',
                                marker_color='blue',
                                opacity=0.7
                            )
                        ],
                        layout=go.Layout(
                            title='Profit % vs Signal Accuracy %',
                            barmode='group',
                            height=500,
                            margin=dict(l=50, r=50, t=80, b=100),
                            xaxis_tickangle=-45
                        )
                    )
                ),
                
                # Add correlation scatter plot
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Scatter(
                                x=[result['Signal Count'] for result in analysis_results],
                                y=[result['Profit %'] for result in analysis_results],
                                mode='markers+text',
                                marker=dict(
                                    size=12,
                                    color=[result['Win Rate'] for result in analysis_results],
                                    colorscale='Viridis',
                                    showscale=True,
                                    colorbar=dict(title='Win Rate %')
                                ),
                                text=[result['Indicator'] for result in analysis_results],
                                textposition='top center'
                            )
                        ],
                        layout=go.Layout(
                            title='Signal Count vs Profit %',
                            xaxis_title='Signal Count',
                            yaxis_title='Profit %',
                            height=500,
                            margin=dict(l=50, r=50, t=80, b=50)
                        )
                    )
                )
            ])
        ]
        
        return html.Div(components)
    
    def generate_backtesting_profit(df, ticker, capital, start_date, end_date):
        """Generate backtesting profit results with linear scenarios"""
        # Create analysis dataframe from signals
        analysis_df = pd.DataFrame()
        
        # Check if we have any signals
        has_signals = False
        for col in df.columns:
            if col.endswith('_Signal') or col == 'Combined_Signal':
                has_signals = True
                for idx, row in df.iterrows():
                    if row[col] in ['Buy', 'Sell']:
                        analysis_df = analysis_df.append({
                            'Datetime': row['Datetime'],
                            'Price': row['Close'],
                            'Signal': row[col],
                            'Volume': row['Volume'],
                            'Analysis_info': col,
                            'Title': ticker
                        }, ignore_index=True)
        
        if not has_signals or analysis_df.empty:
            return html.Div("No signals found for backtesting profit analysis.", className="text-red-500")
        
        # Sort data by date
        analysis_df = analysis_df.sort_values(by='Datetime').reset_index(drop=True)

        # Separate Buy and Sell signals
        buy_signals = analysis_df[analysis_df['Signal'] == 'Buy'].reset_index(drop=True)
        sell_signals = analysis_df[analysis_df['Signal'] == 'Sell'].reset_index(drop=True)

        # Initialize variables for linear backtesting
        all_scenarios = []
        scenario_id = 1
        best_scenario = None
        max_final_capital = float('-inf')

        # Generate linear scenarios (buy then sell pairs)
        for buy_idx in range(len(buy_signals)):
            for sell_idx in range(len(sell_signals)):
                # Skip if sell doesn't come after buy
                buy_date = buy_signals.iloc[buy_idx]['Datetime']
                sell_date = sell_signals.iloc[sell_idx]['Datetime']
                if sell_date <= buy_date:
                    continue
                
                # Calculate single trade
                buy_price = buy_signals.iloc[buy_idx]['Price']
                sell_price = sell_signals.iloc[sell_idx]['Price']
                shares = int(capital // buy_price)
                
                if shares == 0:  # Not enough capital
                    continue
                
                cost = shares * buy_price
                proceeds = shares * sell_price
                profit = proceeds - cost
                pct_profit = (sell_price - buy_price) / buy_price * 100
                
                # Create scenario
                scenario = {
                    'Scenario ID': scenario_id,
                    'Buy Date': buy_date,
                    'Buy Price': buy_price,
                    'Sell Date': sell_date,
                    'Sell Price': sell_price,
                    'Shares': shares,
                    'Investment': cost,
                    'Proceeds': proceeds,
                    'Profit': profit,
                    'Percent Profit': pct_profit,
                    'Final Capital': capital + profit
                }
                
                all_scenarios.append(scenario)
                scenario_id += 1
                
                # Update best scenario
                if profit > 0 and capital + profit > max_final_capital:
                    max_final_capital = capital + profit
                    best_scenario = scenario
        
        # Add more complex scenarios (multiple trades)
        # Sort buy and sell signals by date
        buy_signals = buy_signals.sort_values('Datetime')
        sell_signals = sell_signals.sort_values('Datetime')
        
        # For each starting buy signal, try to create a chain of trades
        for start_buy_idx in range(min(10, len(buy_signals))):  # Limit to first 10 buy signals for performance
            # Reset for this scenario
            current_capital = float(capital)
            transactions = []
            current_buy_idx = start_buy_idx
            position = None
            
            # Continue trading until we run out of signals
            while current_buy_idx < len(buy_signals):
                # Get next buy signal
                buy_row = buy_signals.iloc[current_buy_idx]
                buy_date = buy_row['Datetime']
                buy_price = buy_row['Price']
                
                # Find next sell signal after this buy
                valid_sells = sell_signals[sell_signals['Datetime'] > buy_date]
                if valid_sells.empty:
                    break  # No more valid sell signals
                
                sell_row = valid_sells.iloc[0]
                sell_date = sell_row['Datetime']
                sell_price = sell_row['Price']
                
                # Calculate trade
                shares = int(current_capital // buy_price)
                if shares == 0:
                    break  # Not enough capital
                
                cost = shares * buy_price
                proceeds = shares * sell_price
                profit = proceeds - cost
                
                # Update capital
                current_capital = current_capital - cost + proceeds
                
                # Add transaction
                transactions.append({
                    'Buy Date': buy_date,
                    'Buy Price': buy_price,
                    'Sell Date': sell_date,
                    'Sell Price': sell_price,
                    'Shares': shares,
                    'Investment': cost,
                    'Proceeds': proceeds,
                    'Profit': profit,
                    'Capital After': current_capital
                })
                
                # Find next buy signal after this sell
                next_buys = buy_signals[buy_signals['Datetime'] > sell_date]
                if next_buys.empty:
                    break  # No more buy signals
                
                current_buy_idx = next_buys.index[0]
            
            # Only add scenarios with at least one transaction
            if transactions:
                multi_scenario = {
                    'Scenario ID': scenario_id,
                    'Transactions': transactions,
                    'Initial Capital': float(capital),
                    'Final Capital': current_capital,
                    'Total Profit': current_capital - float(capital),
                    'Percent Profit': (current_capital - float(capital)) / float(capital) * 100,
                    'Number of Trades': len(transactions)
                }
                
                all_scenarios.append(multi_scenario)
                scenario_id += 1
                
                # Update best scenario if needed
                if current_capital > max_final_capital:
                    max_final_capital = current_capital
                    best_scenario = multi_scenario
        
        # Sort scenarios by profitability
        single_trade_scenarios = [s for s in all_scenarios if 'Transactions' not in s]
        multi_trade_scenarios = [s for s in all_scenarios if 'Transactions' in s]
        
        # Sort single trade scenarios
        single_trade_scenarios.sort(key=lambda x: x['Profit'], reverse=True)
        
        # Sort multi-trade scenarios
        multi_trade_scenarios.sort(key=lambda x: x['Total Profit'], reverse=True)
        
        # Limit to top scenarios for display
        top_single = single_trade_scenarios[:10] if len(single_trade_scenarios) > 10 else single_trade_scenarios
        top_multi = multi_trade_scenarios[:5] if len(multi_trade_scenarios) > 5 else multi_trade_scenarios
        
        if not all_scenarios:
            return html.Div("No profitable scenarios found.", className="text-red-500")
        
        # Create components
        components = [
            # Best scenario summary
            html.Div([
                html.H3("Best Linear Scenario", className="text-xl font-semibold mb-3"),
                html.Div([
                    # Display different info depending on scenario type
                    html.Div([
                        html.Div([
                            html.Span("Scenario Type: ", className="font-semibold"),
                            html.Span("Single Trade" if 'Transactions' not in best_scenario else "Multiple Trades", className="ml-1")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Initial Capital: ", className="font-semibold"),
                            html.Span(f"{capital:,.2f}", className="ml-1")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Final Capital: ", className="font-semibold"),
                            html.Span(f"{best_scenario.get('Final Capital', 0):,.2f}", 
                                    className="ml-1 text-green-600")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Total Profit: ", className="font-semibold"),
                            html.Span(f"{best_scenario.get('Profit', best_scenario.get('Total Profit', 0)):,.2f}", 
                                    className="ml-1 text-green-600")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Percent Profit: ", className="font-semibold"),
                            html.Span(f"{best_scenario.get('Percent Profit', 0):.2f}%", 
                                    className="ml-1 text-blue-600")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Number of Trades: ", className="font-semibold"),
                            html.Span(f"{best_scenario.get('Number of Trades', 1)}", className="ml-1")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Time Period: ", className="font-semibold"),
                            html.Span(f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", className="ml-1")
                        ])
                    ])
                ], className="p-4 bg-green-50 border border-green-200 rounded")
            ], className="mb-6"),
            
            # Top Single Trade Scenarios
            html.Div([
                html.H3("Top Single Trade Scenarios", className="text-xl font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'Scenario ID': s['Scenario ID'],
                        'Buy Date': s['Buy Date'].strftime('%Y-%m-%d') if hasattr(s['Buy Date'], 'strftime') else str(s['Buy Date']),
                        'Buy Price': f"{s['Buy Price']:.2f}",
                        'Sell Date': s['Sell Date'].strftime('%Y-%m-%d') if hasattr(s['Sell Date'], 'strftime') else str(s['Sell Date']),
                        'Sell Price': f"{s['Sell Price']:.2f}",
                        'Shares': s['Shares'],
                        'Profit': f"{s['Profit']:,.2f}",
                        'Percent Profit': f"{s['Percent Profit']:.2f}%",
                        'Final Capital': f"{s['Final Capital']:,.2f}"
                    } for s in top_single],
                    columns=[
                        {'name': 'Scenario ID', 'id': 'Scenario ID'},
                        {'name': 'Buy Date', 'id': 'Buy Date'},
                        {'name': 'Buy Price', 'id': 'Buy Price'},
                        {'name': 'Sell Date', 'id': 'Sell Date'},
                        {'name': 'Sell Price', 'id': 'Sell Price'},
                        {'name': 'Shares', 'id': 'Shares'},
                        {'name': 'Profit', 'id': 'Profit'},
                        {'name': 'Percent Profit', 'id': 'Percent Profit'},
                        {'name': 'Final Capital', 'id': 'Final Capital'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'row_index': 0},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'fontWeight': 'bold'
                        }
                    ],
                    sort_action='native',
                    page_size=10
                )
            ], className="mb-6"),
            
            # Multiple Trade Scenarios
            html.Div([
                html.H3("Multi-Trade Scenarios", className="text-xl font-semibold mb-3"),
                dash_table.DataTable(
                    data=[{
                        'Scenario ID': s['Scenario ID'],
                        'Initial Capital': f"{s['Initial Capital']:,.2f}",
                        'Final Capital': f"{s['Final Capital']:,.2f}",
                        'Total Profit': f"{s['Total Profit']:,.2f}",
                        'Percent Profit': f"{s['Percent Profit']:.2f}%",
                        'Number of Trades': s['Number of Trades']
                    } for s in top_multi],
                    columns=[
                        {'name': 'Scenario ID', 'id': 'Scenario ID'},
                        {'name': 'Initial Capital', 'id': 'Initial Capital'},
                        {'name': 'Final Capital', 'id': 'Final Capital'},
                        {'name': 'Total Profit', 'id': 'Total Profit'},
                        {'name': 'Percent Profit', 'id': 'Percent Profit'},
                        {'name': 'Number of Trades', 'id': 'Number of Trades'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'row_index': 0},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'fontWeight': 'bold'
                        }
                    ],
                    sort_action='native'
                )
            ], className="mb-6")
        ]
        
        # Add details for the best multi-trade scenario
        if multi_trade_scenarios:
            best_multi = multi_trade_scenarios[0]
            
            # Create a detailed view of transactions
            transactions_table = dash_table.DataTable(
                data=[{
                    'Buy Date': t['Buy Date'].strftime('%Y-%m-%d') if hasattr(t['Buy Date'], 'strftime') else str(t['Buy Date']),
                    'Buy Price': f"{t['Buy Price']:.2f}",
                    'Sell Date': t['Sell Date'].strftime('%Y-%m-%d') if hasattr(t['Sell Date'], 'strftime') else str(t['Sell Date']),
                    'Sell Price': f"{t['Sell Price']:.2f}",
                    'Shares': t['Shares'],
                    'Profit': f"{t['Profit']:,.2f}",
                    'Capital After': f"{t['Capital After']:,.2f}"
                } for t in best_multi['Transactions']],
                columns=[
                    {'name': 'Buy Date', 'id': 'Buy Date'},
                    {'name': 'Buy Price', 'id': 'Buy Price'},
                    {'name': 'Sell Date', 'id': 'Sell Date'},
                    {'name': 'Sell Price', 'id': 'Sell Price'},
                    {'name': 'Shares', 'id': 'Shares'},
                    {'name': 'Profit', 'id': 'Profit'},
                    {'name': 'Capital After', 'id': 'Capital After'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Profit} contains "-"'},
                        'color': 'red'
                    },
                    {
                        'if': {'filter_query': '{Profit} > 0'},
                        'color': 'green'
                    }
                ],
                page_size=10
            )
            
            # Add capital growth chart
            capital_growth = go.Figure(
                data=[
                    go.Scatter(
                        x=list(range(len(best_multi['Transactions']))),
                        y=[t['Capital After'] for t in best_multi['Transactions']],
                        mode='lines+markers',
                        name='Capital',
                        line=dict(color='blue', width=2)
                    ),
                    go.Scatter(
                        x=[0, len(best_multi['Transactions'])-1],
                        y=[capital, capital],
                        mode='lines',
                        name='Initial Capital',
                        line=dict(color='gray', width=1, dash='dash')
                    )
                ],
                layout=go.Layout(
                    title='Capital Growth for Best Multi-Trade Scenario',
                    xaxis_title='Trade Number',
                    yaxis_title='Capital',
                    height=400,
                    margin=dict(l=50, r=50, t=80, b=50)
                )
            )
            
            components.append(html.Div([
                html.H3("Best Multi-Trade Scenario Details", className="text-xl font-semibold mb-3"),
                html.Div([
                    html.Div([
                        html.Span("Scenario ID: ", className="font-semibold"),
                        html.Span(str(best_multi['Scenario ID']), className="ml-1")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Number of Trades: ", className="font-semibold"),
                        html.Span(str(best_multi['Number of Trades']), className="ml-1")
                    ], className="mb-2"),
                    html.Div([
                        html.Span("Total Profit: ", className="font-semibold"),
                        html.Span(f"{best_multi['Total Profit']:,.2f} ({best_multi['Percent Profit']:.2f}%)", 
                                className="ml-1 text-green-600")
                    ], className="mb-4"),
                    
                    html.H4("Transaction Details", className="text-lg font-semibold mb-2"),
                    transactions_table,
                    
                    html.Div([
                        html.H4("Capital Growth", className="text-lg font-semibold my-4"),
                        dcc.Graph(figure=capital_growth)
                    ], className="mt-4")
                ], className="p-4 bg-white border rounded shadow-sm")
            ], className="mb-6"))
        
        return html.Div(components)

    return app

        



# Helper functions to create components for Standard Backtesting
def create_standard_leaderboard(results, ticker):
    """Create a leaderboard of indicator performance for standard backtesting"""
    if not results:
        return html.Div("No backtesting results available", className="text-center text-gray-500 p-4")
    
    # Convert results to a list for sorting and display
    result_list = []
    for indicator, result in results.items():
        result_list.append({
            'Indicator': indicator,
            'Profit': result['total_profit'],
            'Profit %': result['profit_percentage'],
            'Final Capital': result['final_capital'],
            'Trades': result['num_trades'],
            'Win Rate': result['win_rate']
        })
    
    # Sort by profit percentage
    result_list = sorted(result_list, key=lambda x: x['Profit %'], reverse=True)
    
    return html.Div([
        html.H3(f"{ticker} - Indicator Performance Leaderboard", className="text-lg font-semibold mb-4"),
        
        # Best performer card
        html.Div([
            html.H4("Top Performing Indicator", className="text-md font-semibold mb-2"),
            html.Div([
                html.Div([
                    html.Span("Indicator: ", className="font-semibold"),
                    html.Span(result_list[0]['Indicator'], className="ml-1 text-blue-600")
                ], className="mb-1"),
                html.Div([
                    html.Span("Profit: ", className="font-semibold"),
                    html.Span(f"{result_list[0]['Profit']:.2f}", 
                             className=f"ml-1 {'text-green-600' if result_list[0]['Profit'] > 0 else 'text-red-600'}")
                ], className="mb-1"),
                html.Div([
                    html.Span("Profit %: ", className="font-semibold"),
                    html.Span(f"{result_list[0]['Profit %']:.2f}%", 
                             className=f"ml-1 {'text-green-600' if result_list[0]['Profit %'] > 0 else 'text-red-600'}")
                ], className="mb-1"),
                html.Div([
                    html.Span("Win Rate: ", className="font-semibold"),
                    html.Span(f"{result_list[0]['Win Rate']:.2f}%", className="ml-1 text-blue-600")
                ], className="mb-1"),
            ], className="p-3 bg-green-50 border border-green-200 rounded mb-4")
        ]),
        
        # Full leaderboard table
        dash_table.DataTable(
            data=result_list,
            columns=[
                {'name': 'Indicator', 'id': 'Indicator'},
                {'name': 'Profit', 'id': 'Profit', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                {'name': 'Profit %', 'id': 'Profit %', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                {'name': 'Final Capital', 'id': 'Final Capital', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                {'name': 'Trades', 'id': 'Trades', 'type': 'numeric'},
                {'name': 'Win Rate', 'id': 'Win Rate', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}}
            ],
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '10px'},
            style_header={
                'backgroundColor': 'rgb(240, 240, 240)',
                'fontWeight': 'bold'
            },
            style_data_conditional=[
                {
                    'if': {'row_index': 0},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'fontWeight': 'bold'
                },
                {
                    'if': {'filter_query': '{Profit %} < 0'},
                    'color': 'red'
                },
                {
                    'if': {'filter_query': '{Profit %} >= 0'},
                    'color': 'green'
                }
            ],
            sort_action='native'
        ),
        
        # Bar chart for visual comparison
        dcc.Graph(
            figure=go.Figure(
                data=[
                    go.Bar(
                        x=[r['Indicator'] for r in result_list],
                        y=[r['Profit %'] for r in result_list],
                        marker_color=['green' if p > 0 else 'red' for p in [r['Profit %'] for r in result_list]],
                        text=[f"{p:.2f}%" for p in [r['Profit %'] for r in result_list]],
                        textposition='auto'
                    )
                ],
                layout=go.Layout(
                    title=f"Indicator Profit Comparison for {ticker}",
                    xaxis_title="Technical Indicator",
                    yaxis_title="Profit %",
                    height=400,
                    margin=dict(l=50, r=50, t=80, b=100)
                )
            )
        )
    ])

def create_standard_detailed_results(results, ticker):
    """Create detailed results for each indicator in standard backtesting"""
    if not results:
        return html.Div("No backtesting results available", className="text-center text-gray-500 p-4")
    
    # Create a tab for each indicator
    indicator_tabs = []
    
    for indicator, result in results.items():
        indicator_tab = dcc.Tab(
            label=indicator,
            children=[
                html.Div([
                    html.H4(f"{indicator} Backtest Results", className="text-lg font-semibold mb-3"),
                    
                    # Summary card
                    html.Div([
                        html.Div([
                            html.Span("Initial Capital: ", className="font-semibold"),
                            html.Span(f"{result['initial_capital']:.2f}", className="ml-1")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Final Capital: ", className="font-semibold"),
                            html.Span(f"{result['final_capital']:.2f}", 
                                     className=f"ml-1 {'text-green-600' if result['final_capital'] > result['initial_capital'] else 'text-red-600'}")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Total Profit: ", className="font-semibold"),
                            html.Span(f"{result['total_profit']:.2f}", 
                                     className=f"ml-1 {'text-green-600' if result['total_profit'] > 0 else 'text-red-600'}")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Profit %: ", className="font-semibold"),
                            html.Span(f"{result['profit_percentage']:.2f}%", 
                                     className=f"ml-1 {'text-green-600' if result['profit_percentage'] > 0 else 'text-red-600'}")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Number of Trades: ", className="font-semibold"),
                            html.Span(f"{result['num_trades']}", className="ml-1")
                        ], className="mb-2"),
                        html.Div([
                            html.Span("Win Rate: ", className="font-semibold"),
                            html.Span(f"{result['win_rate']:.2f}%", className="ml-1 text-blue-600")
                        ]),
                    ], className="p-4 bg-white rounded shadow-sm mb-4"),
                    
                    # Capital growth chart
                    html.Div([
                        html.H4("Capital Growth", className="text-md font-semibold mb-2"),
                        dcc.Graph(
                            figure=go.Figure(
                                data=[
                                    go.Scatter(
                                        x=[i for i in range(len(result['trades']))],
                                        y=[t['remaining_cash'] for t in result['trades']],
                                        mode='lines+markers',
                                        name='Capital',
                                        line=dict(color='blue', width=2),
                                        marker=dict(
                                            size=8,
                                            color=['green' if t['type'] == 'Sell' else 'red' for t in result['trades']],
                                            symbol=['triangle-up' if t['type'] == 'Buy' else 'triangle-down' for t in result['trades']]
                                        )
                                    ),
                                    go.Scatter(
                                        x=[0, len(result['trades'])-1],
                                        y=[result['initial_capital'], result['initial_capital']],
                                        mode='lines',
                                        name='Initial Capital',
                                        line=dict(color='gray', width=1, dash='dash')
                                    )
                                ],
                                layout=go.Layout(
                                    title=f"Capital Growth for {ticker} with {indicator}",
                                    xaxis_title="Trade Number",
                                    yaxis_title="Capital",
                                    height=400,
                                    margin=dict(l=50, r=50, t=80, b=50)
                                )
                            )
                        )
                    ])
                ])
            ]
        )
        
        indicator_tabs.append(indicator_tab)
    
    return html.Div([
        dcc.Tabs(indicator_tabs)
    ])

def create_standard_trade_performance(results, ticker):
    """Create trade performance details for each indicator"""
    if not results:
        return html.Div("No trade performance data available", className="text-center text-gray-500 p-4")
    
    # Create a tab for each indicator
    trade_tabs = []
    
    for indicator, result in results.items():
        if not result['trades']:
            continue
            
        trade_tab = dcc.Tab(
            label=indicator,
            children=[
                html.Div([
                    html.H4(f"{indicator} Trade History", className="text-lg font-semibold mb-3"),
                    
                    # Trade table
                    dash_table.DataTable(
                        data=[{
                            'Date': t['date'].strftime('%Y-%m-%d') if hasattr(t['date'], 'strftime') else str(t['date']),
                            'Type': t['type'],
                            'Price': f"{t['price']:.2f}",
                            'Shares': t['shares'],
                            'Value': f"{t['value']:.2f}",
                            'Capital': f"{t['remaining_cash']:.2f}"
                        } for t in result['trades']],
                        columns=[
                            {'name': 'Date', 'id': 'Date'},
                            {'name': 'Type', 'id': 'Type'},
                            {'name': 'Price', 'id': 'Price'},
                            {'name': 'Shares', 'id': 'Shares'},
                            {'name': 'Value', 'id': 'Value'},
                            {'name': 'Capital', 'id': 'Capital'}
                        ],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px'},
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{Type} = "Buy"'},
                                'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                'color': 'green'
                            },
                            {
                                'if': {'filter_query': '{Type} = "Sell"'},
                                'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                'color': 'red'
                            }
                        ],
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        page_size=10,
                        sort_action='native'
                    ),
                    
                    # Trade metrics
                    html.Div([
                        html.H4("Trade Metrics", className="text-md font-semibold mt-4 mb-2"),
                        html.Div([
                            html.Div([
                                html.Div([
                                    html.Span("Total Trades", className="block text-sm text-gray-500"),
                                    html.Span(f"{result['num_trades']}", className="block text-xl font-bold text-blue-600")
                                ], className="p-4 border rounded bg-white shadow-sm")
                            ], className="w-1/3 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Win Rate", className="block text-sm text-gray-500"),
                                    html.Span(f"{result['win_rate']:.2f}%", className="block text-xl font-bold text-blue-600")
                                ], className="p-4 border rounded bg-white shadow-sm")
                            ], className="w-1/3 px-2"),
                            html.Div([
                                html.Div([
                                    html.Span("Avg Profit/Trade", className="block text-sm text-gray-500"),
                                    html.Span(
                                        f"{result['total_profit']/result['num_trades']:.2f}" if result['num_trades'] > 0 else "N/A", 
                                        className="block text-xl font-bold text-blue-600"
                                    )
                                ], className="p-4 border rounded bg-white shadow-sm")
                            ], className="w-1/3 px-2"),
                        ], className="flex -mx-2 mt-2")
                    ])
                ])
            ]
        )
        
        trade_tabs.append(trade_tab)
    
    if not trade_tabs:
        return html.Div("No trade data available", className="text-center text-gray-500 p-4")
    
    return html.Div([
        dcc.Tabs(trade_tabs)
    ])

def create_standard_raw_data_table(df):
    """Create a table showing the raw data with signals"""
    if df.empty:
        return html.Div("No raw data available", className="text-center text-gray-500 p-4")
    
    # Add filtering and search capabilities
    return html.Div([
        html.H4("Raw Data with Signals", className="text-lg font-semibold mb-3"),
        
        # Filter controls
        html.Div([
            html.Div([
                html.Label("Filter by Signal:", className="mr-2 font-medium"),
                dcc.Dropdown(
                    id="raw-signal-filter",
                    options=[
                        {'label': 'All Signals', 'value': 'all'},
                        {'label': 'Buy Signals', 'value': 'Buy'},
                        {'label': 'Sell Signals', 'value': 'Sell'},
                        {'label': 'Hold Signals', 'value': 'Hold'}
                    ],
                    value='all',
                    clearable=False,
                    className="w-64"
                )
            ], className="flex items-center")
        ], className="mb-4"),
        
        # Data table
        dash_table.DataTable(
            id="raw-data-table",
            data=df.to_dict('records'),
            columns=[{'name': col, 'id': col} for col in df.columns],
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '10px'},
            style_data_conditional=[
                {
                    'if': {'filter_query': '{Combined_Signal} = "Buy"'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                },
                {
                    'if': {'filter_query': '{Combined_Signal} = "Sell"'},
                    'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                }
            ],
            style_header={
                'backgroundColor': 'rgb(240, 240, 240)',
                'fontWeight': 'bold'
            },
            page_size=15,
            filter_action='native',
            sort_action='native'
        )
    ])

# Helper functions to extract components from analysis results
def extract_analysis_leaderboard(components):
    """Extract leaderboard data from analysis components"""
    # Find the component that contains the leaderboard
    # This is approximate and depends on the structure of the returned components
    leaderboard_components = []
    
    for component in components:
        # Look for components that might be part of the leaderboard
        if isinstance(component, html.H3) and ("Best Performing Strategy" in component.children or 
                                             "Strategy Comparison" in component.children):
            leaderboard_components.append(component)
            continue
            
        if isinstance(component, dash_table.DataTable):
            # This might be a leaderboard table
            leaderboard_components.append(component)
            continue
            
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check if this div contains a header for leaderboard
            for child in component.children:
                if isinstance(child, html.H3) and ("Best Performing" in child.children or 
                                                 "Strategy Comparison" in child.children):
                    leaderboard_components.append(component)
                    break
    
    if leaderboard_components:
        return html.Div(leaderboard_components)
    else:
        return html.Div("No leaderboard data available", className="text-center text-gray-500 p-4")

def extract_analysis_details(components):
    """Extract detailed results from analysis components"""
    detail_components = []
    
    for component in components:
        # Look for components that might contain detailed results
        if isinstance(component, html.H3) and "Analysis Conclusion" in component.children:
            detail_components.append(component)
            continue
            
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check if this div contains details about indicators
            for child in component.children:
                if isinstance(child, html.H4) and ("Indicator Insights" in child.children or 
                                                "Combination Strategy Insights" in child.children):
                    detail_components.append(component)
                    break
    
    if detail_components:
        return html.Div(detail_components)
    else:
        return html.Div("No detailed analysis available", className="text-center text-gray-500 p-4")

def extract_analysis_performance(components):
    """Extract trade performance from analysis components"""
    performance_components = []
    
    for component in components:
        # Look for components related to trade details
        if isinstance(component, html.H3) and "Trade Details" in component.children:
            performance_components.append(component)
            continue
            
        if isinstance(component, dash_table.DataTable):
            # This might be a trades table
            column_names = [col['name'] for col in component.columns]
            if 'Entry Date' in column_names and 'Exit Date' in column_names:
                performance_components.append(component)
                continue
    
    if performance_components:
        return html.Div(performance_components)
    else:
        return html.Div("No trade performance data available", className="text-center text-gray-500 p-4")

def extract_analysis_comparison(components):
    """Extract indicator comparison from analysis components"""
    comparison_components = []
    
    for component in components:
        # Look for graph components
        if isinstance(component, dcc.Graph):
            comparison_components.append(component)
            continue
            
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check if this div contains comparisons between indicators
            for child in component.children:
                if isinstance(child, html.H3) and ("Strategy Comparison" in child.children or 
                                                 "Comparative Performance" in child.children):
                    comparison_components.append(component)
                    break
    
    if comparison_components:
        return html.Div(comparison_components)
    else:
        return html.Div("No indicator comparison available", className="text-center text-gray-500 p-4")

# Helper functions to extract components from profit analysis results
def extract_profit_top_scenarios(components):
    """Extract top scenarios from profit analysis results"""
    top_scenario_components = []
    
    for component in components:
        # Look for components related to top scenarios
        if isinstance(component, html.H2) and "Best Linear Scenario" in component.children:
            top_scenario_components.append(component)
            continue
            
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check if this div contains best scenario data
            contains_best_scenario = False
            for child in component.children:
                if isinstance(child, html.H2) and "Best Linear Scenario" in child.children:
                    contains_best_scenario = True
                    break
            
            if contains_best_scenario:
                top_scenario_components.append(component)
                continue
                
        if isinstance(component, html.H2) and "Top Performing Scenarios" in component.children:
            top_scenario_components.append(component)
            continue
            
        if isinstance(component, dash_table.DataTable):
            # This might be a top scenarios table
            if hasattr(component, 'columns') and component.columns:
                column_names = [col['name'] for col in component.columns]
                if 'Scenario ID' in column_names or 'Final Capital' in column_names:
                    top_scenario_components.append(component)
                    continue
    
    if top_scenario_components:
        return html.Div(top_scenario_components)
    else:
        return html.Div("No top scenario data available", className="text-center text-gray-500 p-4")

def extract_profit_scenario_details(components):
    """Extract scenario details from profit analysis results"""
    detail_components = []
    
    for component in components:
        # Look for components related to scenario details
        if isinstance(component, html.H3) and "Scenario" in component.children and "Details" in component.children:
            detail_components.append(component)
            continue
            
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check if this div contains scenario details
            contains_scenario_details = False
            for child in component.children:
                if isinstance(child, html.H3) and "Scenario" in child.children and "Details" in child.children:
                    contains_scenario_details = True
                    break
            
            if contains_scenario_details:
                detail_components.append(component)
                continue
    
    if detail_components:
        return html.Div(detail_components)
    else:
        return html.Div("No scenario details available", className="text-center text-gray-500 p-4")

def extract_profit_performance_metrics(components):
    """Extract performance metrics from profit analysis results"""
    metric_components = []
    
    for component in components:
        # Look for components related to performance metrics
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check for common performance metric terms
            contains_metrics = False
            for child in component.children:
                if isinstance(child, (html.H3, html.H4)) and any(term in child.children for term in 
                                                               ["Performance", "Statistics", "Metrics"]):
                    contains_metrics = True
                    break
            
            if contains_metrics:
                metric_components.append(component)
                continue
    
    if metric_components:
        return html.Div(metric_components)
    else:
        return html.Div("No performance metrics available", className="text-center text-gray-500 p-4")

def extract_profit_visualizations(components):
    """Extract visualizations from profit analysis results"""
    visualization_components = []
    
    for component in components:
        # Look for graph components
        if isinstance(component, dcc.Graph):
            visualization_components.append(component)
            continue
            
        if isinstance(component, html.Div) and hasattr(component, 'children'):
            # Check if this div contains graphs
            for child in component.children:
                if isinstance(child, dcc.Graph):
                    visualization_components.append(component)
                    break
    
    if visualization_components:
        return html.Div(visualization_components)
    else:
        return html.Div("No visualizations available", className="text-center text-gray-500 p-4")

















# def apply_technical_indicators(df, selected_technicals, **params):
#     """
#     Apply technical indicators to the dataframe based on selected indicators
#     """
#     print(f"Applying {len(selected_technicals)} technical indicator(s) to data with {len(df)} rows")
#     print(f"Selected indicators: {selected_technicals}")
#     print(f"Parameters: {params}")
    
#     if df.empty:
#         print("WARNING: DataFrame is empty, cannot apply indicators")
#         return df
    
#     # Make a copy to avoid modifying the original
#     df_copy = df.copy()
#     # Helper functions to calculate indicators (simplified versions for brevity)
#     def calculate_bollinger_bands(df, window=20, num_std=2):
#         df['Middle Band'] = df['Close'].rolling(window=window).mean()
#         df['STD'] = df['Close'].rolling(window=window).std()
#         df['Upper Band'] = df['Middle Band'] + (num_std * df['STD'])
#         df['Lower Band'] = df['Middle Band'] - (num_std * df['STD'])
#         df['Bollinger_Signal'] = 'Hold'
#         mask = ~df[['Upper Band', 'Lower Band', 'Middle Band']].isna().any(axis=1)
#         df.loc[mask & (df['Close'] >= df['Upper Band']), 'Bollinger_Signal'] = 'Sell'
#         df.loc[mask & (df['Close'] <= df['Lower Band']), 'Bollinger_Signal'] = 'Buy'
#         return df

#     def calculate_ma(df, short_period=20, long_period=50):
#         df['short_MA'] = df['Close'].rolling(window=short_period).mean()
#         df['long_MA'] = df['Close'].rolling(window=long_period).mean()
#         df['MA_Signal'] = 'Hold'
#         mask = ~df[['short_MA', 'long_MA']].isna().any(axis=1)
#         df.loc[mask & (df['short_MA'] > df['long_MA']), 'MA_Signal'] = 'Buy'
#         df.loc[mask & (df['short_MA'] < df['long_MA']), 'MA_Signal'] = 'Sell'
#         return df

#     def calculate_rsi(df, period=14, ob_level=70, os_level=30):
#         delta = df['Close'].diff()
#         gain = delta.where(delta > 0, 0)
#         loss = -delta.where(delta < 0, 0)
#         avg_gain = gain.rolling(window=period).mean()
#         avg_loss = loss.rolling(window=period).mean()
#         rs = avg_gain / avg_loss
#         df['RSI'] = 100 - (100 / (1 + rs))
#         df['RSI_Signal'] = 'Hold'
#         mask = ~df['RSI'].isna()
#         df.loc[mask & (df['RSI'] > ob_level), 'RSI_Signal'] = 'Sell'
#         df.loc[mask & (df['RSI'] < os_level), 'RSI_Signal'] = 'Buy'
#         return df

#     def calculate_macd(df, short_window=12, long_window=26, signal_window=9):
#         df['EMA_short'] = df['Close'].ewm(span=short_window, adjust=False).mean()
#         df['EMA_long'] = df['Close'].ewm(span=long_window, adjust=False).mean()
#         df['MACD'] = df['EMA_short'] - df['EMA_long']
#         df['Signal_Line'] = df['MACD'].ewm(span=signal_window, adjust=False).mean()
#         df['MACD_Hist'] = df['MACD'] - df['Signal_Line']
#         df['MACD_Signal'] = 'Hold'
#         mask = ~df[['MACD', 'Signal_Line']].isna().any(axis=1)
#         df.loc[mask & (df['MACD'] > df['Signal_Line']), 'MACD_Signal'] = 'Buy'
#         df.loc[mask & (df['MACD'] < df['Signal_Line']), 'MACD_Signal'] = 'Sell'
#         return df
    
#     # Apply selected technical indicators
#     if 'Bollinger_Signal' in selected_technicals:
#         window = params.get('bb_period', 20)
#         num_std = params.get('bb_std', 2)
#         print(f"Calculating Bollinger Bands with window={window}, std={num_std}")
#         df_copy = calculate_bollinger_bands(df_copy, window=window, num_std=num_std)
#         print(f"Bollinger signal counts: {df_copy['Bollinger_Signal'].value_counts().to_dict()}")
    
#     if 'MA_Signal' in selected_technicals:
#         short_period = params.get('ma_short', 20)
#         long_period = params.get('ma_long', 50)
#         print(f"Calculating Moving Averages with short={short_period}, long={long_period}")
#         df_copy = calculate_ma(df_copy, short_period=short_period, long_period=long_period)
#         print(f"MA signal counts: {df_copy['MA_Signal'].value_counts().to_dict()}")
    
#     if 'RSI_Signal' in selected_technicals:
#         period = params.get('rsi_period', 14)
#         ob_level = params.get('rsi_overbought', 70)
#         os_level = params.get('rsi_oversold', 30)
#         print(f"Calculating RSI with period={period}, overbought={ob_level}, oversold={os_level}")
#         df_copy = calculate_rsi(df_copy, period=period, ob_level=ob_level, os_level=os_level)
#         print(f"RSI signal counts: {df_copy['RSI_Signal'].value_counts().to_dict()}")
    
#     if 'MACD_Signal' in selected_technicals:
#         fast = params.get('macd_fast', 12)
#         slow = params.get('macd_slow', 26)
#         signal = params.get('macd_signal', 9)
#         print(f"Calculating MACD with fast={fast}, slow={slow}, signal={signal}")
#         df_copy = calculate_macd(df_copy, short_window=fast, long_window=slow, signal_window=signal)
#         print(f"MACD signal counts: {df_copy['MACD_Signal'].value_counts().to_dict()}")
    
#     # Add combined signal
#     if len(selected_technicals) > 0:
#         print("Calculating combined signal from indicators")
#         df_copy = calculate_combined_signal(df_copy, selected_technicals)
#         print(f"Combined signal counts: {df_copy['Combined_Signal'].value_counts().to_dict()}")
    
#     return df_copy

# def calculate_combined_signal(df, selected_technicals):
#     """Calculate a combined signal based on all selected indicators"""
#     # Initialize the signal column
#     df['Combined_Signal'] = None
    
#     # Only process rows where we have all signals
#     for idx, row in df.iterrows():
#         signals = []
#         for tech in selected_technicals:
#             if tech in row and pd.notna(row[tech]):
#                 signals.append(row[tech])
        
#         # Count signal types
#         buy_count = signals.count('Buy')
#         sell_count = signals.count('Sell')
#         hold_count = signals.count('Hold')
        
#         # Determine majority signal
#         if buy_count > sell_count and buy_count > hold_count:
#             df.at[idx, 'Combined_Signal'] = 'Buy'
#         elif sell_count > buy_count and sell_count > hold_count:
#             df.at[idx, 'Combined_Signal'] = 'Sell'
#         else:
#             df.at[idx, 'Combined_Signal'] = 'Hold'
    
#     return df

# def calculate_candlestick_trend(df):
#     """Calculate candlestick trend dengan output Uptrend/Downtrend/Sideways - ENHANCED DEBUG"""
#     try:
#         from Candlestick_pattern import detect_candlestick_patterns
        
#         # print(f"ðŸ” DEBUG: Input DataFrame type: {type(df)}, shape: {df.shape if hasattr(df, 'shape') else 'N/A'}")
        
#         # Ensure we have a DataFrame
#         if not isinstance(df, pd.DataFrame):
#             print(f"âš ï¸ Warning: Input is not DataFrame, converting from {type(df)}")
#             if isinstance(df, dict):
#                 df = pd.DataFrame(df)
#             else:
#                 return pd.Series('Sideways', index=range(len(df)) if hasattr(df, '__len__') else [0])
        
#         # Make a clean copy to avoid any reference issues
#         df_temp = df.copy()
        
#         # Call the candlestick pattern detection
#         print(f"ðŸ” DEBUG: Calling detect_candlestick_patterns...")
#         df_with_patterns = detect_candlestick_patterns(df_temp)
        
#         print(f"ðŸ” DEBUG: Candlestick detection result type: {type(df_with_patterns)}")
#         print(f"ðŸ” DEBUG: Available columns: {df_with_patterns.columns.tolist() if hasattr(df_with_patterns, 'columns') else 'No columns'}")
        
#         # Initialize trend dengan 'Sideways' sebagai default
#         candlestick_trend = pd.Series('Sideways', index=df.index)
        
#         # Method 1: Check if there's a direct 'candlestick_trend' or 'trend' column
#         trend_columns = ['candlestick_trend', 'trend', 'Trend', 'Pattern_Trend']
#         found_trend_column = None
        
#         for col in trend_columns:
#             if col in df_with_patterns.columns:
#                 found_trend_column = col
#                 print(f"ðŸ” DEBUG: Found trend column '{col}', using it directly")
#                 break
        
#         if found_trend_column:
#             # Use the existing trend column and map to our values
#             trend_values = df_with_patterns[found_trend_column].fillna('Sideways')
#             for idx in df.index:
#                 if idx < len(trend_values):
#                     raw_trend = trend_values.iloc[idx] if hasattr(trend_values, 'iloc') else trend_values[idx]
#                     # Map various trend representations to our standard
#                     if pd.isna(raw_trend):
#                         candlestick_trend.at[idx] = 'Sideways'
#                     elif str(raw_trend).lower() in ['uptrend', 'up', 'bullish', 'rising', '1', 'naik']:
#                         candlestick_trend.at[idx] = 'Uptrend'
#                     elif str(raw_trend).lower() in ['downtrend', 'down', 'bearish', 'falling', '-1', 'turun']:
#                         candlestick_trend.at[idx] = 'Downtrend'
#                     else:
#                         candlestick_trend.at[idx] = 'Sideways'
        
#         # Method 2: Use pattern counts to determine trend
#         elif all(col in df_with_patterns.columns for col in ['bullish_patterns', 'bearish_patterns']):
#             print("ðŸ” DEBUG: Using pattern counts to determine trend")
#             for idx in df_with_patterns.index:
#                 try:
#                     bullish_count = df_with_patterns.at[idx, 'bullish_patterns'] if pd.notna(df_with_patterns.at[idx, 'bullish_patterns']) else 0
#                     bearish_count = df_with_patterns.at[idx, 'bearish_patterns'] if pd.notna(df_with_patterns.at[idx, 'bearish_patterns']) else 0
                    
#                     # print(f"ðŸ” DEBUG (idx {idx}): Bullish: {bullish_count}, Bearish: {bearish_count}")
                    
#                     if bullish_count > bearish_count:
#                         candlestick_trend.at[idx] = 'Uptrend'
#                     elif bearish_count > bullish_count:
#                         candlestick_trend.at[idx] = 'Downtrend'
#                     else:
#                         candlestick_trend.at[idx] = 'Sideways'
#                 except Exception as idx_error:
#                     print(f"âŒ Error processing index {idx}: {idx_error}")
#                     candlestick_trend.at[idx] = 'Sideways'
        
#         # Method 3: Use price momentum to determine trend
#         else:
#             print("ðŸ” DEBUG: No pattern data available, using price momentum")
#             if 'Close' in df.columns:
#                 close_prices = df['Close']
#                 # Calculate short-term trend using moving averages
#                 short_ma = close_prices.rolling(window=5, min_periods=1).mean()
#                 long_ma = close_prices.rolling(window=20, min_periods=1).mean()
                
#                 for i in range(len(df)):
#                     try:
#                         current_idx = df.index[i]
                        
#                         if pd.notna(short_ma.iloc[i]) and pd.notna(long_ma.iloc[i]):
#                             if short_ma.iloc[i] > long_ma.iloc[i] * 1.02:  # 2% threshold for uptrend
#                                 candlestick_trend.at[current_idx] = 'Uptrend'
#                             elif short_ma.iloc[i] < long_ma.iloc[i] * 0.98:  # 2% threshold for downtrend
#                                 candlestick_trend.at[current_idx] = 'Downtrend'
#                             else:
#                                 candlestick_trend.at[current_idx] = 'Sideways'
#                         else:
#                             candlestick_trend.at[current_idx] = 'Sideways'
#                     except Exception as momentum_error:
#                         print(f"âŒ Error calculating momentum at index {i}: {momentum_error}")
#                         if i < len(candlestick_trend):
#                             candlestick_trend.iloc[i] = 'Sideways'
        
#         # Ensure the result has the same index as input
#         if len(candlestick_trend) != len(df):
#             print(f"âš ï¸ Length mismatch: trend={len(candlestick_trend)}, df={len(df)}, creating new series")
#             candlestick_trend = pd.Series('Sideways', index=df.index)
        
#         # Validate trend values - hanya Uptrend, Downtrend, Sideways
#         valid_trends = ['Uptrend', 'Downtrend', 'Sideways']
#         candlestick_trend = candlestick_trend.apply(lambda x: x if x in valid_trends else 'Sideways')
        
#         print(f"ðŸ” DEBUG: Final trend distribution: {candlestick_trend.value_counts().to_dict()}")
#         return candlestick_trend
        
#     except ImportError as import_error:
#         print(f"âŒ Cannot import Candlestick_pattern: {import_error}")
#         return pd.Series('Sideways', index=df.index)
#     except Exception as e:
#         print(f"âŒ Error in candlestick trend calculation: {e}")
#         print(f"Error type: {type(e)}")
#         import traceback
#         print(f"Traceback: {traceback.format_exc()}")
#         return pd.Series('Sideways', index=df.index)


# CALCULATE TECHNICAL INDICATORS
# def apply_technical_indicators(df, selected_technicals, **params):
#     """
#     Apply technical indicators with enhanced voting system - FIXED FRAGMENTATION
#     """
#     print(f"Applying {len(selected_technicals)} technical indicator(s) to data with {len(df)} rows")
#     print(f"Selected indicators: {selected_technicals}")
#     print(f"Parameters: {params}")
    
#     if df.empty:
#         print("WARNING: DataFrame is empty, cannot apply indicators")
#         return df
    
#     # Make a clean copy to avoid modifying the original and prevent fragmentation
#     df_copy = df.copy()
    
#     # Dictionary to store all new columns
#     new_columns = {}
    
#     # Helper functions to calculate indicators (modified to return columns instead of modifying df)
#     def calculate_bollinger_bands(df, window=20, num_std=2):
#         """Calculate Bollinger Bands and return new columns"""
#         middle_band = df['Close'].rolling(window=window).mean()
#         std = df['Close'].rolling(window=window).std()
#         upper_band = middle_band + (num_std * std)
#         lower_band = middle_band - (num_std * std)
        
#         # Generate signals
#         bollinger_signal = pd.Series('Hold', index=df.index)
#         mask = ~pd.concat([upper_band, lower_band, middle_band], axis=1).isna().any(axis=1)
#         bollinger_signal.loc[mask & (df['Close'] >= upper_band)] = 'Sell'
#         bollinger_signal.loc[mask & (df['Close'] <= lower_band)] = 'Buy'
        
#         return {
#             'Middle Band': middle_band,
#             'STD': std,
#             'Upper Band': upper_band,
#             'Lower Band': lower_band,
#             'Bollinger_Signal': bollinger_signal
#         }

#     def calculate_ma(df, short_period=20, long_period=50):
#         """Calculate Moving Average and return new columns"""
#         short_ma = df['Close'].rolling(window=short_period).mean()
#         long_ma = df['Close'].rolling(window=long_period).mean()
        
#         # Generate signals
#         ma_signal = pd.Series('Hold', index=df.index)
#         mask = ~pd.concat([short_ma, long_ma], axis=1).isna().any(axis=1)
#         ma_signal.loc[mask & (short_ma > long_ma)] = 'Buy'
#         ma_signal.loc[mask & (short_ma < long_ma)] = 'Sell'
        
#         return {
#             'short_MA': short_ma,
#             'long_MA': long_ma,
#             'MA_Signal': ma_signal
#         }

#     def calculate_rsi(df, period=14, ob_level=70, os_level=30):
#         """Calculate RSI and return new columns"""
#         delta = df['Close'].diff()
#         gain = delta.where(delta > 0, 0)
#         loss = -delta.where(delta < 0, 0)
#         avg_gain = gain.rolling(window=period).mean()
#         avg_loss = loss.rolling(window=period).mean()
#         rs = avg_gain / avg_loss
#         rsi = 100 - (100 / (1 + rs))
        
#         # Generate signals
#         rsi_signal = pd.Series('Hold', index=df.index)
#         mask = ~rsi.isna()
#         rsi_signal.loc[mask & (rsi > ob_level)] = 'Sell'
#         rsi_signal.loc[mask & (rsi < os_level)] = 'Buy'
        
#         return {
#             'RSI': rsi,
#             'RSI_Signal': rsi_signal
#         }

#     def calculate_macd(df, short_window=12, long_window=26, signal_window=9):
#         """Calculate MACD and return new columns"""
#         ema_short = df['Close'].ewm(span=short_window, adjust=False).mean()
#         ema_long = df['Close'].ewm(span=long_window, adjust=False).mean()
#         macd = ema_short - ema_long
#         signal_line = macd.ewm(span=signal_window, adjust=False).mean()
#         macd_hist = macd - signal_line
        
#         # Generate signals
#         macd_signal = pd.Series('Hold', index=df.index)
#         mask = ~pd.concat([macd, signal_line], axis=1).isna().any(axis=1)
#         macd_signal.loc[mask & (macd > signal_line)] = 'Buy'
#         macd_signal.loc[mask & (macd < signal_line)] = 'Sell'
        
#         return {
#             'EMA_short': ema_short,
#             'EMA_long': ema_long,
#             'MACD': macd,
#             'Signal_Line': signal_line,
#             'MACD_Hist': macd_hist,
#             'MACD_Signal': macd_signal
#         }
    
#     def calculate_adx(df, period=14, threshold=25):
#         """Calculate ADX and return new columns - FIXED FRAGMENTATION"""
#         try:
#             # Ensure we have the required columns
#             required_cols = ['High', 'Low', 'Close']
#             for col in required_cols:
#                 if col not in df.columns:
#                     print(f"Warning: {col} column not found in dataframe")
#                     return {'ADX_Signal': pd.Series('Hold', index=df.index)}
            
#             # Calculate True Range with NaN handling
#             hl = df['High'] - df['Low']
#             hc = abs(df['High'] - df['Close'].shift())
#             lc = abs(df['Low'] - df['Close'].shift())
            
#             tr = pd.concat([hl, hc, lc], axis=1).max(axis=1)
            
#             # Calculate Directional Movement with NaN handling
#             high_diff = df['High'] - df['High'].shift()
#             low_diff = df['Low'].shift() - df['Low']
            
#             plus_dm = high_diff.where((high_diff > low_diff) & (high_diff > 0), 0)
#             minus_dm = low_diff.where((low_diff > high_diff) & (low_diff > 0), 0)
            
#             # Calculate smoothed values with NaN handling
#             tr_smooth = tr.rolling(period, min_periods=1).sum()
#             plus_dm_smooth = plus_dm.rolling(period, min_periods=1).sum()
#             minus_dm_smooth = minus_dm.rolling(period, min_periods=1).sum()
            
#             # Calculate DI and ADX with division by zero protection
#             plus_di = 100 * plus_dm_smooth / tr_smooth.replace(0, np.nan)
#             minus_di = 100 * minus_dm_smooth / tr_smooth.replace(0, np.nan)
            
#             # Calculate DX with proper handling
#             di_sum = plus_di + minus_di
#             di_diff = abs(plus_di - minus_di)
#             dx = 100 * di_diff / di_sum.replace(0, np.nan)
            
#             # Calculate ADX
#             adx = dx.rolling(period, min_periods=1).mean()
            
#             # Generate signals with NaN protection
#             mask = ~pd.concat([adx, plus_di, minus_di], axis=1).isna().any(axis=1)
            
#             # Update signals where we have complete data
#             strong_trend_up = (adx > threshold) & (plus_di > minus_di)
#             strong_trend_down = (adx > threshold) & (plus_di < minus_di)
            
#             adx_signal = pd.Series('Hold', index=df.index)
#             adx_signal.loc[mask & strong_trend_up] = 'Buy'
#             adx_signal.loc[mask & strong_trend_down] = 'Sell'
            
#             return {
#                 'TR': tr,
#                 '+DM': plus_dm,
#                 '-DM': minus_dm,
#                 'TR_smooth': tr_smooth,
#                 '+DM_smooth': plus_dm_smooth,
#                 '-DM_smooth': minus_dm_smooth,
#                 '+DI': plus_di,
#                 '-DI': minus_di,
#                 'DX': dx,
#                 'ADX': adx,
#                 'ADX_Signal': adx_signal
#             }
            
#         except Exception as e:
#             print(f"Error in ADX calculation: {e}")
#             return {'ADX_Signal': pd.Series('Hold', index=df.index)}

#     def calculate_volume_analysis(df, **params):
#         """
#         Calculate volume analysis and return new columns.
#         This version uses the logic from the second provided function.
#         """
#         try:
#             if 'Volume' not in df.columns:
#                 print("Volume column not found, skipping volume analysis")
#                 # Menggunakan 'Low Volume' sebagai default agar konsisten dengan logika baru
#                 return {'Volume_Signal': pd.Series('Low Volume', index=df.index)}
            
#             # Ambil parameter periode moving average, defaultnya 20
#             volume_period = params.get('volume_period', 20)
            
#             # 1. Hitung Volume Moving Average (VMA)
#             vma = df['Volume'].rolling(window=volume_period).mean()
            
#             # 2. Inisialisasi kolom sinyal dengan nilai default 'Low Volume'
#             volume_signal = pd.Series('Low Volume', index=df.index)
            
#             # 3. Buat mask untuk hanya beroperasi pada baris di mana VMA tidak NaN
#             mask = ~vma.isna()
            
#             # 4. Terapkan logika inti:
#             # Ubah sinyal menjadi 'High Volume' jika Volume > VMA
#             volume_signal.loc[mask & (df['Volume'] > vma)] = 'High Volume'
            
#             print("Volume analysis applied successfully")
            
#             # Kembalikan hasil dalam format dictionary yang sama
#             return {
#                 'VMA': vma,
#                 'Volume_Signal': volume_signal
#             }
            
#         except Exception as e:
#             print(f"Error in volume analysis: {e}")
#             # Jika terjadi error, kembalikan default yang konsisten
#             return {'Volume_Signal': pd.Series('Low Volume', index=df.index)}
    

#     def calculate_fibonacci_retracement(df, lookback=60, retracement_levels=None):
#         """Calculate Fibonacci retracement and return new columns - FIXED FRAGMENTATION"""
#         if retracement_levels is None:
#             retracement_levels = [0.236, 0.382, 0.5, 0.618, 0.786]
        
#         fibonacci_signal = pd.Series('Hold', index=df.index)
#         fib_highs = []
#         fib_lows = []
#         fib_levels_list = []

#         for i in range(len(df)):
#             if i < lookback - 1:
#                 fib_highs.append(None)
#                 fib_lows.append(None)
#                 fib_levels_list.append(None)
#                 continue
            
#             try:
#                 recent = df.iloc[i - lookback + 1:i + 1]
                
#                 # Check if we have valid data
#                 if recent.empty or recent['High'].isna().all() or recent['Low'].isna().all():
#                     fib_highs.append(None)
#                     fib_lows.append(None)
#                     fib_levels_list.append(None)
#                     continue
                    
#                 high = recent['High'].max()
#                 low = recent['Low'].min()
#                 last_close = df.iloc[i]['Close']
                
#                 # Validate values
#                 if pd.isna(high) or pd.isna(low) or pd.isna(last_close) or high <= low:
#                     fib_highs.append(None)
#                     fib_lows.append(None)
#                     fib_levels_list.append(None)
#                     continue
                    
#                 levels = [high - (high - low) * r for r in retracement_levels]
                
#                 fib_highs.append(high)
#                 fib_lows.append(low)
#                 fib_levels_list.append(levels)
                
#                 # Signal logic with proper validation
#                 price_range = high - low
#                 if price_range > 0:
#                     # Check distance to key Fibonacci levels
#                     distance_618 = abs(last_close - levels[3]) / price_range if len(levels) > 3 else 1
#                     distance_786 = abs(last_close - levels[4]) / price_range if len(levels) > 4 else 1
#                     distance_236 = abs(last_close - levels[0]) / price_range if len(levels) > 0 else 1
#                     distance_382 = abs(last_close - levels[1]) / price_range if len(levels) > 1 else 1
                    
#                     if distance_618 < 0.02 or distance_786 < 0.02:
#                         fibonacci_signal.iloc[i] = 'Buy'
#                     elif distance_236 < 0.02 or distance_382 < 0.02:
#                         fibonacci_signal.iloc[i] = 'Sell'
#                     else:
#                         fibonacci_signal.iloc[i] = 'Hold'
#                 else:
#                     fibonacci_signal.iloc[i] = 'Hold'
                    
#             except Exception as e:
#                 print(f"Error in Fibonacci calculation at index {i}: {e}")
#                 fib_highs.append(None)
#                 fib_lows.append(None)
#                 fib_levels_list.append(None)
#                 fibonacci_signal.iloc[i] = 'Hold'

#         return {
#             'fib_high': pd.Series(fib_highs, index=df.index),
#             'fib_low': pd.Series(fib_lows, index=df.index),
#             'fib_levels': pd.Series(fib_levels_list, index=df.index),
#             'Fibonacci_Signal': fibonacci_signal
#         }
    
#     # Apply selected technical indicators and collect all new columns
#     if 'Bollinger_Signal' in selected_technicals:
#         window = params.get('bb_period', 20)
#         num_std = params.get('bb_std', 2)
#         print(f"Calculating Bollinger Bands with window={window}, std={num_std}")
#         bb_columns = calculate_bollinger_bands(df_copy, window=window, num_std=num_std)
#         new_columns.update(bb_columns)
#         print(f"Bollinger signal counts: {bb_columns['Bollinger_Signal'].value_counts().to_dict()}")
    
#     if 'MA_Signal' in selected_technicals:
#         short_period = params.get('ma_short', 20)
#         long_period = params.get('ma_long', 50)
#         print(f"Calculating Moving Averages with short={short_period}, long={long_period}")
#         ma_columns = calculate_ma(df_copy, short_period=short_period, long_period=long_period)
#         new_columns.update(ma_columns)
#         print(f"MA signal counts: {ma_columns['MA_Signal'].value_counts().to_dict()}")
    
#     if 'RSI_Signal' in selected_technicals:
#         period = params.get('rsi_period', 14)
#         ob_level = params.get('rsi_overbought', 70)
#         os_level = params.get('rsi_oversold', 30)
#         print(f"Calculating RSI with period={period}, overbought={ob_level}, oversold={os_level}")
#         rsi_columns = calculate_rsi(df_copy, period=period, ob_level=ob_level, os_level=os_level)
#         new_columns.update(rsi_columns)
#         print(f"RSI signal counts: {rsi_columns['RSI_Signal'].value_counts().to_dict()}")
    
#     if 'MACD_Signal' in selected_technicals:
#         fast = params.get('macd_fast', 12)
#         slow = params.get('macd_slow', 26)
#         signal = params.get('macd_signal', 9)
#         print(f"Calculating MACD with fast={fast}, slow={slow}, signal={signal}")
#         macd_columns = calculate_macd(df_copy, short_window=fast, long_window=slow, signal_window=signal)
#         new_columns.update(macd_columns)
#         print(f"MACD signal counts: {macd_columns['MACD_Signal'].value_counts().to_dict()}")
    
#     if 'ADX_Signal' in selected_technicals:
#         period = params.get('adx_period', 14)
#         threshold = params.get('adx_threshold', 25)
#         print(f"Calculating ADX with period={period}, threshold={threshold}")
#         adx_columns = calculate_adx(df_copy, period=period, threshold=threshold)
#         new_columns.update(adx_columns)
#         print(f"ADX signal counts: {adx_columns['ADX_Signal'].value_counts().to_dict()}")
    
#     if 'Volume_Signal' in selected_technicals:
#         ma_window = params.get('volume_window', 20)
#         print(f"Calculating Volume analysis with window={ma_window}")
#         df_copy = calculate_volume_analysis(df_copy, ma_window=ma_window)
#         new_columns['Volume_Signal'] = df_copy['Volume_Signal']
#         new_columns['VMA'] = df_copy['VMA']
#         print(f"Volume signal counts: {df_copy['Volume_Signal'].value_counts().to_dict()}")
    
#     if 'Fibonacci_Signal' in selected_technicals:
#         lookback = params.get('fibonacci_lookback', 60)
#         print(f"Calculating Fibonacci with lookback={lookback}")
#         fib_columns = calculate_fibonacci_retracement(df_copy, lookback=lookback)
#         new_columns.update(fib_columns)
#         print(f"Fibonacci signal counts: {fib_columns['Fibonacci_Signal'].value_counts().to_dict()}")
    
#     if 'Candlestick_Signal' in selected_technicals:
#         print("Calculating Candlestick Trend (as confirmation)")
#         candlestick_trend = calculate_candlestick_trend(df_copy)
#         new_columns['Candlestick_Trend'] = candlestick_trend  # Trend, bukan signal
#         print(f"Candlestick trend counts: {candlestick_trend.value_counts().to_dict()}")
    
#     # Apply the original combined signal (BACKWARD COMPATIBILITY)
#     if len(selected_technicals) > 0:
#         print("Calculating original combined signal from indicators")
#         # Only add combined signal if we have signal columns
#         signal_columns = [col for col in new_columns.keys() if col.endswith('_Signal')]
#         if signal_columns:
#             # Create a temporary df with current signals for combined calculation
#             temp_df = df_copy.copy()
#             for col_name, col_data in new_columns.items():
#                 if col_name.endswith('_Signal'):
#                     temp_df[col_name] = col_data
            
#             combined_signal = calculate_combined_signal_only(temp_df, selected_technicals)
#             if combined_signal is not None:
#                 new_columns['Combined_Signal'] = combined_signal
#                 print(f"Combined signal counts: {combined_signal.value_counts().to_dict()}")
    
#     # # Apply enhanced combined signals with voting system (NEW FEATURE)
#     # if len(selected_technicals) >= 2:
#     #     print("ðŸ—³ï¸ Applying enhanced voting system for multiple combinations...")
#     #     # Create temp df with all current signals
#     #     temp_df = df_copy.copy()
#     #     for col_name, col_data in new_columns.items():
#     #         if col_name.endswith('_Signal'):
#     #             temp_df[col_name] = col_data
        
#     #     enhanced_signals = apply_enhanced_combined_signals_only(temp_df, selected_technicals)
#     #     new_columns.update(enhanced_signals)
        
#     #     # Print new combined signals that were created
#     #     new_combined_cols = [col for col in enhanced_signals.keys() if col.endswith('_Combined_Signal') and col != 'Combined_Signal']
#     #     print(f"âœ… Created {len(new_combined_cols)} voting-based combined signals:")
#     #     for col in new_combined_cols:
#     #         if col in enhanced_signals:
#     #             signal_counts = enhanced_signals[col].value_counts().to_dict()
#     #             print(f"   ðŸ“Š {col}: {signal_counts}")
    
#     # # FIXED: Use pd.concat to add all new columns at once to avoid fragmentation
#     # if new_columns:
#     #     # Convert new_columns dict to DataFrame
#     #     new_columns_df = pd.DataFrame(new_columns, index=df_copy.index)
        
#     #     # Concatenate original DataFrame with new columns
#     #     df_result = pd.concat([df_copy, new_columns_df], axis=1)
        
#     #     print(f"Successfully added {len(new_columns)} new columns using pd.concat")
#     #     return df_result
#     # else:
#     #     return df_copy

#     if len(selected_technicals) > 0:
#         print("Calculating simple combined signal from indicators")
#         combined_signal = calculate_combined_signal_only(df_copy, selected_technicals)
#         if combined_signal is not None:
#             new_columns['Combined_Signal'] = combined_signal
#             print(f"Simple combined signal counts: {combined_signal.value_counts().to_dict()}")
    
#     # Apply enhanced combined signals dengan konfirmasi
#     if len(selected_technicals) >= 2:
#         print("ðŸ”— Applying enhanced combined signals with confirmations...")
#         df_copy = apply_enhanced_combined_signals(df_copy, selected_technicals)
        
#         # Add combined signal columns to new_columns
#         combined_cols = [col for col in df_copy.columns if col.endswith('_Combined_Signal')]
#         for col in combined_cols:
#             new_columns[col] = df_copy[col]
    
#     # Add all new columns at once
#     if new_columns:
#         for col_name, col_data in new_columns.items():
#             df_copy[col_name] = col_data
#         print(f"âœ… Successfully added {len(new_columns)} new columns")
#     else:
#         print("âš ï¸ No new columns to add")
    
#     return df_copy






# def apply_technical_indicators(df, selected_technicals, **params):
#     """Apply technical indicators - UPDATED untuk konsisten menggunakan trend"""
#     print(f"Applying {len(selected_technicals)} technical indicator(s) to data with {len(df)} rows")
#     print(f"Selected indicators: {selected_technicals}")
#     print(f"Parameters: {params}")
    
#     if df.empty:
#         print("WARNING: DataFrame is empty, cannot apply indicators")
#         return df
    
#     # Make a copy to avoid modifying the original
#     df_copy = df.copy()

#     new_columns = {}
    
#     # Helper functions untuk calculate indicators (tetap sama)
#     def calculate_bollinger_bands(df, window=20, num_std=2):
#         df['Middle Band'] = df['Close'].rolling(window=window).mean()
#         df['STD'] = df['Close'].rolling(window=window).std()
#         df['Upper Band'] = df['Middle Band'] + (num_std * df['STD'])
#         df['Lower Band'] = df['Middle Band'] - (num_std * df['STD'])
#         df['Bollinger_Signal'] = 'Hold'
#         mask = ~df[['Upper Band', 'Lower Band', 'Middle Band']].isna().any(axis=1)
#         df.loc[mask & (df['Close'] >= df['Upper Band']), 'Bollinger_Signal'] = 'Sell'
#         df.loc[mask & (df['Close'] <= df['Lower Band']), 'Bollinger_Signal'] = 'Buy'
#         return df

#     def calculate_ma(df, short_period=20, long_period=50):
#         df['short_MA'] = df['Close'].rolling(window=short_period).mean()
#         df['long_MA'] = df['Close'].rolling(window=long_period).mean()
#         df['MA_Signal'] = 'Hold'
#         mask = ~df[['short_MA', 'long_MA']].isna().any(axis=1)
#         df.loc[mask & (df['short_MA'] > df['long_MA']), 'MA_Signal'] = 'Buy'
#         df.loc[mask & (df['short_MA'] < df['long_MA']), 'MA_Signal'] = 'Sell'
#         return df

#     def calculate_rsi(df, period=14, ob_level=70, os_level=30):
#         delta = df['Close'].diff()
#         gain = delta.where(delta > 0, 0)
#         loss = -delta.where(delta < 0, 0)
#         avg_gain = gain.rolling(window=period).mean()
#         avg_loss = loss.rolling(window=period).mean()
#         rs = avg_gain / avg_loss
#         df['RSI'] = 100 - (100 / (1 + rs))
#         df['RSI_Signal'] = 'Hold'
#         mask = ~df['RSI'].isna()
#         df.loc[mask & (df['RSI'] > ob_level), 'RSI_Signal'] = 'Sell'
#         df.loc[mask & (df['RSI'] < os_level), 'RSI_Signal'] = 'Buy'
#         return df

#     def calculate_macd(df, short_window=12, long_window=26, signal_window=9):
#         df['EMA_short'] = df['Close'].ewm(span=short_window, adjust=False).mean()
#         df['EMA_long'] = df['Close'].ewm(span=long_window, adjust=False).mean()
#         df['MACD'] = df['EMA_short'] - df['EMA_long']
#         df['Signal_Line'] = df['MACD'].ewm(span=signal_window, adjust=False).mean()
#         df['MACD_Hist'] = df['MACD'] - df['Signal_Line']
#         df['MACD_Signal'] = 'Hold'
#         mask = ~df[['MACD', 'Signal_Line']].isna().any(axis=1)
#         df.loc[mask & (df['MACD'] > df['Signal_Line']), 'MACD_Signal'] = 'Buy'
#         df.loc[mask & (df['MACD'] < df['Signal_Line']), 'MACD_Signal'] = 'Sell'
#         return df
    
#     def calculate_adx(df, period=14, threshold=25):
#         high = df['High']
#         low = df['Low']
#         close = df['Close']
        
#         plus_dm = high.diff()
#         minus_dm = low.diff()
#         plus_dm[plus_dm < 0] = 0
#         minus_dm[minus_dm > 0] = 0
#         minus_dm = minus_dm.abs()
        
#         tr1 = pd.DataFrame(high - low).rename(columns={'High': 'tr1'})
#         tr2 = pd.DataFrame(abs(high - close.shift(1))).rename(columns={'High': 'tr2'})
#         tr3 = pd.DataFrame(abs(low - close.shift(1))).rename(columns={'Low': 'tr3'})
#         frames = [tr1, tr2, tr3]
#         tr = pd.concat(frames, axis=1, join='inner').max(axis=1)
#         atr = tr.rolling(period).mean()
        
#         plus_di = 100 * (plus_dm.ewm(alpha=1/period).mean() / atr)
#         minus_di = 100 * (minus_dm.ewm(alpha=1/period).mean() / atr)
#         dx = (abs(plus_di - minus_di) / abs(plus_di + minus_di)) * 100
#         adx = ((dx.shift(1) * (period - 1)) + dx) / period
#         adx_smooth = adx.ewm(alpha=1/period).mean()
        
#         df['ADX'] = adx_smooth
#         df['+DI'] = plus_di
#         df['-DI'] = minus_di
        
#         df['ADX_Signal'] = 'Hold'
#         mask = ~adx_smooth.isna()
#         df.loc[mask & (adx_smooth > threshold) & (plus_di > minus_di), 'ADX_Signal'] = 'Buy'
#         df.loc[mask & (adx_smooth > threshold) & (minus_di > plus_di), 'ADX_Signal'] = 'Sell'
#         return df

#     def calculate_fibonacci_retracement(df, lookback=60, retracement_levels=None):
#         """Calculate Fibonacci Retracement - FIXED ERROR HANDLING"""
#         if retracement_levels is None:
#             retracement_levels = [0.236, 0.382, 0.5, 0.618, 0.786]
        
#         df['Fibonacci_Signal'] = 'Hold'
        
#         for i in range(lookback, len(df)):
#             try:
#                 recent_data = df.iloc[i-lookback:i+1]
#                 high_price = recent_data['High'].max()
#                 low_price = recent_data['Low'].min()
#                 current_price = df.iloc[i]['Close']
                
#                 fib_levels = {}
#                 for level in retracement_levels:
#                     fib_levels[level] = high_price - (high_price - low_price) * level
                
#                 if current_price <= fib_levels[0.618] and current_price >= fib_levels[0.786]:
#                     df.iloc[i, df.columns.get_loc('Fibonacci_Signal')] = 'Buy'
#                 elif current_price >= fib_levels[0.236] and current_price <= fib_levels[0.382]:
#                     df.iloc[i, df.columns.get_loc('Fibonacci_Signal')] = 'Sell'
                    
#             except Exception as e:
#                 continue
                
#         return df

#     def calculate_volume(df, ma_window=20):
#         # Initialize signal column
#         df['VolumeSignal'] = 'Low Volume'
        
#         # Calculate Volume Moving Average
#         df['VMA'] = df['Volume'].rolling(window=ma_window).mean()
        
#         # Generate signals only where we have VMA
#         mask = ~df['VMA'].isna()
        
#         # Update signals where we have complete data
#         df.loc[mask & (df['Volume'] > df['VMA']), 'VolumeSignal'] = 'High Volume'
        
#         # Add Volume_Signal column untuk konsistensi dengan naming convention
#         df['Volume_Signal'] = df['VolumeSignal']
        
#         return df
    
#     # Apply selected technical indicators
#     if 'Bollinger_Signal' in selected_technicals:
#         window = params.get('bb_period', 20)
#         num_std = params.get('bb_std', 2)
#         print(f"Calculating Bollinger Bands with window={window}, std={num_std}")
#         df_copy = calculate_bollinger_bands(df_copy, window=window, num_std=num_std)
#         print(f"Bollinger signal counts: {df_copy['Bollinger_Signal'].value_counts().to_dict()}")
    
#     if 'MA_Signal' in selected_technicals:
#         short_period = params.get('ma_short', 20)
#         long_period = params.get('ma_long', 50)
#         print(f"Calculating Moving Averages with short={short_period}, long={long_period}")
#         df_copy = calculate_ma(df_copy, short_period=short_period, long_period=long_period)
#         print(f"MA signal counts: {df_copy['MA_Signal'].value_counts().to_dict()}")
    
#     if 'RSI_Signal' in selected_technicals:
#         period = params.get('rsi_period', 14)
#         ob_level = params.get('rsi_overbought', 70)
#         os_level = params.get('rsi_oversold', 30)
#         print(f"Calculating RSI with period={period}, overbought={ob_level}, oversold={os_level}")
#         df_copy = calculate_rsi(df_copy, period=period, ob_level=ob_level, os_level=os_level)
#         print(f"RSI signal counts: {df_copy['RSI_Signal'].value_counts().to_dict()}")
    
#     if 'MACD_Signal' in selected_technicals:
#         fast = params.get('macd_fast', 12)
#         slow = params.get('macd_slow', 26)
#         signal = params.get('macd_signal', 9)
#         print(f"Calculating MACD with fast={fast}, slow={slow}, signal={signal}")
#         df_copy = calculate_macd(df_copy, short_window=fast, long_window=slow, signal_window=signal)
#         print(f"MACD signal counts: {df_copy['MACD_Signal'].value_counts().to_dict()}")
    
#     if 'ADX_Signal' in selected_technicals:
#         period = params.get('adx_period', 14)
#         threshold = params.get('adx_threshold', 25)
#         print(f"Calculating ADX with period={period}, threshold={threshold}")
#         df_copy = calculate_adx(df_copy, period=period, threshold=threshold)
#         print(f"ADX signal counts: {df_copy['ADX_Signal'].value_counts().to_dict()}")
    
#     if 'Volume_Signal' in selected_technicals:
#         ma_window = params.get('volume_window', 20)
#         print(f"Calculating Volume analysis with window={ma_window}")
#         df_copy = calculate_volume(df_copy, ma_window=ma_window)
#         print(f"Volume signal counts: {df_copy['Volume_Signal'].value_counts().to_dict()}")
    
#     if 'Fibonacci_Signal' in selected_technicals:
#         lookback = params.get('fibonacci_lookback', 60)
#         print(f"Calculating Fibonacci with lookback={lookback}")
#         df_copy = calculate_fibonacci_retracement(df_copy, lookback=lookback)
#         print(f"Fibonacci signal counts: {df_copy['Fibonacci_Signal'].value_counts().to_dict()}")
    
#     # if 'Candlestick_Signal' in selected_technicals:
#     #     print("Calculating Candlestick Trend (Uptrend/Downtrend/Sideways)")
#     #     candlestick_trend = calculate_candlestick_trend(df_copy)
        
#     #     # FIXED: Gunakan Candlestick_Trend sebagai kolom utama, bukan Candlestick_Signal
#     #     df_copy['Candlestick_Trend'] = candlestick_trend
        
#     #     # Untuk kompatibilitas dengan sistem voting, buat kolom Candlestick_Signal yang berisi trend value
#     #     df_copy['Candlestick_Signal'] = candlestick_trend  # Signal = Trend value langsung
        
#     #     print(f"Candlestick trend counts: {candlestick_trend.value_counts().to_dict()}")
#     #     print(f"Candlestick signal counts: {df_copy['Candlestick_Signal'].value_counts().to_dict()}")

#     if 'Candlestick_Signal' in selected_technicals:
#         print("Calculating Candlestick Patterns")
#         from Candlestick_pattern import detect_candlestick_patterns
        
#         # Run the candlestick pattern detection
#         candlestick_df = detect_candlestick_patterns(df_copy)
        
#         # Extract only the columns we need
#         new_columns['detected_patterns'] = candlestick_df['detected_patterns']
#         new_columns['candlestick_trend'] = candlestick_df['candlestick_trend']
#         new_columns['candlestick_confidence'] = candlestick_df['candlestick_confidence']
        
#         # Map candlestick trend to signal
#         # This creates a traditional Buy/Sell/Hold signal based on trend
#         candlestick_signal = pd.Series('Hold', index=df_copy.index)
#         candlestick_signal.loc[candlestick_df['candlestick_trend'] == 'Uptrend'] = 'Buy'
#         candlestick_signal.loc[candlestick_df['candlestick_trend'] == 'Downtrend'] = 'Sell'
        
#         # Add the signal to new columns
#         new_columns['Candlestick_Signal'] = candlestick_signal

#         print(f"Candlestick trend counts: {candlestick_df['candlestick_trend'].value_counts().to_dict()}")

#         print(f"Candlestick signal counts: {candlestick_signal.value_counts().to_dict()}")
    
#     # Apply combined signal (simple) - BACKWARD COMPATIBILITY
#     if len(selected_technicals) > 0:
#         print("Calculating simple combined signal from indicators")
#         df_copy = calculate_combined_signal(df_copy, selected_technicals)
#         print(f"Combined signal counts: {df_copy['Combined_Signal'].value_counts().to_dict()}")
    
#     # Apply enhanced combined signals untuk SEMUA kombinasi yang mungkin
#     if len(selected_technicals) >= 2:
#         print("ðŸ”— Applying enhanced combined signals with ALL POSSIBLE COMBINATIONS...")
#         df_copy = apply_enhanced_combined_signals(df_copy, selected_technicals)
        
#         # Print kombinasi yang dibuat
#         combined_cols = [col for col in df_copy.columns if col.endswith('_Combined_Signal') and col != 'Combined_Signal']
#         for col in combined_cols:
#             print(f"âœ… {col} signal counts: {df_copy[col].value_counts().to_dict()}")
    
#     if new_columns:
#         for col_name, col_data in new_columns.items():
#             df_copy[col_name] = col_data
#         print(f"âœ… Successfully added {len(new_columns)} new columns")
#     else:
#         print("âš ï¸ No new columns to add")
    
#     print(f"ðŸ” DEBUG: Final DataFrame columns: {df_copy.columns.tolist()}")
#     return df_copy





def apply_technical_indicators(df, selected_technicals, **params):
    """Apply technical indicators - FIXED untuk memastikan candlestick_trend masuk ke df"""
    print(f"Applying {len(selected_technicals)} technical indicator(s) to data with {len(df)} rows")
    print(f"Selected indicators: {selected_technicals}")
    print(f"Parameters: {params}")
    
    if df.empty:
        print("WARNING: DataFrame is empty, cannot apply indicators")
        return df
    
    # Make a copy to avoid modifying the original
    df_copy = df.copy()
    
    # Dictionary untuk menyimpan semua kolom baru
    new_columns = {}
    
    # Helper functions untuk calculate indicators (simplified versions)
    def calculate_bollinger_bands(df, window=20, num_std=2, bb_signal_mode='touch'):
        # Kalkulasi dasar Bollinger Bands
        middle_band = df['Close'].rolling(window=window).mean()
        std = df['Close'].rolling(window=window).std()
        upper_band = middle_band + (num_std * std)
        lower_band = middle_band - (num_std * std)
        
        # Inisialisasi sinyal
        bollinger_signal = pd.Series('Hold', index=df.index)
        
        # Buat mask untuk memastikan kita hanya bekerja pada data yang valid (non-NaN)
        mask = ~pd.concat([upper_band, lower_band, middle_band], axis=1).isna().any(axis=1)
        
        if bb_signal_mode == 'touch':
            # Logika asli: sinyal saat harga menyentuh atau melewati band
            bollinger_signal.loc[mask & (df['Close'] >= upper_band)] = 'Sell'
            bollinger_signal.loc[mask & (df['Close'] <= lower_band)] = 'Buy'
            
        elif bb_signal_mode == 'cross':
            # Logika baru: sinyal saat harga menembus band
            # Sinyal Jual: Harga kemarin di bawah Upper Band, harga hari ini di atas Upper Band
            prev_below_upper = df['Close'].shift(1) < upper_band.shift(1)
            current_above_upper = df['Close'] > upper_band
            cross_above_upper = prev_below_upper & current_above_upper
            
            # Sinyal Beli: Harga kemarin di atas Lower Band, harga hari ini di bawah Lower Band
            prev_above_lower = df['Close'].shift(1) > lower_band.shift(1)
            current_below_lower = df['Close'] < lower_band
            cross_below_lower = prev_above_lower & current_below_lower
            
            bollinger_signal.loc[mask & cross_above_upper] = 'Sell'
            bollinger_signal.loc[mask & cross_below_lower] = 'Buy'
            
        return {
            'Middle Band': middle_band,
            'STD': std,
            'Upper Band': upper_band,
            'Lower Band': lower_band,
            'Bollinger_Signal': bollinger_signal
        }

    def calculate_ma(df, short_period=20, long_period=50, medium_period=35, ma_lines_count='2'):
        # Inisialisasi sinyal
        ma_signal = pd.Series('Hold', index=df.index)
        
        # Kalkulasi MA dasar
        short_ma = df['Close'].rolling(window=short_period).mean()
        long_ma = df['Close'].rolling(window=long_period).mean()
        
        # Siapkan dictionary hasil, akan diisi sesuai mode
        result_dict = {
            'short_MA': short_ma,
            'long_MA': long_ma
        }
        
        if ma_lines_count == '3':
            # Mode 3 Garis MA
            medium_ma = df['Close'].rolling(window=medium_period).mean()
            result_dict['medium_MA'] = medium_ma # Tambahkan ke hasil
            
            # Mask untuk memastikan semua 3 MA valid
            mask = ~pd.concat([short_ma, medium_ma, long_ma], axis=1).isna().any(axis=1)
            
            # Sinyal Beli (Bullish): MA tersusun berurutan dari cepat ke lambat (atas ke bawah)
            bullish_alignment = (short_ma > medium_ma) & (medium_ma > long_ma)
            
            # Sinyal Jual (Bearish): MA tersusun terbalik (bawah ke atas)
            bearish_alignment = (short_ma < medium_ma) & (medium_ma < long_ma)
            
            ma_signal.loc[mask & bullish_alignment] = 'Buy'
            ma_signal.loc[mask & bearish_alignment] = 'Sell'
            
        else: # Default ke mode 2 Garis MA
            # Mask untuk memastikan 2 MA valid
            mask = ~pd.concat([short_ma, long_ma], axis=1).isna().any(axis=1)
            
            # Sinyal Beli: MA cepat memotong ke atas MA lambat
            ma_signal.loc[mask & (short_ma > long_ma)] = 'Buy'
            
            # Sinyal Jual: MA cepat memotong ke bawah MA lambat
            ma_signal.loc[mask & (short_ma < long_ma)] = 'Sell'

        # Tambahkan sinyal yang sudah jadi ke dictionary hasil
        result_dict['MA_Signal'] = ma_signal
        
        return result_dict
    

    def calculate_rsi(df, period=14, ob_level=70, os_level=30):
        """Calculate RSI and return new columns"""
        delta = df['Close'].diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)
        avg_gain = gain.rolling(window=period).mean()
        avg_loss = loss.rolling(window=period).mean()
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        # Generate signals
        rsi_signal = pd.Series('Hold', index=df.index)
        mask = ~rsi.isna()
        rsi_signal.loc[mask & (rsi > ob_level)] = 'Sell'
        rsi_signal.loc[mask & (rsi < os_level)] = 'Buy'
        
        return {
            'RSI': rsi,
            'RSI_Signal': rsi_signal
        }

    def calculate_macd(df, short_window=12, long_window=26, signal_window=9):
        """Calculate MACD and return new columns"""
        ema_short = df['Close'].ewm(span=short_window, adjust=False).mean()
        ema_long = df['Close'].ewm(span=long_window, adjust=False).mean()
        macd = ema_short - ema_long
        signal_line = macd.ewm(span=signal_window, adjust=False).mean()
        macd_hist = macd - signal_line
        
        # Generate signals
        macd_signal = pd.Series('Hold', index=df.index)
        mask = ~pd.concat([macd, signal_line], axis=1).isna().any(axis=1)
        macd_signal.loc[mask & (macd > signal_line)] = 'Buy'
        macd_signal.loc[mask & (macd < signal_line)] = 'Sell'
        
        return {
            'EMA_short': ema_short,
            'EMA_long': ema_long,
            'MACD': macd,
            'Signal_Line': signal_line,
            'MACD_Hist': macd_hist,
            'MACD_Signal': macd_signal
        }
    
    def calculate_adx(df, period=14, threshold=25):
        """Calculate ADX and return new columns"""
        try:
            # Ensure we have the required columns
            required_cols = ['High', 'Low', 'Close']
            for col in required_cols:
                if col not in df.columns:
                    print(f"Warning: {col} column not found in dataframe")
                    return {'ADX_Signal': pd.Series('Hold', index=df.index)}
            
            # Calculate True Range
            hl = df['High'] - df['Low']
            hc = abs(df['High'] - df['Close'].shift())
            lc = abs(df['Low'] - df['Close'].shift())
            tr = pd.concat([hl, hc, lc], axis=1).max(axis=1)
            
            # Calculate Directional Movement
            high_diff = df['High'] - df['High'].shift()
            low_diff = df['Low'].shift() - df['Low']
            plus_dm = high_diff.where((high_diff > low_diff) & (high_diff > 0), 0)
            minus_dm = low_diff.where((low_diff > high_diff) & (low_diff > 0), 0)
            
            # Calculate smoothed values
            tr_smooth = tr.rolling(period, min_periods=1).sum()
            plus_dm_smooth = plus_dm.rolling(period, min_periods=1).sum()
            minus_dm_smooth = minus_dm.rolling(period, min_periods=1).sum()
            
            # Calculate DI and ADX
            plus_di = 100 * plus_dm_smooth / tr_smooth.replace(0, np.nan)
            minus_di = 100 * minus_dm_smooth / tr_smooth.replace(0, np.nan)
            di_sum = plus_di + minus_di
            di_diff = abs(plus_di - minus_di)
            dx = 100 * di_diff / di_sum.replace(0, np.nan)
            adx = dx.rolling(period, min_periods=1).mean()
            
            # Generate signals
            mask = ~pd.concat([adx, plus_di, minus_di], axis=1).isna().any(axis=1)
            strong_trend_up = (adx > threshold) & (plus_di > minus_di)
            strong_trend_down = (adx > threshold) & (plus_di < minus_di)
            
            adx_signal = pd.Series('Hold', index=df.index)
            adx_signal.loc[mask & strong_trend_up] = 'Buy'
            adx_signal.loc[mask & strong_trend_down] = 'Sell'
            
            return {
                'ADX': adx,
                '+DI': plus_di,
                '-DI': minus_di,
                'ADX_Signal': adx_signal
            }
            
        except Exception as e:
            print(f"Error in ADX calculation: {e}")
            return {'ADX_Signal': pd.Series('Hold', index=df.index)}

    def calculate_volume_analysis(df, volume_period=20):
        """Calculate volume analysis and return new columns"""
        try:
            if 'Volume' not in df.columns:
                print("Volume column not found, skipping volume analysis")
                return {'Volume_Signal': pd.Series('Low Volume', index=df.index)}
            
            # Calculate Volume Moving Average (VMA)
            vma = df['Volume'].rolling(window=volume_period).mean()
            
            # Initialize signal column
            volume_signal = pd.Series('Low Volume', index=df.index)
            
            # Create mask for valid data
            mask = ~vma.isna()
            
            # Apply logic: High Volume if Volume > VMA
            volume_signal.loc[mask & (df['Volume'] > vma)] = 'High Volume'
            
            return {
                'VMA': vma,
                'Volume_Signal': volume_signal
            }
            
        except Exception as e:
            print(f"Error in volume analysis: {e}")
            return {'Volume_Signal': pd.Series('Low Volume', index=df.index)}

    def calculate_fibonacci_retracement(df, lookback=60, retracement_levels=None):
        """Calculate Fibonacci retracement and return new columns"""
        if retracement_levels is None:
            retracement_levels = [0.236, 0.382, 0.5, 0.618, 0.786]
        
        fibonacci_signal = pd.Series('Hold', index=df.index)
        fib_highs = []
        fib_lows = []
        fib_levels_list = []

        for i in range(len(df)):
            if i < lookback - 1:
                fib_highs.append(None)
                fib_lows.append(None)
                fib_levels_list.append(None)
                continue
            
            try:
                recent = df.iloc[i - lookback + 1:i + 1]
                
                if recent.empty or recent['High'].isna().all() or recent['Low'].isna().all():
                    fib_highs.append(None)
                    fib_lows.append(None)
                    fib_levels_list.append(None)
                    continue
                    
                high = recent['High'].max()
                low = recent['Low'].min()
                last_close = df.iloc[i]['Close']
                
                if pd.isna(high) or pd.isna(low) or pd.isna(last_close) or high <= low:
                    fib_highs.append(None)
                    fib_lows.append(None)
                    fib_levels_list.append(None)
                    continue
                    
                levels = [high - (high - low) * r for r in retracement_levels]
                
                fib_highs.append(high)
                fib_lows.append(low)
                fib_levels_list.append(levels)
                
                # Signal logic
                price_range = high - low
                if price_range > 0:
                    distance_618 = abs(last_close - levels[3]) / price_range if len(levels) > 3 else 1
                    distance_786 = abs(last_close - levels[4]) / price_range if len(levels) > 4 else 1
                    distance_236 = abs(last_close - levels[0]) / price_range if len(levels) > 0 else 1
                    distance_382 = abs(last_close - levels[1]) / price_range if len(levels) > 1 else 1
                    
                    if distance_618 < 0.02 or distance_786 < 0.02:
                        fibonacci_signal.iloc[i] = 'Buy'
                    elif distance_236 < 0.02 or distance_382 < 0.02:
                        fibonacci_signal.iloc[i] = 'Sell'
                    else:
                        fibonacci_signal.iloc[i] = 'Hold'
                else:
                    fibonacci_signal.iloc[i] = 'Hold'
                    
            except Exception as e:
                print(f"Error in Fibonacci calculation at index {i}: {e}")
                fib_highs.append(None)
                fib_lows.append(None)
                fib_levels_list.append(None)
                fibonacci_signal.iloc[i] = 'Hold'

        return {
            'fib_high': pd.Series(fib_highs, index=df.index),
            'fib_low': pd.Series(fib_lows, index=df.index),
            'fib_levels': pd.Series(fib_levels_list, index=df.index),
            'Fibonacci_Signal': fibonacci_signal
        }
    
    # Apply selected technical indicators
    if 'Bollinger_Signal' in selected_technicals:
        # Ambil parameter standar
        window = params.get('bb_period', 20)
        num_std = params.get('bb_std', 2)
        # Ambil parameter BARU: Signal Mode
        bb_signal_mode = params.get('bb_signal_mode', 'touch') # ID dari dcc.RadioItems: 'bb-signal-mode'
        
        print(f"Calculating Bollinger Bands with window={window}, std={num_std}, mode='{bb_signal_mode}'")
        
        # Panggil fungsi dengan semua parameter yang diperlukan
        bb_columns = calculate_bollinger_bands(df_copy, window=window, num_std=num_std, bb_signal_mode=bb_signal_mode)
        
        new_columns.update(bb_columns)
        print(f"Bollinger signal counts: {bb_columns['Bollinger_Signal'].value_counts().to_dict()}")

    if 'MA_Signal' in selected_technicals:
        # Ambil parameter standar
        short_period = params.get('ma_short', 20)
        long_period = params.get('ma_long', 50)
        # Ambil parameter BARU: MA Lines Count dan Medium Period
        ma_lines_count = params.get('ma_lines_count', '2')    # ID dari dcc.RadioItems: 'ma-lines-count'
        medium_period = params.get('ma_medium', 35)      # ID dari dcc.Input: 'ma-medium'

        print(f"Calculating Moving Averages ({ma_lines_count}-line system) with periods: short={short_period}, medium={medium_period}, long={long_period}")
        
        # Panggil fungsi dengan semua parameter yang diperlukan
        ma_columns = calculate_ma(df_copy, 
                                short_period=short_period, 
                                long_period=long_period, 
                                medium_period=medium_period, 
                                ma_lines_count=ma_lines_count)
                                
        new_columns.update(ma_columns)
        print(f"MA signal counts: {ma_columns['MA_Signal'].value_counts().to_dict()}")
    
    if 'RSI_Signal' in selected_technicals:
        period = params.get('rsi_period', 14)
        ob_level = params.get('rsi_overbought', 70)
        os_level = params.get('rsi_oversold', 30)
        print(f"Calculating RSI with period={period}, overbought={ob_level}, oversold={os_level}")
        rsi_columns = calculate_rsi(df_copy, period=period, ob_level=ob_level, os_level=os_level)
        new_columns.update(rsi_columns)
        print(f"RSI signal counts: {rsi_columns['RSI_Signal'].value_counts().to_dict()}")
    
    if 'MACD_Signal' in selected_technicals:
        fast = params.get('macd_fast', 12)
        slow = params.get('macd_slow', 26)
        signal = params.get('macd_signal', 9)
        print(f"Calculating MACD with fast={fast}, slow={slow}, signal={signal}")
        macd_columns = calculate_macd(df_copy, short_window=fast, long_window=slow, signal_window=signal)
        new_columns.update(macd_columns)
        print(f"MACD signal counts: {macd_columns['MACD_Signal'].value_counts().to_dict()}")
    
    if 'ADX_Signal' in selected_technicals:
        period = params.get('adx_period', 14)
        threshold = params.get('adx_threshold', 25)
        print(f"Calculating ADX with period={period}, threshold={threshold}")
        adx_columns = calculate_adx(df_copy, period=period, threshold=threshold)
        new_columns.update(adx_columns)
        print(f"ADX signal counts: {adx_columns['ADX_Signal'].value_counts().to_dict()}")
    
    if 'Volume_Signal' in selected_technicals:
        volume_period = params.get('volume_period', 20)
        print(f"Calculating Volume analysis with period={volume_period}")
        volume_columns = calculate_volume_analysis(df_copy, volume_period=volume_period)
        new_columns.update(volume_columns)
        print(f"Volume signal counts: {volume_columns['Volume_Signal'].value_counts().to_dict()}")
    
    if 'Fibonacci_Signal' in selected_technicals:
        lookback = params.get('fibonacci_lookback', 60)
        print(f"Calculating Fibonacci with lookback={lookback}")
        fib_columns = calculate_fibonacci_retracement(df_copy, lookback=lookback)
        new_columns.update(fib_columns)
        print(f"Fibonacci signal counts: {fib_columns['Fibonacci_Signal'].value_counts().to_dict()}")
    
    # FIXED: Pastikan candlestick_trend masuk ke dalam new_columns untuk ditambahkan ke df
    if 'Candlestick_Signal' in selected_technicals:
        from Candlestick_pattern import detect_candlestick_patterns
        print("Calculating Candlestick Trend (Uptrend/Downtrend/Sideways)")
        candlestick_df = detect_candlestick_patterns(df_copy)
        
        # FIXED: Pastikan candlestick trend tersimpan di new_columns
        

        new_columns['detected_patterns'] = candlestick_df['detected_patterns']
        new_columns['candlestick_trend'] = candlestick_df['candlestick_trend']

        new_columns['candlestick_confidence'] = candlestick_df['candlestick_confidence']
        
        # Map candlestick trend to signal
        # This creates a traditional Buy/Sell/Hold signal based on trend
        candlestick_signal = pd.Series('Hold', index=df_copy.index)
        candlestick_signal.loc[candlestick_df['candlestick_trend'] == 'Uptrend'] = 'Buy'
        candlestick_signal.loc[candlestick_df['candlestick_trend'] == 'Downtrend'] = 'Sell'
        
        # Add the signal to new columns
        new_columns['Candlestick_Signal'] = candlestick_signal
        
    
    # Apply combined signal (simple) - BACKWARD COMPATIBILITY
    if len(selected_technicals) > 0:
        print("Calculating simple combined signal from indicators")
        combined_signal = calculate_combined_signal_only(df_copy, selected_technicals)
        if combined_signal is not None:
            new_columns['Combined_Signal'] = combined_signal
            print(f"Simple combined signal counts: {combined_signal.value_counts().to_dict()}")
    
    # FIXED: Tambahkan semua kolom ke df_copy SEBELUM voting system
    if new_columns:
        for col_name, col_data in new_columns.items():
            df_copy[col_name] = col_data
        print(f"âœ… Successfully added {len(new_columns)} new columns to df_copy")
        
        # DEBUG: Print candlestick trend availability
        if 'candlestick_trend' in df_copy.columns:
            print(f"ðŸ•¯ï¸ DEBUG: candlestick_trend successfully added to df_copy")
            print(f"   Distribution: {df_copy['candlestick_trend'].value_counts().to_dict()}")
        else:
            print(f"âŒ WARNING: candlestick_trend NOT found in df_copy columns")
    
    # Apply enhanced combined signals untuk SEMUA kombinasi yang mungkin - SETELAH semua kolom ditambahkan
    if len(selected_technicals) >= 2:
        print("ðŸ”— Applying enhanced combined signals with confirmations...")
        df_copy = apply_enhanced_combined_signals(df_copy, selected_technicals)
        
        print(f"ðŸ” DEBUG: After enhanced combined signals, df_copy columns: {df_copy.columns.tolist()}")
    
    print(f"ðŸ” DEBUG: Final DataFrame columns: {df_copy.columns.tolist()}")
    return df_copy













def calculate_combined_signal_only(df, selected_technicals):
    """Calculate only the combined signal without modifying the DataFrame"""
    try:
        # Get signal columns that exist in the dataframe
        signal_columns = [col for col in selected_technicals if col in df.columns]
        
        if len(signal_columns) < 2:
            return None
        
        combined_signal = pd.Series('Hold', index=df.index)
        
        # Simple voting mechanism
        for idx in df.index:
            signals = []
            for col in signal_columns:
                if pd.notna(df.loc[idx, col]):
                    signals.append(df.loc[idx, col])
            
            if not signals:
                continue
            
            buy_count = signals.count('Buy')
            sell_count = signals.count('Sell')
            
            if buy_count > sell_count:
                combined_signal.loc[idx] = 'Buy'
            elif sell_count > buy_count:
                combined_signal.loc[idx] = 'Sell'
            # else remains 'Hold'
        
        return combined_signal
        
    except Exception as e:
        print(f"Error calculating combined signal: {e}")
        return pd.Series('Hold', index=df.index)


# def apply_enhanced_combined_signals_only(df, selected_technicals):
#     """Apply enhanced combined signals and return only the new signal columns"""
#     try:
#         print(f"ðŸ—³ï¸ Applying enhanced combined signals for: {selected_technicals}")
        
#         # Generate all combinations
#         combinations_to_create = generate_all_signal_combinations(selected_technicals)
        
#         print(f"ðŸ“ Creating {len(combinations_to_create)} combined signal combinations...")
        
#         enhanced_signals = {}
        
#         for combo in combinations_to_create:
#             combo_name = combo['name']
#             indicators = combo['indicators']
            
#             print(f"   ðŸ”§ Creating: {combo_name} from {indicators}")
            
#             # Apply voting system
#             combined_signal = apply_voting_system_only(df, indicators)
#             enhanced_signals[combo_name] = combined_signal
            
#             # Print hasil untuk verifikasi
#             signal_counts = combined_signal.value_counts().to_dict()
#             print(f"   âœ… {combo_name}: {signal_counts}")
        
#         return enhanced_signals
        
#     except Exception as e:
#         print(f"Error in apply_enhanced_combined_signals_only: {e}")
#         return {}


def apply_voting_system_only(df, indicators):
    """Apply voting system and return only the combined signal"""
    combined_signal = pd.Series('Hold', index=df.index)
    
    for idx in df.index:
        # Collect all signals from the indicators
        signals = []
        volume_signal = None
        has_volume = False
        
        for indicator in indicators:
            if indicator in df.columns:
                signal = df.loc[idx, indicator]
                
                if pd.notna(signal):
                    if indicator == 'Volume_Signal':
                        has_volume = True
                        volume_signal = signal
                        # Don't add volume to regular voting - handle separately
                    else:
                        signals.append(signal)
        
        if not signals:
            combined_signal.loc[idx] = 'Hold'
            continue
        
        # Count votes for each signal type
        buy_votes = signals.count('Buy')
        sell_votes = signals.count('Sell')
        hold_votes = signals.count('Hold')
        
        # Determine preliminary result based on voting
        preliminary_result = determine_voting_result(buy_votes, sell_votes, hold_votes, len(signals))
        
        # Apply volume filter if volume indicator is present
        if has_volume and volume_signal:
            final_result = apply_volume_filter(preliminary_result, volume_signal)
        else:
            final_result = preliminary_result
        
        combined_signal.loc[idx] = final_result
    
    return combined_signal


# Update other functions that might cause fragmentation
def calculate_signal_pairs_profit(df, signal_col):
    """Calculate profit from signal pairs with improved error handling and no DataFrame fragmentation"""
    if signal_col not in df.columns:
        return [], 0, 0
    
    try:
        # Create a clean copy to avoid fragmentation
        df_clean = df.copy()
        
        # Ensure datetime column is properly formatted
        if 'Datetime' in df_clean.columns:
            df_clean['Datetime'] = pd.to_datetime(df_clean['Datetime'], errors='coerce')
            df_clean = df_clean.dropna(subset=['Datetime'])
                
        if df_clean.empty:
            return [], 0, 0
        
        df_sorted = df_clean.sort_values('Datetime')
        signal_pairs = []
        current_position = None
        
        for idx, row in df_sorted.iterrows():
            signal = row[signal_col]
            
            if pd.isna(signal) or signal not in ['Buy', 'Sell']:
                continue
            
            if signal == 'Buy' and current_position is None:
                current_position = {
                    'buy_date': row['Datetime'],
                    'buy_price': row.get('Close', 0),
                    'buy_idx': idx
                }
            elif signal == 'Sell' and current_position is not None:
                sell_price = row.get('Close', 0)
                profit_pct = ((sell_price - current_position['buy_price']) / current_position['buy_price']) * 100
                holding_period = (row['Datetime'] - current_position['buy_date']).days
                
                signal_pairs.append({
                    'buy_date': current_position['buy_date'],
                    'buy_price': current_position['buy_price'],
                    'sell_date': row['Datetime'],
                    'sell_price': sell_price,
                    'profit_pct': profit_pct,
                    'holding_period': holding_period,
                    'holding_days': holding_period
                })
                
                current_position = None
        
        # Calculate overall metrics
        if signal_pairs:
            total_profit = sum(pair['profit_pct'] for pair in signal_pairs)
            winning_trades = len([pair for pair in signal_pairs if pair['profit_pct'] > 0])
            win_rate = (winning_trades / len(signal_pairs)) * 100
        else:
            total_profit = 0
            win_rate = 0
        
        return signal_pairs, total_profit, win_rate
        
    except Exception as e:
        print(f"Error in calculate_signal_pairs_profit: {e}")
        return [], 0, 0






def apply_voting_system_with_confirmations(df, indicators, has_volume_confirmation, has_trend_confirmation):
    """Apply voting system with proper confirmations based on specified rules"""
    combined_signal = pd.Series('Hold', index=df.index)
    
    # Process row by row
    for idx in df.index:
        # Collect votes from each indicator
        votes = []
        volume_signal = None
        candlestick_trend = None
        
        for indicator in indicators:
            if indicator == 'Volume_Signal' and indicator in df.columns:
                volume_signal = df.at[idx, indicator] if pd.notna(df.at[idx, indicator]) else None
                continue  # Skip adding volume to voting, we'll use it as confirmation
            
            if indicator == 'Candlestick_Signal' and 'candlestick_trend' in df.columns:
                candlestick_trend = df.at[idx, 'candlestick_trend'] if pd.notna(df.at[idx, 'candlestick_trend']) else None
                continue  # Skip adding candlestick to voting, we'll use it as confirmation
                
            if indicator in df.columns and pd.notna(df.at[idx, indicator]):
                votes.append(df.at[idx, indicator])
        
        # Calculate initial vote counts
        buy_votes = votes.count('Buy')
        sell_votes = votes.count('Sell')
        hold_votes = votes.count('Hold')
        total_votes = len(votes)
        
        # Determine preliminary result based on voting
        if total_votes == 0:
            preliminary_result = 'Hold'
        else:
            # For 2 indicators
            if total_votes == 1:
                # With only one vote, use it directly
                preliminary_result = votes[0]
            elif total_votes == 2:
                # For 2 votes, both must agree for Buy/Sell
                if buy_votes == 2:
                    preliminary_result = 'Buy'
                elif sell_votes == 2:
                    preliminary_result = 'Sell'
                else:
                    preliminary_result = 'Hold'  # Disagreement = Hold
            else:
                # For 3+ votes, use majority
                if buy_votes > sell_votes and buy_votes > hold_votes:
                    preliminary_result = 'Buy'
                elif sell_votes > buy_votes and sell_votes > hold_votes:
                    preliminary_result = 'Sell'
                else:
                    preliminary_result = 'Hold'
        
        # Apply candlestick trend confirmation
        if has_trend_confirmation and candlestick_trend is not None:
            # If preliminary result and trend contradict each other, change to Hold
            if preliminary_result == 'Buy' and candlestick_trend == 'Downtrend':
                preliminary_result = 'Hold'
            elif preliminary_result == 'Sell' and candlestick_trend == 'Uptrend':
                preliminary_result = 'Hold'
            # If sideways, maintain the signal
        
        # Apply volume confirmation - IMPROVED
        if has_volume_confirmation and volume_signal is not None:
            if preliminary_result in ['Buy', 'Sell']:
                if volume_signal == 'Low Volume':
                    # With Low Volume, force Hold regardless of other signals
                    preliminary_result = 'Hold'
                # With High Volume, maintain the signal
        
        # Set the final signal
        combined_signal.at[idx] = preliminary_result
    
    return combined_signal


def apply_trend_confirmation(preliminary_signal, candlestick_trend):
    """Apply trend confirmation to a preliminary signal"""
    # If the candlestick_trend is not available or is NaN, keep the original signal
    if pd.isna(candlestick_trend):
        return preliminary_signal
    
    # If the signal aligns with the trend, keep it
    if (preliminary_signal == 'Buy' and candlestick_trend == 'Uptrend') or \
       (preliminary_signal == 'Sell' and candlestick_trend == 'Downtrend'):
        return preliminary_signal
    
    # If the signal contradicts a strong trend, consider changing it
    if preliminary_signal == 'Buy' and candlestick_trend == 'Downtrend':
        return 'Hold'  # Downgrade buy signal when trend is down
    
    if preliminary_signal == 'Sell' and candlestick_trend == 'Uptrend':
        return 'Hold'  # Downgrade sell signal when trend is up
    
    # For Hold signals or Sideways trends, keep the original signal
    return preliminary_signal

def apply_volume_confirmation(preliminary_signal, volume_signal):
    """Apply volume confirmation - hanya High Volume yang melanjutkan sinyal"""
    if pd.isna(volume_signal):
            return preliminary_signal
        
    # Hanya High Volume yang melanjutkan sinyal Buy/Sell
    if preliminary_signal in ['Buy', 'Sell']:
        if volume_signal == 'High Volume':
                return preliminary_signal  # Lanjutkan sinyal karena volume tinggi
        else:  # Low Volume
            return 'Hold'  # Ubah ke Hold karena volume rendah
        
    # Jika sinyal Hold, tetap Hold
    return preliminary_signal


# def apply_enhanced_combined_signals(df, selected_technicals):
#     """Apply enhanced combined signals dengan sistem voting yang lebih akurat"""
#     print(f"ðŸ—³ï¸ Applying enhanced combined signals with improved voting for: {selected_technicals}")
    
#     # Generate all combinations including Volume and Candlestick
#     combinations_to_create = generate_all_signal_combinations(selected_technicals)
    
#     print(f"ðŸ“ Creating {len(combinations_to_create)} combined signal combinations...")
    
#     # Track voting decisions for debugging
#     voting_log = []
    
#     for combo in combinations_to_create:
#         combo_name = combo['name']
#         indicators = combo['indicators']
        
#         print(f"ðŸ”„ Processing {combo_name} with indicators: {indicators}")
        
#         # Check if this combination should use rule-based voting
#         has_candlestick = 'Candlestick_Signal' in indicators
#         has_volume = 'Volume_Signal' in indicators
#         is_multi_indicator = len([i for i in indicators if i not in ['Volume_Signal', 'Candlestick_Signal']]) >= 1
        
#         # Apply rule-based voting if this includes candlestick or volume as confirmation
#         if (has_candlestick or has_volume) and is_multi_indicator:
#             print(f"   Using rule-based voting with trend confirmation for {combo_name}")
#             combined_signal = apply_rule_based_voting(df, indicators)
#         else:
#             # Otherwise use simple majority voting
#             print(f"   Using simple majority voting for {combo_name}")
#             combined_signal = apply_simple_voting(df, indicators)
        
#         df[combo_name] = combined_signal
        
#         # Log signal distribution
#         signal_counts = combined_signal.value_counts().to_dict()
#         print(f"âœ… {combo_name} signal counts: {signal_counts}")
        
#         # Add sample of voting decisions for debugging
#         sample_idx = min(5, len(df))
#         for i in range(sample_idx):
#             if i < len(df):
#                 row = df.iloc[i]
#                 signal_values = {ind: row[ind] if ind in row else None for ind in indicators}
#                 voting_log.append({
#                     'combo': combo_name,
#                     'datetime': str(row['Datetime']) if 'Datetime' in row else f"row_{i}",
#                     'signals': signal_values,
#                     'result': row[combo_name]
#                 })
    
#     # Log some example voting decisions (optional)
#     # print(f"Example voting decisions: {voting_log[:3]}")
    
#     return df







def generate_all_signal_combinations(selected_technicals):
    """Generates all relevant combinations of technical indicators."""
    base_indicators = selected_technicals.copy()
    all_combos_list = []
    
    # Generate base combinations from selected technicals
    for i in range(1, len(base_indicators) + 1):
        for combo in combinations(base_indicators, i):
            all_combos_list.append(list(combo))

    special_indicators = ['Volume_Signal', 'candlestick_trend']
    final_combinations = []

    # Add special indicators to the base combinations
    for combo in all_combos_list:
        # Combo as is
        final_combinations.append(combo)
        # Combo with Volume
        final_combinations.append(combo + ['Volume_Signal'])
        # Combo with Candlestick
        final_combinations.append(combo + ['candlestick_trend'])
        # Combo with both
        final_combinations.append(combo + special_indicators)

    # Add combination of only special indicators
    final_combinations.append(['Volume_Signal', 'candlestick_trend'])
    
    # Create unique, sorted combinations in the desired dictionary format
    combinations_to_create = []
    seen_combos = set()
    for combo_list in final_combinations:
        # Filter out None and ensure indicators are valid columns (hypothetically)
        valid_combo = [ind for ind in combo_list if ind is not None]
        if not valid_combo:
            continue
            
        valid_combo.sort()
        combo_tuple = tuple(valid_combo)
        
        if combo_tuple not in seen_combos and len(combo_tuple) >= 2:
            combo_name = 'Signal_' + '_'.join(valid_combo)
            combinations_to_create.append({'name': combo_name, 'indicators': valid_combo})
            seen_combos.add(combo_tuple)
            
    return combinations_to_create

def get_voting_info(df, idx, indicators):
    """Helper function to get voting information for debugging."""
    voting_info = {
        'datetime': df.at[idx, 'Datetime'] if 'Datetime' in df.columns else idx,
        'votes': {}
    }
    for indicator in indicators:
        if indicator in df.columns and pd.notna(df.at[idx, indicator]):
            voting_info['votes'][indicator] = df.at[idx, indicator]
    return voting_info

def apply_enhanced_combined_signals(df, selected_technicals):
    """Apply enhanced combined signals dengan sistem voting yang lebih akurat - FIXED LOGIC"""
    print(f"ðŸ—³ï¸ Applying enhanced combined signals with improved voting for: {selected_technicals}")
    
    combinations_to_create = generate_all_signal_combinations(selected_technicals)
    print(f"ðŸ“ Creating {len(combinations_to_create)} combined signal combinations...")
    
    voting_log = []
    
    for combo in combinations_to_create:
        combo_name = combo['name']
        indicators = combo['indicators']
        
        print(f"   ðŸ”§ Creating: {combo_name} from {indicators}")
        
        # Apply enhanced voting system dengan logika yang diperbaiki
        combined_signal = apply_enhanced_rule_based_voting(df, indicators)
        df[combo_name] = combined_signal
        
        signal_counts = combined_signal.value_counts().to_dict()
        print(f"   âœ… {combo_name}: {signal_counts}")
        
        sample_votes = []
        sample_indices = df[df[combo_name] != 'Hold'].index.tolist()[:3] + df.index.tolist()[:2]
        sample_indices = sorted(list(set(sample_indices)))[:5]
        
        for idx in sample_indices:
            if idx in df.index:
                vote_info = get_voting_info(df, idx, indicators)
                vote_info['final_signal'] = df.at[idx, combo_name]
                sample_votes.append(vote_info)
        
        voting_log.append({
            'combination': combo_name,
            'sample_votes': sample_votes
        })
    
    print(f"ðŸ“‹ Example voting decisions logged for {len(voting_log)} combinations")
    return df

# =============================================================================
# FUNGSI INTI YANG DIPERBAIKI SECARA SIGNIFIKAN
# =============================================================================
def apply_enhanced_rule_based_voting(df, indicators):
    """
    Apply an enhanced, unified rule-based voting system.
    1. All indicators, including candlestick, are treated as voters.
    2. Low Volume acts as a veto, forcing a 'Hold' signal.
    3. Ties result in a 'Hold' signal.
    4. High Volume can act as an enhancer to upgrade a 'Hold' signal if the trend is clear.
    """
    combined_signal = pd.Series('Hold', index=df.index)
    
    for idx in df.index:
        signals = {indicator: df.at[idx, indicator] for indicator in indicators if indicator in df.columns and pd.notna(df.at[idx, indicator])}
        
        volume_signal = signals.get('Volume_Signal')
        candlestick_trend = signals.get('candlestick_trend')
        
        # --- ATURAN #1: VETO DARI LOW VOLUME ---
        # Jika volume rendah, sinyal dianggap tidak valid. Ini adalah aturan prioritas tertinggi.
        if volume_signal == 'Low Volume':
            combined_signal.at[idx] = 'Hold'
            continue # Lanjut ke baris berikutnya

        # --- ATURAN #2: KUMPULKAN SEMUA SUARA (VOTES) ---
        all_votes = []
        # Tambahkan suara dari indikator regular (Bollinger, RSI, dll.)
        for indicator, value in signals.items():
            if indicator not in ['Volume_Signal', 'candlestick_trend']:
                all_votes.append(value)
        
        # Ubah candlestick_trend menjadi suara dan tambahkan ke daftar
        if candlestick_trend:
            if candlestick_trend == 'Uptrend':
                all_votes.append('Buy')
            elif candlestick_trend == 'Downtrend':
                all_votes.append('Sell')
            else: # Sideways or other
                all_votes.append('Hold')
        
        # Jika tidak ada suara sama sekali, hasilnya Hold
        if not all_votes:
            combined_signal.at[idx] = 'Hold'
            continue

        # --- ATURAN #3: TENTUKAN SINYAL DARI VOTING MAYORITAS ---
        buy_votes = all_votes.count('Buy')
        sell_votes = all_votes.count('Sell')
        hold_votes = all_votes.count('Hold')
        
        prelim_signal = 'Hold' # Default ke Hold jika terjadi tie
        if buy_votes > sell_votes and buy_votes > hold_votes:
            prelim_signal = 'Buy'
        elif sell_votes > buy_votes and sell_votes > hold_votes:
            prelim_signal = 'Sell'
        # Jika tidak ada mayoritas yang jelas (termasuk tie), hasilnya tetap 'Hold'.
        # Ini mencakup:
        # - bollinger(Hold) + candlestick(Uptrend) -> [Hold, Buy] -> Tie -> Hold
        # - bollinger(Buy) + candlestick(Sideways) -> [Buy, Hold] -> Tie -> Hold
        
        # --- ATURAN #4: HIGH VOLUME SEBAGAI ENHANCER/PENINGKAT ---
        # Jika sinyal awal adalah 'Hold' (karena mayoritas Hold atau tie),
        # 'High Volume' dapat meningkatkannya jika ada konfirmasi dari tren.
        final_signal = prelim_signal
        if prelim_signal == 'Hold' and volume_signal == 'High Volume':
            if candlestick_trend == 'Uptrend':
                final_signal = 'Buy' # Upgrade ke Buy
            elif candlestick_trend == 'Downtrend':
                final_signal = 'Sell' # Upgrade ke Sell
        
        combined_signal.at[idx] = final_signal

    return combined_signal


# Fungsi apply_simple_voting tetap bisa digunakan sebagai alternatif, tidak perlu diubah
def apply_simple_voting(df, indicators):
    """Apply simple majority voting dengan enhanced logic untuk edge cases"""
    combined_signal = pd.Series('Hold', index=df.index)
    
    for idx in df.index:
        all_votes = []
        for indicator in indicators:
            if indicator in df.columns:
                value = df.at[idx, indicator] if pd.notna(df.at[idx, indicator]) else None
                if value is not None:
                    if indicator == 'Volume_Signal':
                        if value == 'High Volume': all_votes.append('Buy')
                        elif value == 'Low Volume': all_votes.append('Sell')
                        else: all_votes.append('Hold')
                    elif indicator == 'candlestick_trend':
                        if value == 'Uptrend': all_votes.append('Buy')
                        elif value == 'Downtrend': all_votes.append('Sell')
                        else: all_votes.append('Hold')
                    else:
                        all_votes.append(value)
        
        buy_count = all_votes.count('Buy')
        sell_count = all_votes.count('Sell')
        hold_count = all_votes.count('Hold')
        
        if len(all_votes) == 0:
            final_signal = 'Hold'
        elif buy_count > sell_count and buy_count > hold_count:
            final_signal = 'Buy'
        elif sell_count > buy_count and sell_count > hold_count:
            final_signal = 'Sell'
        elif hold_count > buy_count and hold_count > sell_count:
            final_signal = 'Hold'
        elif buy_count == sell_count and buy_count > hold_count:
            final_signal = 'Hold'
        elif buy_count == hold_count and buy_count > sell_count:
            final_signal = 'Buy'
        elif sell_count == hold_count and sell_count > buy_count:
            final_signal = 'Sell'
        else:
            final_signal = 'Hold'
        
        combined_signal.at[idx] = final_signal
    
    return combined_signal




# def get_voting_info(df, idx, indicators):
#     """Helper function to get voting information for debugging"""
#     voting_info = {
#         'datetime': df.at[idx, 'Datetime'] if 'Datetime' in df.columns else idx,
#         'votes': {}
#     }
    
#     for indicator in indicators:
#         if indicator in df.columns:
#             value = df.at[idx, indicator] if pd.notna(df.at[idx, indicator]) else None
#             if value is not None:
#                 if indicator == 'Volume_Signal':
#                     vote = 'Buy' if value == 'High Volume' else 'Sell' if value == 'Low Volume' else 'Hold'
#                     voting_info['votes'][indicator] = f"{vote} ({value})"
#                 elif indicator == 'candlestick_trend':
#                     vote = 'Buy' if value == 'Uptrend' else 'Sell' if value == 'Downtrend' else 'Hold'
#                     voting_info['votes'][indicator] = f"{vote} ({value})"
#                 else:
#                     voting_info['votes'][indicator] = value
    
#     return voting_info











# def apply_rule_based_voting(df, indicators):
#     """Apply rule-based voting system dengan memanfaatkan candlestick trend sebagai konfirmasi yang lebih baik"""
#     combined_signal = pd.Series('Hold', index=df.index)
#     debug_info = []  # Untuk tracking logika voting


    
#     for idx in df.index:
#         # Kumpulkan semua sinyal untuk baris ini
#         signals = {}
#         for indicator in indicators:
#             if indicator ==  'candlestick_trend' in df.columns:
#                 # Gunakan trend bukan signal untuk candlestick
#                 signals[indicator] = df.at[idx, 'candlestick_trend'] if pd.notna(df.at[idx, 'candlestick_trend']) else None
#             elif indicator in df.columns:
#                 signals[indicator] = df.at[idx, indicator] if pd.notna(df.at[idx, indicator]) else None
        
#         # Pisahkan sinyal berdasarkan jenisnya
#         regular_signals = {}
#         volume_signal = None
#         candlestick_trend = None

#         # print(indicator('candlestick_trend'))
#         print(df.columns)
        
#         for indicator, value in signals.items():
#             if indicator == 'Volume_Signal':
#                 volume_signal = value
#             elif indicator == 'candlestick_trend':
#                 candlestick_trend = value
#             elif value is not None:
#                 regular_signals[indicator] = value
        
#         # Hitung jumlah sinyal berdasarkan jenisnya
#         regular_values = list(regular_signals.values())
#         buy_count = regular_values.count('Buy')
#         sell_count = regular_values.count('Sell')
#         hold_count = regular_values.count('Hold')
#         total_regular = len(regular_values)
        
#         # Tentukan sinyal awal berdasarkan voting mayoritas dari sinyal reguler
#         if buy_count > sell_count and buy_count > hold_count:
#             preliminary_signal = 'Buy'
#         elif sell_count > buy_count and sell_count > hold_count:
#             preliminary_signal = 'Sell'
#         else:
#             preliminary_signal = 'Hold'
            
#         # Simpan informasi awal untuk debugging
#         debug_row = {
#             'datetime': df.at[idx, 'Datetime'] if 'Datetime' in df.columns else idx,
#             'prelim_signal': preliminary_signal,
#             'buy_count': buy_count,
#             'sell_count': sell_count,
#             'hold_count': hold_count,
#             'volume_signal': volume_signal,
#             'candlestick_trend': candlestick_trend
#         }
        
#         # Aturan konfirmasi candlestick trend
#         final_signal = preliminary_signal
        
#         # IMPROVED: Penanganan Candlestick Trend sebagai Konfirmasi
        
#         # Rule 1: Buy-Buy-Sideways = Buy (sinyal buy dominan dengan sideways)
#         if preliminary_signal == 'Buy' and candlestick_trend == 'Sideways':
#             final_signal = 'Buy'
#             debug_row['rule'] = "Buy + Sideways = Buy"
        
#         # Rule 2: Buy-Sell-Uptrend = Buy (uptrend memperkuat sinyal buy)
#         elif preliminary_signal == 'Hold' and buy_count == sell_count and candlestick_trend == 'Uptrend':
#             final_signal = 'Buy'
#             debug_row['rule'] = "Buy-Sell tie + Uptrend = Buy"
            
#         # Rule 3: Buy-Buy-Downtrend = Hold (downtrend melemahkan sinyal buy)
#         elif preliminary_signal == 'Buy' and candlestick_trend == 'Downtrend':
#             final_signal = 'Hold'
#             debug_row['rule'] = "Buy + Downtrend = Hold"
        
#         # Rule 4: Sell-Sell-Sideways = Sell (sinyal sell dominan dengan sideways)
#         elif preliminary_signal == 'Sell' and candlestick_trend == 'Sideways':
#             final_signal = 'Sell'
#             debug_row['rule'] = "Sell + Sideways = Sell"
            
#         # Rule 5: Buy-Sell-Downtrend = Sell (downtrend memperkuat sinyal sell)
#         elif preliminary_signal == 'Hold' and buy_count == sell_count and candlestick_trend == 'Downtrend':
#             final_signal = 'Sell'
#             debug_row['rule'] = "Buy-Sell tie + Downtrend = Sell"
            
#         # Rule 6: Sell-Sell-Uptrend = Hold (uptrend melemahkan sinyal sell)
#         elif preliminary_signal == 'Sell' and candlestick_trend == 'Uptrend':
#             final_signal = 'Hold'
#             debug_row['rule'] = "Sell + Uptrend = Hold"
            
#         # Rule 7: Ketika Buy dominan dan Uptrend, ini sinyal Buy yang kuat
#         elif preliminary_signal == 'Buy' and candlestick_trend == 'Uptrend':
#             final_signal = 'Buy' 
#             # Cek volume juga untuk keputusan final
#             if volume_signal == 'Low Volume':
#                 final_signal = 'Hold'  # Volume rendah melemahkan sinyal
#                 debug_row['rule'] = "Buy + Uptrend + Low Volume = Hold"
#             else:
#                 debug_row['rule'] = "Buy + Uptrend = Strong Buy"
        
#         # Rule 8: Ketika Sell dominan dan Downtrend, ini sinyal Sell yang kuat
#         elif preliminary_signal == 'Sell' and candlestick_trend == 'Downtrend':
#             final_signal = 'Sell'
#             # Cek volume juga untuk keputusan final
#             if volume_signal == 'Low Volume':
#                 final_signal = 'Hold'  # Volume rendah melemahkan sinyal
#                 debug_row['rule'] = "Sell + Downtrend + Low Volume = Hold"
#             else:
#                 debug_row['rule'] = "Sell + Downtrend = Strong Sell"
        
#         # Volume sebagai konfirmasi tambahan
#         if volume_signal == 'Low Volume' and final_signal in ['Buy', 'Sell']:
#             final_signal = 'Hold'
#             debug_row['rule'] = f"{final_signal} + Low Volume = Hold"
            
#         debug_row['final_signal'] = final_signal
#         debug_info.append(debug_row)
#         combined_signal.at[idx] = final_signal
    
#     # Simpan debug info untuk analisis sistem votinG FOR DEBUG
#     # debug_df = pd.DataFrame(debug_info)
#     # debug_df.to_csv('voting_debug.csv', index=False)
    
#     return combined_signal




# def apply_rule_based_voting(df, indicators):
#     """Apply rule-based voting system dengan memanfaatkan candlestick trend sebagai konfirmasi yang lebih baik"""
#     combined_signal = pd.Series('Hold', index=df.index)
#     debug_info = []  # Untuk tracking logika voting
    
#     for idx in df.index:
#         # Kumpulkan semua sinyal untuk baris ini
#         signals = {}
#         for indicator in indicators:
#             if indicator == 'candlestick_trend' and 'candlestick_trend' in df.columns:
#                 # Gunakan trend bukan signal untuk candlestick
#                 signals[indicator] = df.at[idx, 'candlestick_trend'] if pd.notna(df.at[idx, 'candlestick_trend']) else None
#             elif indicator in df.columns:
#                 signals[indicator] = df.at[idx, indicator] if pd.notna(df.at[idx, indicator]) else None
        
#         # Pisahkan sinyal berdasarkan jenisnya
#         regular_signals = {}
#         volume_signal = None
#         candlestick_trend = None
        
#         for indicator, value in signals.items():
#             if indicator == 'Volume_Signal':
#                 volume_signal = value
#             elif indicator == 'candlestick_trend':
#                 candlestick_trend = value
#             elif value is not None:
#                 regular_signals[indicator] = value
        
#         # Hitung jumlah sinyal berdasarkan jenisnya
#         regular_values = list(regular_signals.values())
#         buy_count = regular_values.count('Buy')
#         sell_count = regular_values.count('Sell')
#         hold_count = regular_values.count('Hold')
#         total_regular = len(regular_values)
        
#         # Tentukan sinyal awal berdasarkan voting mayoritas dari sinyal reguler
#         if buy_count > sell_count and buy_count > hold_count:
#             preliminary_signal = 'Buy'
#         elif sell_count > buy_count and sell_count > hold_count:
#             preliminary_signal = 'Sell'
#         else:
#             preliminary_signal = 'Hold'
            
#         final_signal = preliminary_signal
        
#         # Simpan informasi awal untuk debugging
#         debug_row = {
#             'datetime': df.at[idx, 'Datetime'] if 'Datetime' in df.columns else idx,
#             'prelim_signal': preliminary_signal,
#             'buy_count': buy_count,
#             'sell_count': sell_count,
#             'hold_count': hold_count,
#             'volume_signal': volume_signal,
#             'candlestick_trend': candlestick_trend
#             # 'rule' akan diisi oleh logika di bawah
#         }
#         if total_regular > 0:
#             debug_row['rule'] = f"Initial from regular signals: {preliminary_signal}"
#         elif preliminary_signal == 'Hold': # No regular signals, prelim is Hold
#              debug_row['rule'] = "Initial: No regular signals, Hold"
#         else: # Should not happen if prelim_signal logic is correct for no regular signals
#             debug_row['rule'] = f"Initial: No regular signals, prelim: {preliminary_signal}"

#         # ==============================================================================
#         # BLOK LOGIKA BARU: Khusus untuk kombinasi Volume + Candlestick SAJA
#         # (tanpa ada sinyal dari indikator reguler lain)
#         # ==============================================================================
#         is_volume_candlestick_only = total_regular == 0 and volume_signal is not None and candlestick_trend is not None

#         if is_volume_candlestick_only:
#             # Aturan Low Volume selalu Hold, apapun trendnya
#             if volume_signal == 'Low Volume':
#                 final_signal = 'Hold'
#                 debug_row['rule'] = "Vol+Candle Only: Low Volume overrides any trend -> Hold"
#             # Aturan High Volume
#             elif volume_signal == 'High Volume':
#                 if candlestick_trend == 'Uptrend':
#                     final_signal = 'Buy'
#                     debug_row['rule'] = "Vol+Candle Only: High Volume + Uptrend = Buy"
#                 elif candlestick_trend == 'Downtrend':
#                     final_signal = 'Sell'
#                     debug_row['rule'] = "Vol+Candle Only: High Volume + Downtrend = Sell"
#                 else:  # Meliputi 'Sideways', 'Neutral', atau trend tidak jelas lainnya
#                     final_signal = 'Hold'
#                     debug_row['rule'] = f"Vol+Candle Only: High Volume + Trend ({candlestick_trend}) = Hold"
#             else: # Volume bukan 'High' atau 'Low'
#                 final_signal = 'Hold'
#                 debug_row['rule'] = f"Vol+Candle Only: Unknown Volume ({volume_signal}) = Hold"
        
#         # JIKA BUKAN KASUS "HANYA VOLUME + CANDLESTICK", maka jalankan logika yang sudah ada
#         else:
#             # ==============================================================================
#             # BLOK LOGIKA YANG SUDAH ADA (PRIORITAS TERTINGGI SETELAH BLOK DI ATAS)
#             # ==============================================================================
#             # ATURAN REVERSAL 1: Sinyal Sell/Hold dengan High Volume di Uptrend -> Reversal ke Buy
#             if (preliminary_signal == 'Sell' or preliminary_signal == 'Hold') and volume_signal == 'High Volume' and candlestick_trend == 'Uptrend':
#                 final_signal = 'Buy'
#                 debug_row['rule'] = "NEW Reversal: Sell/Hold + High Volume + Uptrend = Buy"

#             # ATURAN REVERSAL 2: Sinyal Buy/Hold dengan High Volume di Downtrend -> Reversal ke Sell
#             elif (preliminary_signal == 'Buy' or preliminary_signal == 'Hold') and volume_signal == 'High Volume' and candlestick_trend == 'Downtrend':
#                 final_signal = 'Sell'
#                 debug_row['rule'] = "NEW Reversal: Buy/Hold + High Volume + Downtrend = Sell"
            
#             # ATURAN KUAT LOW VOLUME: Low Volume selalu menghasilkan Hold, apapun trendnya
#             elif volume_signal == 'Low Volume':
#                 final_signal = 'Hold'
#                 debug_row['rule'] = "NEW Confirmation: Low Volume overrides -> Hold"

#             # ATURAN KONFIRMASI HIGH VOLUME: High Volume di market yang trending (Up/Down) akan meneruskan sinyal awal
#             elif volume_signal == 'High Volume' and candlestick_trend in ['Uptrend', 'Downtrend']:
#                 # final_signal = preliminary_signal # Meneruskan sinyal awal (sudah diinisialisasi)
#                 if preliminary_signal != 'Hold':
#                     debug_row['rule'] = f"NEW Confirmation: {preliminary_signal} + High Volume + Trend ({candlestick_trend}) = {preliminary_signal}"
#                 else:
#                     # Jika sinyal awal Hold, tetap Hold
#                     debug_row['rule'] = f"NEW Confirmation: Hold + High Volume + Trend ({candlestick_trend}) = Hold"
            
#             # ==============================================================================
#             # JIKA ATURAN BARU TIDAK ADA YANG COCOK, JALANKAN LOGIKA LAMA ANDA
#             # ==============================================================================
#             else:
#                 # Rule 1: Buy-Buy-Sideways = Buy (sinyal buy dominan dengan sideways)
#                 if preliminary_signal == 'Buy' and candlestick_trend == 'Sideways':
#                     final_signal = 'Buy'
#                     debug_row['rule'] = "Old Logic: Buy + Sideways = Buy"
                
#                 # Rule 2: Buy-Sell-Uptrend = Buy (uptrend memperkuat sinyal buy)
#                 elif preliminary_signal == 'Hold' and buy_count == sell_count and total_regular > 0 and candlestick_trend == 'Uptrend':
#                     final_signal = 'Buy'
#                     debug_row['rule'] = "Old Logic: Buy-Sell tie + Uptrend = Buy"
                    
#                 # Rule 3: Buy-Buy-Downtrend = Hold (downtrend melemahkan sinyal buy)
#                 elif preliminary_signal == 'Buy' and candlestick_trend == 'Downtrend':
#                     final_signal = 'Hold'
#                     debug_row['rule'] = "Old Logic: Buy + Downtrend = Hold"
                
#                 # Rule 4: Sell-Sell-Sideways = Sell (sinyal sell dominan dengan sideways)
#                 elif preliminary_signal == 'Sell' and candlestick_trend == 'Sideways':
#                     final_signal = 'Sell'
#                     debug_row['rule'] = "Old Logic: Sell + Sideways = Sell"
                    
#                 # Rule 5: Buy-Sell-Downtrend = Sell (downtrend memperkuat sinyal sell)
#                 elif preliminary_signal == 'Hold' and buy_count == sell_count and total_regular > 0 and candlestick_trend == 'Downtrend':
#                     final_signal = 'Sell'
#                     debug_row['rule'] = "Old Logic: Buy-Sell tie + Downtrend = Sell"
                    
#                 # Rule 6: Sell-Sell-Uptrend = Hold (uptrend melemahkan sinyal sell)
#                 elif preliminary_signal == 'Sell' and candlestick_trend == 'Uptrend':
#                     final_signal = 'Hold'
#                     debug_row['rule'] = "Old Logic: Sell + Uptrend = Hold"
                    
#                 # Rule 7: Ketika Buy dominan dan Uptrend, ini sinyal Buy yang kuat
#                 elif preliminary_signal == 'Buy' and candlestick_trend == 'Uptrend':
#                     # final_signal = 'Buy' # Sudah Buy
#                     debug_row['rule'] = "Old Logic: Buy + Uptrend = Strong Buy" 
                
#                 # Rule 8: Ketika Sell dominan dan Downtrend, ini sinyal Sell yang kuat
#                 elif preliminary_signal == 'Sell' and candlestick_trend == 'Downtrend':
#                     # final_signal = 'Sell' # Sudah Sell
#                     debug_row['rule'] = "Old Logic: Sell + Downtrend = Strong Sell"
                
#                 elif preliminary_signal == 'Hold' and not debug_row.get('rule', '').startswith("Initial"): # If still Hold and not changed by any rule
#                      debug_row['rule'] = "Old Logic: Default to Hold or prelim_signal was Hold and no rules applied"
#                 elif not debug_row.get('rule', '').startswith("Initial"): # If prelim was Buy/Sell and no specific rule matched
#                      debug_row['rule'] = f"Old Logic: Prelim signal {preliminary_signal} maintained, no specific candlestick rule"

#         debug_row['final_signal'] = final_signal
#         debug_info.append(debug_row)
#         combined_signal.at[idx] = final_signal
    
#     # Simpan debug info untuk analisis sistem voting (opsional, bisa diaktifkan jika perlu)
#     # debug_df = pd.DataFrame(debug_info)
#     # print(debug_df) # Cetak untuk melihat hasil debug
#     # debug_df.to_csv('voting_debug.csv', index=False)
    
#     return combined_signal


def apply_rule_based_voting(df, indicators):
    """
    Apply rule-based voting system dengan memanfaatkan volume sebagai konfirmator
    dan candlestick trend sebagai indikator setara dalam voting.
    """
    combined_signal = pd.Series('Hold', index=df.index)
    debug_info = []  # Untuk tracking logika voting
    
    for idx in df.index:
        # Kumpulkan semua sinyal untuk baris ini
        signals = {}
        for indicator in indicators:
            if indicator == 'candlestick_trend' and 'candlestick_trend' in df.columns:
                # Gunakan trend bukan signal untuk candlestick
                signals[indicator] = df.at[idx, 'candlestick_trend'] if pd.notna(df.at[idx, 'candlestick_trend']) else None
            elif indicator in df.columns:
                signals[indicator] = df.at[idx, indicator] if pd.notna(df.at[idx, indicator]) else None
        
        # Ekstrak sinyal volume secara terpisah untuk digunakan sebagai konfirmator nanti
        volume_signal = signals.get('Volume_Signal', None)
        
        # =============================================================================
        # LOGIKA BARU: VOLUME SEBAGAI KONFIRMASI, BUKAN VOTER
        # =============================================================================
        
        # 1. Kumpulkan semua votes dari indikator NON-VOLUME
        all_votes = []
        vote_details = {}
        
        for indicator, value in signals.items():
            # Lewati 'Volume_Signal' karena akan digunakan nanti untuk konfirmasi
            if indicator == 'Volume_Signal' or value is None:
                continue

            # Proses voting untuk indikator lain (termasuk candlestick)
            if indicator == 'candlestick_trend':
                # Candlestick Trend sebagai voter: Uptrend = Buy, Downtrend = Sell, Sideways = Hold
                if value == 'Uptrend':
                    all_votes.append('Buy')
                    vote_details[indicator] = 'Buy (Uptrend)'
                elif value == 'Downtrend':
                    all_votes.append('Sell')
                    vote_details[indicator] = 'Sell (Downtrend)'
                else:  # Sideways atau lainnya
                    all_votes.append('Hold')
                    vote_details[indicator] = f'Hold ({value})'
            else:
                # Indikator reguler (Buy/Sell/Hold)
                all_votes.append(value)
                vote_details[indicator] = value
        
        # 2. Hitung hasil voting dari indikator NON-VOLUME untuk mendapatkan sinyal dasar
        buy_count = all_votes.count('Buy')
        sell_count = all_votes.count('Sell')
        hold_count = all_votes.count('Hold')
        total_votes = len(all_votes)
        
        base_signal = 'Hold'  # Sinyal dasar sebelum dikonfirmasi oleh volume
        base_rule = "Default Hold"
        
        # Tentukan sinyal dasar berdasarkan mayoritas voting
        if total_votes == 0:
            base_signal = 'Hold'
            base_rule = "No votes available from indicators"
        elif buy_count > sell_count and buy_count > hold_count:
            base_signal = 'Buy'
            base_rule = f"Majority Buy: {buy_count}/{total_votes} votes"
        elif sell_count > buy_count and sell_count > hold_count:
            base_signal = 'Sell'
            base_rule = f"Majority Sell: {sell_count}/{total_votes} votes"
        elif hold_count > buy_count and hold_count > sell_count:
            base_signal = 'Hold'
            base_rule = f"Majority Hold: {hold_count}/{total_votes} votes"
        else:
            # Handle ties
            if total_votes == 2:
                if buy_count == sell_count == 1:
                    base_signal = 'Hold'
                    base_rule = "2-way tie Buy-Sell â†’ Hold"
                elif buy_count == hold_count == 1:
                    base_signal = 'Hold' # Dianggap netral
                    base_rule = "2-way tie Buy-Hold â†’ Hold"
                elif sell_count == hold_count == 1:
                    base_signal = 'Hold' # Dianggap netral
                    base_rule = "2-way tie Sell-Hold â†’ Hold"
                else:
                    base_signal = 'Hold'
                    base_rule = "Tie situation â†’ Hold"
            elif total_votes >= 3:
                if buy_count == sell_count and buy_count > hold_count:
                    base_signal = 'Hold'
                    base_rule = f"Buy-Sell tie ({buy_count}-{sell_count}) â†’ Hold"
                elif buy_count == hold_count and buy_count > sell_count:
                    base_signal = 'Buy'
                    base_rule = f"Buy-Hold tie ({buy_count}-{hold_count}), more than Sell â†’ Buy"
                elif sell_count == hold_count and sell_count > buy_count:
                    base_signal = 'Sell'
                    base_rule = f"Sell-Hold tie ({sell_count}-{hold_count}), more than Buy â†’ Sell"
                else:
                    base_signal = 'Hold'
                    base_rule = f"Complex tie ({buy_count}-{sell_count}-{hold_count}) â†’ Hold"
            else:
                base_signal = 'Hold'
                base_rule = "Default Hold"

        # 3. Terapkan logika konfirmasi volume pada sinyal dasar
        final_signal = base_signal
        rule_applied = base_rule # Default rule
        
        if volume_signal == 'Low Volume':
            # VETO: Low Volume membatalkan sinyal apa pun dan menjadikannya 'Hold'
            final_signal = 'Hold'
            rule_applied = f"VETO by Low Volume (Original signal: {base_signal})"
        elif volume_signal == 'High Volume':
            # KONFIRMASI: High Volume meneruskan sinyal dasar
            final_signal = base_signal
            rule_applied = f"CONFIRMED by High Volume. ({base_rule})"
        else: # Normal Volume, None, atau nilai lain
            # NETRAL: Sinyal dasar lolos tanpa perubahan
            final_signal = base_signal
            rule_applied = f"Volume is Normal/None. ({base_rule})"
            
        # Simpan informasi debug
        debug_row = {
            'datetime': df.at[idx, 'Datetime'] if 'Datetime' in df.columns else idx,
            'total_votes': total_votes,
            'buy_votes': buy_count,
            'sell_votes': sell_count,
            'hold_votes': hold_count,
            'vote_details': vote_details,
            'volume_signal': volume_signal,
            'base_signal': base_signal, # Sinyal sebelum konfirmasi volume
            'final_signal': final_signal, # Sinyal setelah konfirmasi volume
            'rule': rule_applied
        }
        
        debug_info.append(debug_row)
        combined_signal.at[idx] = final_signal
    
    # Untuk analisis lebih lanjut, Anda bisa mengembalikan debug_info juga
    # return combined_signal, pd.DataFrame(debug_info)
    return combined_signal




# def apply_simple_voting(df, indicators):
#     """Apply simple majority voting without special confirmation rules"""
#     combined_signal = pd.Series('Hold', index=df.index)
    
#     for idx in df.index:
#         votes = []
#         for indicator in indicators:
#             if indicator in df.columns and pd.notna(df.at[idx, indicator]):
#                 votes.append(df.at[idx, indicator])
        
#         # Count votes
#         buy_votes = votes.count('Buy')
#         sell_votes = votes.count('Sell')
#         hold_votes = votes.count('Hold')
        
#         # Determine result
#         if buy_votes > sell_votes and buy_votes > hold_votes:
#             combined_signal.at[idx] = 'Buy'
#         elif sell_votes > buy_votes and sell_votes > hold_votes:
#             combined_signal.at[idx] = 'Sell'
#         else:
#             combined_signal.at[idx] = 'Hold'
    
#     return combined_signal


def apply_specific_voting_rules(df, indicators):
    """Apply specific voting rules as requested"""
    combined_signal = pd.Series('Hold', index=df.index)
    
    for idx in df.index:
        # Collect all signals
        signals = {}
        for indicator in indicators:
            if indicator in df.columns and pd.notna(df.at[idx, indicator]):
                signals[indicator] = df.at[idx, indicator]
                
        # Special case for candlestick trend
        if 'Candlestick_Signal' in indicators and 'candlestick_trend' in df.columns:
            signals['Candlestick_Signal'] = df.at[idx, 'candlestick_trend']
        
        # Apply specific rules based on collected signals
        result = apply_rule_based_logic(signals)
        combined_signal.at[idx] = result
            
    return combined_signal

def apply_rule_based_logic(signals):
    """Apply specific rules as requested"""
    # Default result
    result = 'Hold'
    
    # Extract signals for easier processing
    regular_signals = {k: v for k, v in signals.items() 
                      if k != 'Volume_Signal' and k != 'candlestick_trend'}
    
    volume_signal = signals.get('Volume_Signal')
    candlestick_trend = signals.get('candlestick_trend')
    
    # Count types of regular signals
    buy_count = list(regular_signals.values()).count('Buy')
    sell_count = list(regular_signals.values()).count('Sell')
    
    # Rule: buy-buy-high volume = buy
    if buy_count >= 2 and volume_signal == 'High Volume':
        result = 'Buy'
    
    # Rule: buy-buy-low volume = hold
    elif buy_count >= 2 and volume_signal == 'Low Volume':
        result = 'Hold'
    
    # Rule: buy-sell-sell-downtrend = sell
    elif buy_count == 1 and sell_count >= 2 and candlestick_trend == 'Downtrend':
        result = 'Sell'
    
    # General rules:
    # If all signals agree
    elif all(signal == 'Buy' for signal in regular_signals.values()) and len(regular_signals) >= 2:
        result = 'Buy'
    elif all(signal == 'Sell' for signal in regular_signals.values()) and len(regular_signals) >= 2:
        result = 'Sell'
    
    # If signals contradict with trend
    elif buy_count > sell_count and candlestick_trend == 'Downtrend':
        result = 'Hold'
    elif sell_count > buy_count and candlestick_trend == 'Uptrend':
        result = 'Hold'
    
    # If most signals are buy and no contradictions
    elif buy_count > sell_count and (candlestick_trend != 'Downtrend'):
        if volume_signal == 'Low Volume':
            result = 'Hold'
        else:
            result = 'Buy'
    
    # If most signals are sell and no contradictions
    elif sell_count > buy_count and (candlestick_trend != 'Uptrend'):
        if volume_signal == 'Low Volume':
            result = 'Hold'
        else:
            result = 'Sell'
    
    # Default case
    return result


def apply_voting_system_with_special_cases(df, indicators):
    """Apply voting system dengan special handling untuk Volume dan Candlestick - ENHANCED DEBUG untuk TREND"""
    # print(f"ðŸ” DEBUG: Starting voting system with indicators: {indicators}")
    
    combined_signal = pd.Series('Hold', index=df.index)
    
    # Separate regular indicators from special cases
    regular_indicators = []
    volume_indicator = None
    candlestick_indicator = None
    
    for indicator in indicators:
        if indicator == 'Volume_Signal':
            volume_indicator = indicator
            # print(f"ðŸ” DEBUG: Found Volume indicator: {indicator}")
        elif indicator == 'Candlestick_Signal':
            candlestick_indicator = indicator
            print(f"ðŸ” DEBUG: Found Candlestick indicator: {indicator}")
        else:
            regular_indicators.append(indicator)
            # print(f"ðŸ” DEBUG: Regular indicator: {indicator}")
    
    # print(f"ðŸ” DEBUG: Regular indicators: {regular_indicators}")
    # print(f"ðŸ” DEBUG: Volume indicator: {volume_indicator}")
    # print(f"ðŸ” DEBUG: Candlestick indicator: {candlestick_indicator}")
    
    for idx in df.index:
        # Collect votes dari regular indicators
        regular_votes = []
        for indicator in regular_indicators:
            if indicator in df.columns and pd.notna(df.at[idx, indicator]):
                vote = df.at[idx, indicator]
                regular_votes.append(vote)
                # print(f"ðŸ” DEBUG (idx {idx}): {indicator} voted: {vote}")
        
        # Handle special cases for Volume and Candlestick
        volume_vote = None
        candlestick_vote = None
        
        # Volume special handling
        if volume_indicator and volume_indicator in df.columns:
            volume_signal = df.at[idx, volume_indicator]
            if pd.notna(volume_signal):
                if volume_signal == 'High Volume':
                    volume_vote = 'Buy'  # High volume treated as bullish
                    # print(f"ðŸ” DEBUG (idx {idx}): Volume HIGH -> voting Buy")
                elif volume_signal == 'Low Volume':
                    volume_vote = 'Hold'  # Low volume treated as neutral/hold
                    # print(f"ðŸ” DEBUG (idx {idx}): Volume LOW -> voting Hold")
                regular_votes.append(volume_vote)
        
        # Candlestick special handling - FIXED untuk menggunakan TREND VALUE
        if candlestick_indicator and candlestick_indicator in df.columns:
            candlestick_trend = df.at[idx, candlestick_indicator]  # Sekarang berisi Uptrend/Downtrend/Sideways
            
            if pd.notna(candlestick_trend):
                if candlestick_trend == 'Uptrend':
                    candlestick_vote = 'Buy'
                    # print(f"ðŸ” DEBUG (idx {idx}): Candlestick UPTREND -> voting Buy")
                elif candlestick_trend == 'Downtrend':
                    candlestick_vote = 'Sell'
                    # print(f"ðŸ” DEBUG (idx {idx}): Candlestick DOWNTREND -> voting Sell")
                elif candlestick_trend == 'Sideways':
                    candlestick_vote = 'Hold'
                    # print(f"ðŸ” DEBUG (idx {idx}): Candlestick SIDEWAYS -> voting Hold")
                else:
                    candlestick_vote = 'Hold'
                    # print(f"ðŸ” DEBUG (idx {idx}): Candlestick UNKNOWN ({candlestick_trend}) -> voting Hold")
                regular_votes.append(candlestick_vote)
        
        if not regular_votes:
            combined_signal.at[idx] = 'Hold'
            continue
        
        # Count votes
        buy_votes = regular_votes.count('Buy')
        sell_votes = regular_votes.count('Sell')
        hold_votes = regular_votes.count('Hold')
        total_votes = len(regular_votes)
        
        # print(f"ðŸ” DEBUG (idx {idx}): Vote count - Buy: {buy_votes}, Sell: {sell_votes}, Hold: {hold_votes}, Total: {total_votes}")
        
        # Determine result using majority voting
        result = determine_voting_result(buy_votes, sell_votes, hold_votes, total_votes)
        combined_signal.at[idx] = result
        
        # print(f"ðŸ” DEBUG (idx {idx}): Final result: {result}")
    
    return combined_signal


# def generate_all_signal_combinations(selected_technicals):
#     """Generate all possible combinations dengan nama yang descriptive"""
#     from itertools import combinations
    
#     # Filter out Volume_Signal from regular combinations
#     regular_indicators = [ind for ind in selected_technicals if ind != 'Volume_Signal']
#     has_volume = 'Volume_Signal' in selected_technicals
    
#     combinations_to_create = []
    
#     # Generate combinations of 2 or more indicators
#     for r in range(2, len(regular_indicators) + 1):
#         for combo in combinations(regular_indicators, r):
#             combo_indicators = list(combo)
            
#             # Create descriptive names - IMPROVED NAMING
#             base_name_parts = []
#             for ind in combo_indicators:
#                 if ind == 'Bollinger_Signal':
#                     base_name_parts.append('BB')
#                 elif ind == 'MA_Signal':
#                     base_name_parts.append('MA')
#                 elif ind == 'RSI_Signal':
#                     base_name_parts.append('RSI')
#                 elif ind == 'MACD_Signal':
#                     base_name_parts.append('MACD')
#                 elif ind == 'ADX_Signal':
#                     base_name_parts.append('ADX')
#                 elif ind == 'Fibonacci_Signal':
#                     base_name_parts.append('FIBO')
#                 elif ind == 'Candlestick_Signal':
#                     base_name_parts.append('CANDLE')
#                 else:
#                     base_name_parts.append(ind.replace('_Signal', ''))
            
#             base_name = '_'.join(base_name_parts)
            
#             # Add volume if available
#             if has_volume:
#                 combo_name = f"{base_name}_Volume_Combined_Signal"
#                 combo_indicators_with_volume = combo_indicators + ['Volume_Signal']
#             else:
#                 combo_name = f"{base_name}_Combined_Signal"
#                 combo_indicators_with_volume = combo_indicators
            
#             combinations_to_create.append({
#                 'name': combo_name,
#                 'indicators': combo_indicators_with_volume,
#                 'base_indicators': combo_indicators,
#                 'has_volume': has_volume,
#                 'display_name': base_name + (' + Volume' if has_volume else '')
#             })
    
#     return combinations_to_create


def generate_all_signal_combinations(selected_technicals):
    """Generate all possible combinations of technical indicators - FIXED untuk semua 8 indikator"""
    from itertools import combinations
    
    # print(f"ðŸ” DEBUG: Starting combination generation with: {selected_technicals}")
    
    # SEMUA indikator akan masuk ke kombinasi, tidak ada yang dikecualikan
    all_indicators = selected_technicals.copy()
    
    # print(f"ðŸ” DEBUG: All indicators for combination: {all_indicators}")
    
    combinations_to_create = []
    
    # Generate kombinasi dari 2 hingga semua indikator yang dipilih
    for r in range(2, len(all_indicators) + 1):
        for combo in combinations(all_indicators, r):
            combo_name = '_'.join([ind.replace('_Signal', '') for ind in combo]) + '_Combined_Signal'
            combinations_to_create.append({
                'name': combo_name,
                'indicators': list(combo),
                'size': r,
                'has_volume': 'Volume_Signal' in combo,
                'has_candlestick': 'Candlestick_Signal' in combo,
                'display_name': ' + '.join([ind.replace('_Signal', '') for ind in combo])
            })
    
    # print(f"ðŸ” DEBUG: Generated {len(combinations_to_create)} combinations:")
    for combo in combinations_to_create:
        print(f"   ðŸ“Š {combo['name']} (size: {combo['size']}, volume: {combo['has_volume']}, candlestick: {combo['has_candlestick']})")
    
    return combinations_to_create




def apply_voting_system(df, indicators):
    """Apply voting system dengan logic yang robust"""
    combined_signal = pd.Series('Hold', index=df.index)
    
    for idx in df.index:
        signals = []
        volume_signal = None
        has_volume = False
        
        for indicator in indicators:
            if indicator in df.columns:
                signal = df.loc[idx, indicator]
                
                if pd.notna(signal):
                    if indicator == 'Volume_Signal':
                        has_volume = True
                        volume_signal = signal
                    else:
                        signals.append(signal)
        
        if not signals:
            combined_signal.loc[idx] = 'Hold'
            continue
        
        # Count votes
        buy_votes = signals.count('Buy')
        sell_votes = signals.count('Sell')
        hold_votes = signals.count('Hold')
        
        # Determine preliminary result
        preliminary_result = determine_voting_result(buy_votes, sell_votes, hold_votes, len(signals))
        
        # Apply volume filter if present
        if has_volume and volume_signal:
            final_result = apply_volume_filter(preliminary_result, volume_signal)
        else:
            final_result = preliminary_result
        
        combined_signal.loc[idx] = final_result
    
    return combined_signal

def determine_voting_result(buy_votes, sell_votes, hold_votes, total_indicators):
    """Determine voting result based on majority rule - ENHANCED LOGIC"""
    # print(f"ðŸ” DEBUG: Voting - Buy: {buy_votes}, Sell: {sell_votes}, Hold: {hold_votes}, Total: {total_indicators}")
    
    # Find the maximum votes
    max_votes = max(buy_votes, sell_votes, hold_votes)
    
    # Check for clear majority (lebih dari 50%)
    majority_threshold = total_indicators / 2
    
    if buy_votes > majority_threshold:
        # print(f"ðŸ” DEBUG: Buy majority ({buy_votes} > {majority_threshold})")
        return 'Buy'
    elif sell_votes > majority_threshold:
        # print(f"ðŸ” DEBUG: Sell majority ({sell_votes} > {majority_threshold})")
        return 'Sell'
    elif hold_votes > majority_threshold:
        # print(f"ðŸ” DEBUG: Hold majority ({hold_votes} > {majority_threshold})")
        return 'Hold'
    
    # Jika tidak ada mayoritas jelas, gunakan plurality (terbanyak)
    if buy_votes == max_votes and buy_votes > sell_votes and buy_votes > hold_votes:
        # print(f"ðŸ” DEBUG: Buy plurality")
        return 'Buy'
    elif sell_votes == max_votes and sell_votes > buy_votes and sell_votes > hold_votes:
        # print(f"ðŸ” DEBUG: Sell plurality")
        return 'Sell'
    elif hold_votes == max_votes and hold_votes > buy_votes and hold_votes > sell_votes:
        # print(f"ðŸ” DEBUG: Hold plurality")
        return 'Hold'
    
    # Handle ties
    if total_indicators == 2:
        # print(f"ðŸ” DEBUG: 2 indicators tie -> Hold")
        return 'Hold'
    elif total_indicators >= 3:
        # Untuk 3+ indikator, jika tie antara Buy-Sell, maka Hold
        if buy_votes == sell_votes and buy_votes > hold_votes:
            # print(f"ðŸ” DEBUG: Buy-Sell tie -> Hold")
            return 'Hold'
        # Jika tie lainnya, ambil yang pertama secara prioritas: Buy > Sell > Hold
        if buy_votes == max_votes:
            # print(f"ðŸ” DEBUG: Multi-way tie -> Buy priority")
            return 'Buy'
        elif sell_votes == max_votes:
            # print(f"ðŸ” DEBUG: Multi-way tie -> Sell priority")
            return 'Sell'
    
    # print(f"ðŸ” DEBUG: Default -> Hold")
    return 'Hold'

def apply_volume_filter(preliminary_result, volume_signal):
    """Apply volume filter to modify preliminary result"""
    if volume_signal == 'Low Volume':
        return 'Hold'  # Force Hold on low volume
    elif volume_signal == 'High Volume':
        return preliminary_result  # Let result stand on high volume
    else:
        return preliminary_result  # Normal volume, use preliminary result











# def calculate_combined_signal(df, selected_technicals):
#     """Calculate a combined signal based on all selected indicators using voting logic"""
#     # Initialize the signal column
#     df['Combined_Signal'] = 'Hold'
    
#     # Only process rows where we have all signals
#     for idx, row in df.iterrows():
#         signals = []
#         for tech in selected_technicals:
#             signal_col = tech
#             if signal_col in df.columns and not pd.isna(row[signal_col]):
#                 # Handle special cases for Volume and other non-standard signals
#                 if signal_col == 'Volume_Signal':
#                     # Convert volume signals to buy/sell/hold
#                     if row[signal_col] == 'High Volume':
#                         # High volume doesn't directly indicate buy/sell, so we keep it neutral
#                         signals.append('Hold')
#                     else:
#                         signals.append('Hold')
#                 else:
#                     signals.append(row[signal_col])
        
#         # Count signal types for voting
#         buy_count = signals.count('Buy')
#         sell_count = signals.count('Sell')
#         hold_count = signals.count('Hold')
        
#         # Determine majority signal with voting logic
#         total_signals = len(signals)
#         if total_signals == 0:
#             df.at[idx, 'Combined_Signal'] = 'Hold'
#         elif buy_count > sell_count and buy_count > hold_count:
#             # Majority buy
#             df.at[idx, 'Combined_Signal'] = 'Buy'
#         elif sell_count > buy_count and sell_count > hold_count:
#             # Majority sell
#             df.at[idx, 'Combined_Signal'] = 'Sell'
#         elif buy_count == sell_count and buy_count > hold_count:
#             # Tie between buy and sell, default to hold
#             df.at[idx, 'Combined_Signal'] = 'Hold'
#         else:
#             # Default to hold
#             df.at[idx, 'Combined_Signal'] = 'Hold'
        
#         # Add confidence level based on consensus
#         max_vote = max(buy_count, sell_count, hold_count)
#         confidence = (max_vote / total_signals * 100) if total_signals > 0 else 0
#         df.at[idx, 'Signal_Confidence'] = confidence
    
#     return df




def calculate_combined_signal(df, selected_technicals):
    """Calculate a combined signal based on all selected indicators - FIXED BACK TO ORIGINAL"""
    # Initialize the signal column
    df['Combined_Signal'] = 'Hold'
    
    # Only process rows where we have all signals
    for idx, row in df.iterrows():
        signals = []
        for tech in selected_technicals:
            signal_col = tech
            if signal_col in df.columns and not pd.isna(row[signal_col]):
                # Handle special cases for Volume and other non-standard signals
                if signal_col == 'Volume_Signal':
                    # Convert volume signals to buy/sell/hold
                    if row[signal_col] == 'High Volume':
                        # High volume doesn't directly indicate buy/sell, so we keep it neutral
                        signals.append('Hold')
                    else:
                        signals.append('Hold')
                else:
                    signals.append(row[signal_col])
        
        # Count signal types for voting
        buy_count = signals.count('Buy')
        sell_count = signals.count('Sell')
        hold_count = signals.count('Hold')
        
        # Determine majority signal with voting logic
        total_signals = len(signals)
        if total_signals == 0:
            df.at[idx, 'Combined_Signal'] = 'Hold'
        elif buy_count > sell_count and buy_count > hold_count:
            # Majority buy
            df.at[idx, 'Combined_Signal'] = 'Buy'
        elif sell_count > buy_count and sell_count > hold_count:
            # Majority sell
            df.at[idx, 'Combined_Signal'] = 'Sell'
        elif buy_count == sell_count and buy_count > hold_count:
            # Tie between buy and sell, default to hold
            df.at[idx, 'Combined_Signal'] = 'Hold'
        else:
            # Default to hold
            df.at[idx, 'Combined_Signal'] = 'Hold'
        
        # Add confidence level based on consensus
        max_vote = max(buy_count, sell_count, hold_count)
        confidence = (max_vote / total_signals * 100) if total_signals > 0 else 0
        df.at[idx, 'Signal_Confidence'] = confidence
    
    return df


# Update the existing calculate_combined_signal function calls in bulk_analysis.py
# def calculate_combined_signal(df, selected_technicals):
#     """Calculate a combined signal based on all selected indicators"""
#     # Initialize the signal column
#     df['Combined_Signal'] = None
    
#     # Only process rows where we have all signals
#     for idx, row in df.iterrows():
#         signals = []
#         for tech in selected_technicals:
#             signal_col = tech
#             if signal_col in df.columns and not pd.isna(row[signal_col]):
#                 # Handle special cases for Volume and other non-standard signals
#                 if signal_col == 'Volume_Signal':
#                     # Convert volume signals to buy/sell/hold
#                     if row[signal_col] == 'High Volume':
#                         # High volume can amplify other signals, but doesn't give direction alone
#                         # We'll treat it as neutral for voting purposes
#                         signals.append('Hold')
#                     else:
#                         signals.append('Hold')
#                 else:
#                     signals.append(row[signal_col])
        
#         # Count signal types
#         buy_count = signals.count('Buy')
#         sell_count = signals.count('Sell')
#         hold_count = signals.count('Hold')
        
#         # Determine majority signal
#         if buy_count > sell_count and buy_count > hold_count:
#             df.at[idx, 'Combined_Signal'] = 'Buy'
#         elif sell_count > buy_count and sell_count > hold_count:
#             df.at[idx, 'Combined_Signal'] = 'Sell'
#         else:
#             df.at[idx, 'Combined_Signal'] = 'Hold'
    
#     return df









# def run_backtest_for_indicator(df, indicator, capital):
#     """
#     Runs a backtest for a specific indicator
#     Returns a dictionary with backtest results
#     """
#     print(f"Running backtest for indicator: {indicator} with initial capital: {capital}")
    
#     if indicator not in df.columns and indicator != 'Combined_Signal':
#         print(f"ERROR: Indicator '{indicator}' not found in dataframe columns: {df.columns.tolist()}")
#         return None
    
#     signal_col = indicator
    
#     # Use the indicator column for backtesting
#     df_sorted = df.sort_values('Datetime')
#     print(f"Backtest data spans from {df_sorted['Datetime'].min()} to {df_sorted['Datetime'].max()}")
    
#     # Initialize backtest variables with proper type conversion
#     try:
#         cash = float(capital)  # Ensure capital is a float
#     except (ValueError, TypeError):
#         print(f"ERROR: Invalid capital value: {capital}")
#         return None
        
#     position = 0
#     trades = []
    
#     # Run backtest with NaN protection
#     for i, row in df_sorted.iterrows():
#         signal = row[signal_col]
        
#         # Skip rows with NaN signal or price
#         if pd.isna(signal) or pd.isna(row['Close']):
#             continue
            
#         price = float(row['Close'])  # Ensure price is float
        
#         # Additional validation for price
#         if price <= 0 or not np.isfinite(price):
#             continue
            
#         if signal == 'Buy' and cash > 0:
#             # Buy as many shares as we can with NaN protection
#             try:
#                 shares_to_buy = int(cash / price)
#                 if shares_to_buy > 0 and np.isfinite(shares_to_buy):
#                     cost = shares_to_buy * price
#                     cash -= cost
#                     position += shares_to_buy
                    
#                     trades.append({
#                         'type': 'Buy',
#                         'date': row['Datetime'],
#                         'price': price,
#                         'shares': shares_to_buy,
#                         'value': cost,
#                         'remaining_cash': cash
#                     })
#                     print(f"BUY: {shares_to_buy} shares at {price} = {cost} on {row['Datetime']}")
#             except (ValueError, OverflowError, ZeroDivisionError) as e:
#                 print(f"Error in buy calculation: {e}")
#                 continue
                
#         elif signal == 'Sell' and position > 0:
#             # Sell all shares
#             try:
#                 proceeds = position * price
#                 if np.isfinite(proceeds):
#                     cash += proceeds
                    
#                     trades.append({
#                         'type': 'Sell',
#                         'date': row['Datetime'],
#                         'price': price,
#                         'shares': position,
#                         'value': proceeds,
#                         'remaining_cash': cash
#                     })
#                     print(f"SELL: {position} shares at {price} = {proceeds} on {row['Datetime']}")
                    
#                     position = 0
#             except (ValueError, OverflowError) as e:
#                 print(f"Error in sell calculation: {e}")
#                 continue
    
#     # Calculate final portfolio value and performance metrics with NaN protection
#     try:
#         final_price = float(df_sorted['Close'].iloc[-1])
#         if pd.isna(final_price) or not np.isfinite(final_price):
#             final_price = 0
            
#         final_portfolio_value = cash + (position * final_price if position > 0 else 0)
        
#         # Calculate performance metrics with division by zero protection
#         initial_capital = float(capital)
#         total_profit = final_portfolio_value - initial_capital
#         profit_percentage = (total_profit / initial_capital) * 100 if initial_capital > 0 else 0
        
#         # Calculate win rate with proper validation
#         win_rate = 0
#         if len(trades) > 1:
#             buy_trades = [t for t in trades if t['type'] == 'Buy']
#             sell_trades = [t for t in trades if t['type'] == 'Sell']
            
#             winning_trades = 0
#             total_trade_pairs = min(len(buy_trades), len(sell_trades))
            
#             for i in range(total_trade_pairs):
#                 try:
#                     if sell_trades[i]['price'] > buy_trades[i]['price']:
#                         winning_trades += 1
#                 except (IndexError, KeyError, TypeError):
#                     continue
            
#             win_rate = (winning_trades / total_trade_pairs) * 100 if total_trade_pairs > 0 else 0
        
#         print(f"Backtest results: trades={len(trades)}, profit={profit_percentage:.2f}%, win_rate={win_rate:.2f}%")
        
#         # Return results with proper validation
#         return {
#             'initial_capital': float(initial_capital),
#             'final_capital': float(final_portfolio_value) if np.isfinite(final_portfolio_value) else float(initial_capital),
#             'total_profit': float(total_profit) if np.isfinite(total_profit) else 0.0,
#             'profit_percentage': float(profit_percentage) if np.isfinite(profit_percentage) else 0.0,
#             'num_trades': len(trades),
#             'win_rate': float(win_rate) if np.isfinite(win_rate) else 0.0,
#             'trades': trades
#         }
        
#     except Exception as e:
#         print(f"Error in final calculations: {e}")
#         return {
#             'initial_capital': float(capital),
#             'final_capital': float(capital),
#             'total_profit': 0.0,
#             'profit_percentage': 0.0,
#             'num_trades': 0,
#             'win_rate': 0.0,
#             'trades': []
#         }


#backtest analysis dari sinyal buy pertama dengan sell pertama secara langsung
# def run_backtest_for_indicator(df, indicator, capital):
#     """
#     Runs a backtest for a specific indicator.
#     Prevents the last buy signal if no subsequent sell signal exists.
#     Returns a dictionary with backtest results.
#     """
#     print(f"Running backtest for indicator: {indicator} with initial capital: {capital}")
    
#     if indicator not in df.columns and indicator != 'Combined_Signal':
#         print(f"ERROR: Indicator '{indicator}' not found in dataframe columns: {df.columns.tolist()}")
#         return None
    
#     signal_col = indicator
    
#     # Use the indicator column for backtesting
#     df_sorted = df.sort_values('Datetime').reset_index(drop=True) # MODIFIKASI: Reset index for easy slicing
#     print(f"Backtest data spans from {df_sorted['Datetime'].min()} to {df_sorted['Datetime'].max()}")
    
#     # Initialize backtest variables with proper type conversion
#     try:
#         cash = float(capital)
#     except (ValueError, TypeError):
#         print(f"ERROR: Invalid capital value: {capital}")
#         return None
        
#     position = 0
#     trades = []
    
#     # Run backtest with NaN protection
#     for i, row in df_sorted.iterrows():
#         signal = row[signal_col]
        
#         if pd.isna(signal) or pd.isna(row['Close']):
#             continue
            
#         price = float(row['Close'])
        
#         if price <= 0 or not np.isfinite(price):
#             continue
            
#         if signal == 'Buy' and cash > 0:
#             # BARU: Logika untuk memeriksa apakah ada sinyal 'Sell' di masa depan
#             # Kita melihat semua baris setelah baris saat ini (i + 1)
#             future_signals = df_sorted.loc[i + 1:, signal_col]
#             if 'Sell' not in future_signals.values:
#                 print(f"INFO: Ignoring final Buy signal on {row['Datetime']} as no subsequent Sell signal found.")
#                 continue  # Lewati sinyal Beli ini

#             # Jika ada sinyal 'Sell' di masa depan, lanjutkan eksekusi Beli
#             try:
#                 shares_to_buy = int(cash / price)
#                 if shares_to_buy > 0 and np.isfinite(shares_to_buy):
#                     cost = shares_to_buy * price
#                     cash -= cost
#                     position += shares_to_buy
                    
#                     trades.append({
#                         'type': 'Buy',
#                         'date': row['Datetime'],
#                         'price': price,
#                         'shares': shares_to_buy,
#                         'value': cost,
#                         'remaining_cash': cash
#                     })
#                     print(f"BUY: {shares_to_buy} shares at {price} = {cost} on {row['Datetime']}")
#             except (ValueError, OverflowError, ZeroDivisionError) as e:
#                 print(f"Error in buy calculation: {e}")
#                 continue
                
#         elif signal == 'Sell' and position > 0:
#             try:
#                 proceeds = position * price
#                 if np.isfinite(proceeds):
#                     cash += proceeds
                    
#                     trades.append({
#                         'type': 'Sell',
#                         'date': row['Datetime'],
#                         'price': price,
#                         'shares': position,
#                         'value': proceeds,
#                         'remaining_cash': cash
#                     })
#                     print(f"SELL: {position} shares at {price} = {proceeds} on {row['Datetime']}")
                    
#                     position = 0
#             except (ValueError, OverflowError) as e:
#                 print(f"Error in sell calculation: {e}")
#                 continue
    
#     # Calculate final portfolio value and performance metrics
#     # MODIFIKASI: Tidak perlu menghitung nilai posisi akhir karena logikanya sudah mencegah posisi terbuka
#     final_portfolio_value = cash
    
#     try:
#         initial_capital = float(capital)
#         total_profit = final_portfolio_value - initial_capital
#         profit_percentage = (total_profit / initial_capital) * 100 if initial_capital > 0 else 0
        
#         win_rate = 0
#         if len(trades) > 1:
#             buy_trades = [t for t in trades if t['type'] == 'Buy']
#             sell_trades = [t for t in trades if t['type'] == 'Sell']
            
#             winning_trades = 0
#             # Jumlah pasangan trade adalah jumlah sell, karena setiap sell menutup satu buy
#             total_trade_pairs = len(sell_trades)
            
#             # Memastikan buy dan sell berpasangan
#             num_pairs_to_check = min(len(buy_trades), len(sell_trades))

#             for i in range(num_pairs_to_check):
#                 try:
#                     if sell_trades[i]['price'] > buy_trades[i]['price']:
#                         winning_trades += 1
#                 except (IndexError, KeyError, TypeError):
#                     continue
            
#             win_rate = (winning_trades / total_trade_pairs) * 100 if total_trade_pairs > 0 else 0
        
#         print(f"\nBacktest finished. Final portfolio value: {final_portfolio_value:.2f}")
#         print(f"Results: trades={len(trades)}, profit={profit_percentage:.2f}%, win_rate={win_rate:.2f}%")
        
#         return {
#             'initial_capital': float(initial_capital),
#             'final_capital': float(final_portfolio_value),
#             'total_profit': float(total_profit),
#             'profit_percentage': float(profit_percentage),
#             'num_trades': len(trades),
#             'win_rate': float(win_rate),
#             'trades': trades
#         }
        
#     except Exception as e:
#         print(f"Error in final calculations: {e}")
#         return {
#             'initial_capital': float(capital),
#             'final_capital': float(capital),
#             'total_profit': 0.0,
#             'profit_percentage': 0.0,
#             'num_trades': 0,
#             'win_rate': 0.0,
#             'trades': []
#         }






# def run_backtest_for_indicator(df, indicator, capital):
    
#     print(f"--- Running Sophisticated Backtest for: {indicator} with Initial Capital: {capital} ---")
    
#     required_cols = [indicator, 'Volume', 'Close', 'Datetime']
#     if indicator == 'Combined_Signal': required_cols.remove(indicator)
        
#     for col in required_cols:
#         if col not in df.columns:
#             print(f"ERROR: Required column '{col}' not found in DataFrame.")
#             return None

#     signal_col = indicator
#     df_sorted = df.sort_values('Datetime').reset_index(drop=True)
#     print(f"Backtest data spans from {df_sorted['Datetime'].min()} to {df_sorted['Datetime'].max()}")

#     try:
#         cash = float(capital)
#     except (ValueError, TypeError):
#         print(f"ERROR: Invalid capital value: {capital}")
#         return None
        
#     position = 0
#     trades = []
    
#     all_combinations_log = []
    
#     in_buy_cycle = False
#     cycle_start_index = -1

#     for i, row in df_sorted.iterrows():
#         signal = row[signal_col]
        
#         if not in_buy_cycle and signal == 'Buy':
#             if 'Sell' in df_sorted.loc[i:, signal_col].values:
#                 in_buy_cycle = True
#                 cycle_start_index = i
#                 print(f"\n--- INFO: Cycle detected starting around {row['Datetime'].date()}. Awaiting Sell signal to analyze. ---")
#             else:
#                 print(f"INFO: Ignoring final Buy signal group starting at {row['Datetime'].date()} as no subsequent Sell signal found.")
#                 break

#         elif in_buy_cycle and signal == 'Sell':
#             cycle_df = df_sorted.loc[cycle_start_index:i]
#             buy_signals_in_cycle = cycle_df[cycle_df[signal_col] == 'Buy']
#             sell_signals_in_cycle = cycle_df[cycle_df[signal_col] == 'Sell']

#             if buy_signals_in_cycle.empty or sell_signals_in_cycle.empty:
#                 in_buy_cycle = False
#                 continue

#             best_combination_for_execution = None
#             max_profit = -np.inf

#             for buy_idx, buy_row in buy_signals_in_cycle.iterrows():
#                 valid_sells = sell_signals_in_cycle[sell_signals_in_cycle['Datetime'] > buy_row['Datetime']]
#                 if valid_sells.empty: continue

#                 for sell_idx, sell_row in valid_sells.iterrows():
#                     profit_per_share = sell_row['Close'] - buy_row['Close']
                    
#                     current_combination = {
#                         'cycle_id': len(trades) // 2 + 1,
#                         'buy_date': buy_row['Datetime'], 'buy_price': buy_row['Close'], 'buy_volume': buy_row['Volume'],
#                         'sell_date': sell_row['Datetime'], 'sell_price': sell_row['Close'], 'sell_volume': sell_row['Volume'],
#                         'profit_per_share': profit_per_share
#                     }
#                     all_combinations_log.append(current_combination)
                    
#                     if profit_per_share > max_profit:
#                         max_profit = profit_per_share
#                         best_combination_for_execution = current_combination

#             if not best_combination_for_execution:
#                 in_buy_cycle = False
#                 continue

#             if cash > 0:
#                 best_buy_price = best_combination_for_execution['buy_price']
#                 best_sell_price = best_combination_for_execution['sell_price']
                
#                 shares_to_buy = int(cash / best_buy_price)
#                 if shares_to_buy > 0:
#                     cost = shares_to_buy * best_buy_price
#                     cash -= cost
                    
#                     proceeds = shares_to_buy * best_sell_price
#                     cash += proceeds
                    
#                     trades.append({
#                         'type': 'Buy', 'date': best_combination_for_execution['buy_date'], 'price': best_buy_price,
#                         'volume': best_combination_for_execution['buy_volume'], 'shares': shares_to_buy,
#                         'value': cost, 'remaining_cash': cash - (proceeds - cost)
#                     })
#                     trades.append({
#                         'type': 'Sell', 'date': best_combination_for_execution['sell_date'], 'price': best_sell_price,
#                         'volume': best_combination_for_execution['sell_volume'], 'shares': shares_to_buy,
#                         'value': proceeds, 'remaining_cash': cash
#                     })
                    
#                     status = "PROFIT" if max_profit > 0 else "LOSS"
#                     print(f"OPTIMAL TRADE EXECUTED: BUY on {best_combination_for_execution['buy_date'].date()} | SELL on {best_combination_for_execution['sell_date'].date()} | Result: {status} of {max_profit * shares_to_buy:.2f}")

#             in_buy_cycle = False

#     final_portfolio_value = cash
#     initial_capital = float(capital)
#     total_profit = final_portfolio_value - initial_capital
#     profit_percentage = (total_profit / initial_capital) * 100 if initial_capital > 0 else 0
    
#     total_executed_cycles = len(trades) // 2
#     winning_trades_executed = 0
#     if total_executed_cycles > 0:
#         buy_trades = [t for t in trades if t['type'] == 'Buy']
#         sell_trades = [t for t in trades if t['type'] == 'Sell']
#         for i in range(total_executed_cycles):
#             if sell_trades[i]['price'] > buy_trades[i]['price']:
#                 winning_trades_executed += 1
#     win_rate = (winning_trades_executed / total_executed_cycles) * 100 if total_executed_cycles > 0 else 0
    
#     print(f"\n--- Backtest Finished (Based on Executed Optimal Trades). Final Portfolio Value: {final_portfolio_value:.2f} ---")
#     print(f"Results: {total_executed_cycles} trade cycles executed.")
#     print(f"Profit: {total_profit:.2f} ({profit_percentage:.2f}%) | Win Rate: {win_rate:.2f}%")

#     if all_combinations_log:
#         analysis_df = pd.DataFrame(all_combinations_log)
#         analysis_df['is_win'] = analysis_df['profit_per_share'] > 0
        
#         avg_buy_volume_win = analysis_df[analysis_df['is_win']]['buy_volume'].mean()
#         avg_buy_volume_loss = analysis_df[~analysis_df['is_win']]['buy_volume'].mean()
#         avg_sell_volume_win = analysis_df[analysis_df['is_win']]['sell_volume'].mean()
#         avg_sell_volume_loss = analysis_df[~analysis_df['is_win']]['sell_volume'].mean()

#         print("\n--- Volume Impact Analysis (Based on ALL Possible Combinations) ---")
#         print(f"Total combinations analyzed: {len(all_combinations_log)}")
#         print(f"Avg. Buy Volume on Winning Combinations: {avg_buy_volume_win:,.0f}")
#         print(f"Avg. Buy Volume on Losing Combinations:  {avg_buy_volume_loss:,.0f}")
#         print(f"Avg. Sell Volume on Winning Combinations: {avg_sell_volume_win:,.0f}")
#         print(f"Avg. Sell Volume on Losing Combinations:  {avg_sell_volume_loss:,.0f}")

#         volume_conclusion = []
#         if not pd.isna(avg_buy_volume_win) and not pd.isna(avg_buy_volume_loss) and avg_buy_volume_win > avg_buy_volume_loss:
#             volume_conclusion.append("Higher buy volume is generally correlated with winning combinations.")
#         else:
#             volume_conclusion.append("Lower or similar buy volume is generally correlated with winning combinations.")
        
#         if not pd.isna(avg_sell_volume_win) and not pd.isna(avg_sell_volume_loss) and avg_sell_volume_win > avg_sell_volume_loss:
#             volume_conclusion.append("Higher sell volume is generally correlated with winning combinations (profit taking).")
#         else:
#             volume_conclusion.append("Lower or similar sell volume is generally correlated with winning combinations.")
        
#         volume_summary = " ".join(volume_conclusion)
#         print(f"Conclusion: {volume_summary}")
#     else:
#         volume_summary = "Not enough data for volume analysis."

#     # --- FIX: Mengembalikan nama kunci ke 'trades' untuk konsistensi ---
#     return {
#         'initial_capital': initial_capital,
#         'final_capital': final_portfolio_value,
#         'total_profit': total_profit,
#         'profit_percentage': profit_percentage,
#         'num_executed_cycles': total_executed_cycles, 
#         'num_trades': len(trades),
#         'win_rate': win_rate,
#         'trades': trades, 
#         'all_possible_combinations': all_combinations_log,
#         'volume_analysis_summary': volume_summary
#     }

def run_backtest_for_indicator(df, indicator, capital):
    
    print(f"--- Running Sophisticated Backtest for: {indicator} with Initial Capital: {capital} ---")
    
    required_cols = [indicator, 'Volume', 'Close', 'Datetime']
    if indicator == 'Combined_Signal': required_cols.remove(indicator)
        
    for col in required_cols:
        if col not in df.columns:
            print(f"ERROR: Required column '{col}' not found in DataFrame.")
            return None

    signal_col = indicator
    df_sorted = df.sort_values('Datetime').reset_index(drop=True)
    print(f"Backtest data spans from {df_sorted['Datetime'].min()} to {df_sorted['Datetime'].max()}")

    try:
        cash = float(capital)
    except (ValueError, TypeError):
        print(f"ERROR: Invalid capital value: {capital}")
        return None
        
    position = 0
    trades = []
    
    all_combinations_log = []
    
    in_buy_cycle = False
    cycle_start_index = -1

    for i, row in df_sorted.iterrows():
        signal = row[signal_col]
        
        if not in_buy_cycle and signal == 'Buy':
            if 'Sell' in df_sorted.loc[i:, signal_col].values:
                in_buy_cycle = True
                cycle_start_index = i
                print(f"\n--- INFO: Cycle detected starting around {row['Datetime'].date()}. Awaiting Sell signal to analyze. ---")
            else:
                print(f"INFO: Ignoring final Buy signal group starting at {row['Datetime'].date()} as no subsequent Sell signal found.")
                break

        elif in_buy_cycle and signal == 'Sell':
            cycle_df = df_sorted.loc[cycle_start_index:i]
            buy_signals_in_cycle = cycle_df[cycle_df[signal_col] == 'Buy']
            sell_signals_in_cycle = cycle_df[cycle_df[signal_col] == 'Sell']

            if buy_signals_in_cycle.empty or sell_signals_in_cycle.empty:
                in_buy_cycle = False
                continue

            best_combination_for_execution = None
            max_profit = -np.inf

            for buy_idx, buy_row in buy_signals_in_cycle.iterrows():
                valid_sells = sell_signals_in_cycle[sell_signals_in_cycle['Datetime'] > buy_row['Datetime']]
                if valid_sells.empty: continue

                for sell_idx, sell_row in valid_sells.iterrows():
                    profit_per_share = sell_row['Close'] - buy_row['Close']
                    
                    current_combination = {
                        'cycle_id': len(trades) // 2 + 1,
                        'buy_date': buy_row['Datetime'], 'buy_price': buy_row['Close'], 'buy_volume': buy_row['Volume'],
                        'sell_date': sell_row['Datetime'], 'sell_price': sell_row['Close'], 'sell_volume': sell_row['Volume'],
                        'profit_per_share': profit_per_share
                    }
                    all_combinations_log.append(current_combination)
                    
                    if profit_per_share > max_profit:
                        max_profit = profit_per_share
                        best_combination_for_execution = current_combination

            if not best_combination_for_execution:
                in_buy_cycle = False
                continue

            if cash > 0:
                best_buy_price = best_combination_for_execution['buy_price']
                best_sell_price = best_combination_for_execution['sell_price']
                
                shares_to_buy = int(cash / best_buy_price)
                if shares_to_buy > 0:
                    cost = shares_to_buy * best_buy_price
                    cash -= cost
                    
                    proceeds = shares_to_buy * best_sell_price
                    cash += proceeds
                    
                    trades.append({
                        'type': 'Buy', 'date': best_combination_for_execution['buy_date'], 'price': best_buy_price,
                        'volume': best_combination_for_execution['buy_volume'], 'shares': shares_to_buy,
                        'value': cost, 'remaining_cash': cash - (proceeds - cost)
                    })
                    trades.append({
                        'type': 'Sell', 'date': best_combination_for_execution['sell_date'], 'price': best_sell_price,
                        'volume': best_combination_for_execution['sell_volume'], 'shares': shares_to_buy,
                        'value': proceeds, 'remaining_cash': cash
                    })
                    
                    status = "PROFIT" if max_profit > 0 else "LOSS"
                    print(f"OPTIMAL TRADE EXECUTED: BUY on {best_combination_for_execution['buy_date'].date()} | SELL on {best_combination_for_execution['sell_date'].date()} | Result: {status} of {max_profit * shares_to_buy:.2f}")

            in_buy_cycle = False

    final_portfolio_value = cash
    initial_capital = float(capital)
    total_profit = final_portfolio_value - initial_capital
    profit_percentage = (total_profit / initial_capital) * 100 if initial_capital > 0 else 0
    
    total_executed_cycles = len(trades) // 2
    winning_trades_executed = 0
    if total_executed_cycles > 0:
        buy_trades = [t for t in trades if t['type'] == 'Buy']
        sell_trades = [t for t in trades if t['type'] == 'Sell']
        for i in range(total_executed_cycles):
            if sell_trades[i]['price'] > buy_trades[i]['price']:
                winning_trades_executed += 1
    win_rate = (winning_trades_executed / total_executed_cycles) * 100 if total_executed_cycles > 0 else 0
    
    print(f"\n--- Backtest Finished (Based on Executed Optimal Trades). Final Portfolio Value: {final_portfolio_value:.2f} ---")
    print(f"Results: {total_executed_cycles} trade cycles executed.")
    print(f"Profit: {total_profit:.2f} ({profit_percentage:.2f}%) | Win Rate: {win_rate:.2f}%")

    # --- PERUBAHAN DIMULAI DI SINI ---
    volume_summary = "Tidak cukup data untuk analisis volume."
    if all_combinations_log:
        analysis_df = pd.DataFrame(all_combinations_log)
        if not analysis_df.empty:
            analysis_df['is_win'] = analysis_df['profit_per_share'] > 0

            # Cek apakah ada data untuk kelompok menang dan kalah
            has_wins = 'buy_volume' in analysis_df.columns and analysis_df['is_win'].any()
            has_losses = 'buy_volume' in analysis_df.columns and (~analysis_df['is_win']).any()

            avg_buy_volume_win = analysis_df[analysis_df['is_win']]['buy_volume'].mean() if has_wins else np.nan
            avg_buy_volume_loss = analysis_df[~analysis_df['is_win']]['buy_volume'].mean() if has_losses else np.nan
            avg_sell_volume_win = analysis_df[analysis_df['is_win']]['sell_volume'].mean() if has_wins else np.nan
            avg_sell_volume_loss = analysis_df[~analysis_df['is_win']]['sell_volume'].mean() if has_losses else np.nan

            summary_lines = []
            # Analisis Volume Beli
            if not pd.isna(avg_buy_volume_win) and not pd.isna(avg_buy_volume_loss):
                if avg_buy_volume_win > avg_buy_volume_loss:
                    summary_lines.append(f"Analisis Volume Beli: Rata-rata volume pada sinyal Beli yang profit ({avg_buy_volume_win:,.0f}) lebih TINGGI daripada yang rugi ({avg_buy_volume_loss:,.0f}). Ini mengindikasikan sinyal beli lebih valid saat didukung volume besar.")
                else:
                    summary_lines.append(f"Analisis Volume Beli: Rata-rata volume pada sinyal Beli yang profit ({avg_buy_volume_win:,.0f}) lebih RENDAH/serupa daripada yang rugi ({avg_buy_volume_loss:,.0f}). Ini bisa berarti pembelian yang menguntungkan terjadi di kondisi pasar yang lebih tenang.")
            else:
                summary_lines.append("Analisis Volume Beli: Korelasi volume beli dengan profit tidak dapat disimpulkan (data tidak lengkap).")
            
            # Analisis Volume Jual
            if not pd.isna(avg_sell_volume_win) and not pd.isna(avg_sell_volume_loss):
                if avg_sell_volume_win > avg_sell_volume_loss:
                    summary_lines.append(f"Analisis Volume Jual: Rata-rata volume pada sinyal Jual yang profit ({avg_sell_volume_win:,.0f}) lebih TINGGI daripada yang rugi ({avg_sell_volume_loss:,.0f}). Ini adalah ciri khas dari aksi ambil untung (profit taking) yang kuat.")
                else:
                    summary_lines.append(f"Analisis Volume Jual: Rata-rata volume pada sinyal Jual yang profit ({avg_sell_volume_win:,.0f}) lebih RENDAH/serupa daripada yang rugi ({avg_sell_volume_loss:,.0f}). Ini mungkin mengindikasikan profit direalisasikan sebelum tekanan jual masif muncul.")
            else:
                summary_lines.append("Analisis Volume Jual: Korelasi volume jual dengan profit tidak dapat disimpulkan (data tidak lengkap).")
            
            volume_summary = "\n".join(summary_lines)
        
    
    return {
        'initial_capital': initial_capital,
        'final_capital': final_portfolio_value,
        'total_profit': total_profit,
        'profit_percentage': profit_percentage,
        'num_executed_cycles': total_executed_cycles, 
        'num_trades': len(trades),
        'win_rate': win_rate,
        'trades': trades, 
        'all_possible_combinations': all_combinations_log,
        'volume_analysis_summary': volume_summary
    }







def create_leaderboard(leaderboard_data):
    """Create an enhanced leaderboard component with visualizations"""
    if not leaderboard_data:
        return html.Div("No leaderboard data available", className="text-center text-gray-500 p-4")
    
    # Create tabs for different analysis types
    leaderboard_tabs = [
        # Performance Analysis Tab
        dcc.Tab(label="Performance Analysis", children=[
            html.Div([
                html.H3("Performance Leaderboard", className="text-lg font-semibold mb-4"),
                html.P("Ranked by profit percentage. Showing top performing ticker-indicator combinations.", 
                       className="text-gray-600 mb-4"),
                
                # Top performer insight
                create_top_performer_insight(leaderboard_data),
                
                # Visualization
                create_performance_chart(leaderboard_data),
                
                # Leaderboard table
                dash_table.DataTable(
                    data=leaderboard_data,
                    columns=[
                        {'name': 'Ticker', 'id': 'ticker'},
                        {'name': 'Indicator', 'id': 'indicator'},
                        {'name': 'Profit %', 'id': 'profit_percentage', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                        {'name': 'Total Profit', 'id': 'total_profit', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                        {'name': 'Win Rate', 'id': 'win_rate', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                        {'name': 'Trades', 'id': 'num_trades', 'type': 'numeric'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{profit_percentage} > 0'},
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{profit_percentage} < 0'},
                            'color': 'red'
                        },
                        {
                            'if': {'row_index': 0},
                            'backgroundColor': 'rgba(102, 204, 102, 0.2)',
                            'fontWeight': 'bold'
                        }
                    ],
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    sort_action='native',
                    filter_action='native',
                    page_size=15
                )
            ])
        ]),
        
        # Trading Scenarios Tab
        dcc.Tab(label="Trading Scenarios", children=[
            html.Div([
                html.H3("Trading Scenarios Leaderboard", className="text-lg font-semibold mb-4"),
                html.P("Analysis of different trading strategies across tickers.", 
                       className="text-gray-600 mb-4"),
                
                # Best scenario summary
                create_best_scenario_summary(leaderboard_data),
                
                # Trading statistics
                create_trading_stats_cards(leaderboard_data),
                
                # Scatter plot of trade count vs profit
                dcc.Graph(
                    figure=go.Figure(
                        data=[
                            go.Scatter(
                                x=[item['num_trades'] for item in leaderboard_data],
                                y=[item['profit_percentage'] for item in leaderboard_data],
                                mode='markers',
                                marker=dict(
                                    size=10,
                                    color=[item['profit_percentage'] for item in leaderboard_data],
                                    colorscale='RdYlGn',
                                    colorbar=dict(title='Profit %'),
                                    showscale=True
                                ),
                                text=[f"{item['ticker']} - {item['indicator']}" for item in leaderboard_data],
                                hovertemplate='<b>%{text}</b><br>Trades: %{x}<br>Profit: %{y:.2f}%<extra></extra>'
                            )
                        ],
                        layout=go.Layout(
                            title='Trade Count vs Profit Percentage',
                            xaxis_title='Number of Trades',
                            yaxis_title='Profit %',
                            height=500,
                            template='plotly_white'
                        )
                    ),
                    className="mb-6"
                )
            ])
        ])
    ]
    
    return html.Div([
        dcc.Tabs(leaderboard_tabs)
    ])

# Helper functions
def create_top_performer_insight(leaderboard_data):
    """Create the top performer insight card"""
    top_performer = leaderboard_data[0] if leaderboard_data else None
    if not top_performer:
        return html.Div()
        
    return html.Div([
        html.H4("Top Performer Insight", className="text-lg font-semibold mb-3"),
        html.Div([
            html.P([
                "The best performing combination was ",
                html.Strong(f"{top_performer['ticker']} using {top_performer['indicator']}"),
                f", which produced a return of ",
                html.Strong(f"{top_performer['profit_percentage']:.2f}%"),
                " with a win rate of ",
                html.Strong(f"{top_performer['win_rate']:.2f}%"),
                "."
            ]),
            html.P([
                "This performance suggests that ",
                html.Strong(f"{top_performer['indicator']}"),
                " is particularly effective for analyzing ",
                html.Strong(f"{top_performer['ticker']}"),
                " in the selected time period."
            ], className="mt-2")
        ], className="p-4 bg-green-50 border border-green-200 rounded")
    ], className="mb-6")

def create_performance_chart(leaderboard_data):
    """Create the performance chart"""
    # Show top 10 performers
    top_n = 10
    top_performers = leaderboard_data[:top_n] if len(leaderboard_data) > top_n else leaderboard_data
    
    fig = go.Figure()
    fig.add_trace(go.Bar(
        x=[f"{p['ticker']} ({p['indicator']})" for p in top_performers],
        y=[p['profit_percentage'] for p in top_performers],
        marker_color=['green' if p['profit_percentage'] > 0 else 'red' for p in top_performers],
        text=[f"{p['profit_percentage']:.2f}%" for p in top_performers],
        textposition='auto'
    ))
    fig.update_layout(
        title=f"Top {len(top_performers)} Performer(s) by Profit %",
        xaxis_title="Ticker (Indicator)",
        yaxis_title="Profit %",
        height=400,
        margin=dict(l=50, r=50, t=80, b=120),
        xaxis={'tickangle': -45}
    )
    
    return dcc.Graph(figure=fig, className="mb-6")

def create_best_scenario_summary(leaderboard_data):
    """Create the best scenario summary for trading scenarios tab"""
    best_scenario = leaderboard_data[0] if leaderboard_data else None
    if not best_scenario:
        return html.Div()
        
    return html.Div([
        html.H4("Best Trading Scenario", className="text-lg font-semibold mb-3"),
        html.Div([
            html.Div([
                html.Div([
                    html.Span("Ticker: ", className="font-semibold"),
                    html.Span(best_scenario['ticker'], className="ml-1 text-blue-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Indicator: ", className="font-semibold"),
                    html.Span(best_scenario['indicator'], className="ml-1 text-blue-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Profit: ", className="font-semibold"),
                    html.Span(f"{best_scenario['profit_percentage']:.2f}%", className="ml-1 text-green-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Win Rate: ", className="font-semibold"),
                    html.Span(f"{best_scenario['win_rate']:.2f}%", className="ml-1 text-green-600")
                ]),
            ], className="w-1/2"),
            html.Div([
                html.Div([
                    html.Span("Total Trades: ", className="font-semibold"),
                    html.Span(f"{best_scenario['num_trades']}", className="ml-1")
                ], className="mb-2"),
                html.Div([
                    html.Span("Total Profit: ", className="font-semibold"),
                    html.Span(f"{best_scenario['total_profit']:.2f}", className="ml-1 text-green-600")
                ], className="mb-2"),
            ], className="w-1/2"),
        ], className="flex p-4 bg-green-50 border border-green-200 rounded")
    ], className="mb-6")

def create_trading_stats_cards(leaderboard_data):
    """Create trading statistics cards"""
    if not leaderboard_data:
        return html.Div()
        
    # Calculate statistics
    total_trades = sum(item['num_trades'] for item in leaderboard_data)
    avg_profit = sum(item['profit_percentage'] for item in leaderboard_data) / len(leaderboard_data) if leaderboard_data else 0
    avg_win_rate = sum(item['win_rate'] for item in leaderboard_data) / len(leaderboard_data) if leaderboard_data else 0
    profitable_scenarios = sum(1 for item in leaderboard_data if item['profit_percentage'] > 0)
    
    return html.Div([
        html.H4("Trading Statistics", className="text-lg font-semibold mb-3"),
        html.Div([
            html.Div([
                html.Div([
                    html.Span("Total Trades", className="block text-sm text-gray-500"),
                    html.Span(f"{total_trades}", className="block text-xl font-bold text-blue-600")
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
            html.Div([
                html.Div([
                    html.Span("Average Profit", className="block text-sm text-gray-500"),
                    html.Span(f"{avg_profit:.2f}%", 
                             className=f"block text-xl font-bold {'text-green-600' if avg_profit > 0 else 'text-red-600'}")
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
            html.Div([
                html.Div([
                    html.Span("Average Win Rate", className="block text-sm text-gray-500"),
                    html.Span(f"{avg_win_rate:.2f}%", className="block text-xl font-bold text-blue-600")
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
            html.Div([
                html.Div([
                    html.Span("Profitable Scenarios", className="block text-sm text-gray-500"),
                    html.Span(f"{profitable_scenarios}/{len(leaderboard_data)}", className="block text-xl font-bold text-green-600")
                ], className="p-4 border rounded bg-white shadow-sm")
            ], className="w-1/4 px-2"),
        ], className="flex -mx-2 mb-6")
    ])



def create_detailed_results(ticker_details):
    """Create detailed results components from the data"""
    # Create tabs for each ticker
    ticker_tabs = []
    
    for ticker, results in ticker_details.items():
        # Create tabs for different analysis types (Analysis and Profit)
        analysis_tabs = [
            # Analysis Tab - Current implementation
            dcc.Tab(label="Performance Analysis", children=[
                html.Div([
                    html.H3(f"{ticker} Performance by Indicator", className="text-lg font-semibold mb-4"),
                    
                    # Table showing results for each indicator
                    dash_table.DataTable(
                        data=[{
                            'indicator': r['indicator'],
                            'profit_percentage': r['profit_percentage'],
                            'final_capital': r['final_capital'],
                            'num_trades': r['num_trades'],
                            'win_rate': r['win_rate']
                        } for r in results],
                        columns=[
                            {'name': 'Technical Indicator', 'id': 'indicator'},
                            {'name': 'Profit %', 'id': 'profit_percentage', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                            {'name': 'Final Capital', 'id': 'final_capital', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                            {'name': 'Number of Trades', 'id': 'num_trades', 'type': 'numeric'},
                            {'name': 'Win Rate %', 'id': 'win_rate', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}}
                        ],
                        style_table={'overflowX': 'auto'},
                        style_cell={'textAlign': 'left', 'padding': '10px'},
                        style_data_conditional=[
                            {
                                'if': {'filter_query': '{profit_percentage} > 0'},
                                'color': 'green'
                            },
                            {
                                'if': {'filter_query': '{profit_percentage} < 0'},
                                'color': 'red'
                            }
                        ],
                        style_header={
                            'backgroundColor': 'rgb(240, 240, 240)',
                            'fontWeight': 'bold'
                        },
                        sort_action='native'
                    ),
                    
                    # Visualization of performance
                    html.Div([
                        html.H4("Performance Comparison", className="text-lg font-semibold mt-6 mb-3"),
                        dcc.Graph(
                            figure=go.Figure(
                                data=[
                                    go.Bar(
                                        x=[r['indicator'] for r in results],
                                        y=[r['profit_percentage'] for r in results],
                                        marker_color=['green' if p > 0 else 'red' for p in [r['profit_percentage'] for r in results]],
                                        text=[f"{p:.2f}%" for p in [r['profit_percentage'] for r in results]],
                                        textposition='auto'
                                    )
                                ],
                                layout=go.Layout(
                                    title=f"Profit % by Indicator for {ticker}",
                                    xaxis_title="Indicator",
                                    yaxis_title="Profit %",
                                    height=400,
                                    margin=dict(l=50, r=50, t=80, b=100)
                                )
                            )
                        )
                    ])
                ])
            ]),
            
            # Profit Analysis Tab - Based on backtesting_profit logic
            dcc.Tab(label="Profit Analysis", children=[
                html.Div([
                    html.H3(f"{ticker} Trading Scenarios", className="text-lg font-semibold mb-4"),
                    
                    # Top scenarios summary
                    html.Div([
                        html.H4("Best Trading Scenarios", className="text-lg font-semibold mb-3"),
                        dash_table.DataTable(
                            data=[{
                                'Indicator': r['indicator'],
                                'Initial Capital': r['initial_capital'],
                                'Final Capital': r['final_capital'],
                                'Total Profit': r['total_profit'],
                                'Profit %': r['profit_percentage'],
                                'Trades': r['num_trades']
                            } for r in sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[:5]],  # Top 5 scenarios
                            columns=[
                                {'name': 'Indicator', 'id': 'Indicator'},
                                {'name': 'Initial Capital', 'id': 'Initial Capital', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                {'name': 'Final Capital', 'id': 'Final Capital', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                {'name': 'Total Profit', 'id': 'Total Profit', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                {'name': 'Profit %', 'id': 'Profit %', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                                {'name': 'Trades', 'id': 'Trades', 'type': 'numeric'},
                            ],
                            style_table={'overflowX': 'auto'},
                            style_cell={'textAlign': 'left', 'padding': '10px'},
                            style_data_conditional=[
                                {
                                    'if': {'row_index': 0},
                                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                    'fontWeight': 'bold'
                                }
                            ],
                            style_header={
                                'backgroundColor': 'rgb(240, 240, 240)',
                                'fontWeight': 'bold'
                            },
                        )
                    ], className="mb-6"),
                    
                    # Best scenario visual
                    html.Div([
                        html.H4("Best Scenario Performance", className="text-lg font-semibold mb-3"),
                        html.Div([
                            html.Div([
                                html.Span("Best Indicator: ", className="font-semibold"),
                                html.Span(sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[0]['indicator'], 
                                         className="ml-1 text-blue-600")
                            ], className="mb-2"),
                            html.Div([
                                html.Span("Total Profit: ", className="font-semibold"),
                                html.Span(f"{sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[0]['total_profit']:.2f}", 
                                         className="ml-1 text-green-600")
                            ], className="mb-2"),
                            html.Div([
                                html.Span("Win Rate: ", className="font-semibold"),
                                html.Span(f"{sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[0]['win_rate']:.2f}%", 
                                         className="ml-1 text-blue-600")
                            ], className="mb-2"),
                        ], className="p-4 bg-green-50 border border-green-200 rounded mb-4"),
                        
                        # Profit over time visualization
                        dcc.Graph(
                            figure=go.Figure(
                                data=[
                                    go.Scatter(
                                        x=[i for i in range(len(sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[0]['trades']))],
                                        y=[trade['remaining_cash'] if 'remaining_cash' in trade else 0 
                                           for trade in sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[0]['trades']],
                                        mode='lines+markers',
                                        name='Capital Growth',
                                        line=dict(color='blue', width=2)
                                    )
                                ],
                                layout=go.Layout(
                                    title=f"Capital Growth for Best Scenario ({sorted(results, key=lambda x: x['profit_percentage'], reverse=True)[0]['indicator']})",
                                    xaxis_title="Trade Number",
                                    yaxis_title="Capital",
                                    height=400,
                                    margin=dict(l=50, r=50, t=80, b=50)
                                )
                            )
                        )
                    ])
                ])
            ])
        ]
        
        ticker_tabs.append(dcc.Tab(label=ticker, children=[
            dcc.Tabs(analysis_tabs, className="mb-4")
        ]))
    
    if not ticker_tabs:
        return html.Div("No detailed results available", className="text-center text-gray-500 p-4")
    
    return html.Div([
        dcc.Tabs(ticker_tabs)
    ])

def create_trade_performance(trade_details):
    """Create trade performance components"""
    # Create tabs for each ticker
    ticker_tabs = []
    
    for ticker, indicators in trade_details.items():
        # Create analysis tabs
        analysis_type_tabs = [
            # Standard Analysis Tab
            dcc.Tab(label="Trade Analysis", children=[
                html.Div([
                    dcc.Tabs([
                        dcc.Tab(label=indicator, children=[
                            html.Div([
                                html.H4(f"Trade History - {indicator}", className="text-lg font-semibold mb-3"),
                                
                                # Trade table
                                dash_table.DataTable(
                                    data=[{
                                        'date': t['date'].strftime('%Y-%m-%d %H:%M:%S') if hasattr(t['date'], 'strftime') else str(t['date']),
                                        'type': t['type'],
                                        'price': t['price'],
                                        'shares': t['shares'],
                                        'value': t['value'],
                                        'cash': t['remaining_cash']
                                    } for t in trades],
                                    columns=[
                                        {'name': 'Date', 'id': 'date'},
                                        {'name': 'Type', 'id': 'type'},
                                        {'name': 'Price', 'id': 'price', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                        {'name': 'Shares', 'id': 'shares', 'type': 'numeric'},
                                        {'name': 'Value', 'id': 'value', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                        {'name': 'Cash', 'id': 'cash', 'type': 'numeric', 'format': {'specifier': ',.2f'}}
                                    ],
                                    style_table={'overflowX': 'auto'},
                                    style_cell={'textAlign': 'left', 'padding': '10px'},
                                    style_data_conditional=[
                                        {
                                            'if': {'filter_query': '{type} = "Buy"'},
                                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                                            'color': 'green'
                                        },
                                        {
                                            'if': {'filter_query': '{type} = "Sell"'},
                                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                                            'color': 'red'
                                        }
                                    ],
                                    style_header={
                                        'backgroundColor': 'rgb(240, 240, 240)',
                                        'fontWeight': 'bold'
                                    },
                                    page_size=10
                                ),
                                
                                # Performance chart
                                html.Div([
                                    html.H4("Cumulative Performance", className="text-lg font-semibold mt-6 mb-3"),
                                    dcc.Graph(
                                        figure=get_trade_performance_chart(trades, ticker, indicator)
                                    )
                                ])
                            ])
                        ]) for indicator, trades in indicators.items() if trades
                    ])
                ])
            ]),
            
            # Profit Analysis Tab - Based on backtesting_profit logic
            dcc.Tab(label="Trading Scenarios", children=[
                html.Div([
                    html.H3(f"Trading Scenarios for {ticker}", className="text-lg font-semibold mb-3"),
                    
                    # Compare all scenarios in one view
                    html.Div([
                        html.H4("Scenario Comparison", className="text-lg font-semibold mb-3"),
                        dash_table.DataTable(
                            data=[{
                                'Indicator': indicator,
                                'Initial Capital': trades[0]['remaining_cash'] if trades else 0,
                                'Final Capital': trades[-1]['remaining_cash'] if trades else 0,
                                'Total Profit': (trades[-1]['remaining_cash'] - trades[0]['remaining_cash']) if trades else 0,
                                'Profit %': ((trades[-1]['remaining_cash'] / trades[0]['remaining_cash'] - 1) * 100) if trades and trades[0]['remaining_cash'] > 0 else 0,
                                'Trades': len(trades),
                                'Buy/Sell Ratio': sum(1 for t in trades if t['type'] == 'Buy') / max(1, sum(1 for t in trades if t['type'] == 'Sell'))
                            } for indicator, trades in indicators.items() if trades],
                            columns=[
                                {'name': 'Indicator', 'id': 'Indicator'},
                                {'name': 'Initial Capital', 'id': 'Initial Capital', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                {'name': 'Final Capital', 'id': 'Final Capital', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                {'name': 'Total Profit', 'id': 'Total Profit', 'type': 'numeric', 'format': {'specifier': ',.2f'}},
                                {'name': 'Profit %', 'id': 'Profit %', 'type': 'numeric', 'format': {'specifier': '.2f', 'locale': {'symbol': ['', '%']}}},
                                {'name': 'Trades', 'id': 'Trades', 'type': 'numeric'},
                                {'name': 'Buy/Sell Ratio', 'id': 'Buy/Sell Ratio', 'type': 'numeric', 'format': {'specifier': '.2f'}}
                            ],
                            style_table={'overflowX': 'auto'},
                            style_cell={'textAlign': 'left', 'padding': '10px'},
                            style_data_conditional=[
                                {
                                    'if': {'filter_query': '{Total Profit} < 0'},
                                    'color': 'red'
                                },
                                {
                                    'if': {'filter_query': '{Total Profit} >= 0'},
                                    'color': 'green'
                                }
                            ],
                            style_header={
                                'backgroundColor': 'rgb(240, 240, 240)',
                                'fontWeight': 'bold'
                            },
                            sort_action='native'
                        )
                    ], className="mb-6"),
                    
                    # Comparative visualization
                    html.Div([
                        html.H4("Comparative Performance", className="text-lg font-semibold mb-3"),
                        dcc.Graph(
                            figure=get_comparative_performance_chart(indicators, ticker)
                        )
                    ])
                ])
            ])
        ]
        
        if not indicators:
            ticker_content = html.Div("No trade details available", className="text-center text-gray-500 p-4")
        else:
            ticker_content = html.Div([
                dcc.Tabs(analysis_type_tabs)
            ])
        
        ticker_tabs.append(dcc.Tab(label=ticker, children=[ticker_content]))
    
    if not ticker_tabs:
        return html.Div("No trade details available", className="text-center text-gray-500 p-4")
    
    return html.Div([
        dcc.Tabs(ticker_tabs)
    ])

# Helper functions for charts
def get_trade_performance_chart(trades, ticker, indicator):
    """Generate a performance chart for trades"""
    # Calculate cumulative performance
    cumulative_performance = []
    for idx, trade in enumerate(trades):
        cumulative_performance.append({
            'index': idx,
            'date': trade['date'],
            'capital': trade['remaining_cash'],
            'type': trade['type']
        })
    
    return go.Figure(
        data=[
            go.Scatter(
                x=[p['index'] for p in cumulative_performance],
                y=[p['capital'] for p in cumulative_performance],
                mode='lines+markers',
                name='Capital',
                line=dict(color='blue', width=2),
                marker=dict(
                    size=10,
                    color=['green' if p['type'] == 'Sell' else 'red' for p in cumulative_performance],
                    symbol=['triangle-up' if p['type'] == 'Buy' else 'triangle-down' for p in cumulative_performance]
                )
            )
        ],
        layout=go.Layout(
            title=f"Cumulative Performance for {ticker} using {indicator}",
            xaxis_title="Trade Number",
            yaxis_title="Capital",
            height=400,
            margin=dict(l=50, r=50, t=80, b=50)
        )
    )

def get_comparative_performance_chart(indicators, ticker):
    """Generate a chart comparing performance across different indicators"""
    traces = []
    
    for indicator, trades in indicators.items():
        if not trades:
            continue
            
        # Create a normalized series (starting at 100%)
        initial_capital = trades[0]['remaining_cash'] if trades else 0
        if initial_capital <= 0:
            continue
            
        performance_series = []
        for idx, trade in enumerate(trades):
            performance_series.append({
                'index': idx,
                'value': (trade['remaining_cash'] / initial_capital) * 100
            })
            
        traces.append(
            go.Scatter(
                x=[p['index'] for p in performance_series],
                y=[p['value'] for p in performance_series],
                mode='lines',
                name=indicator,
            )
        )
    
    return go.Figure(
        data=traces,
        layout=go.Layout(
            title=f"Comparative Performance by Indicator for {ticker}",
            xaxis_title="Trade Number",
            yaxis_title="Performance (%)",
            height=500,
            margin=dict(l=50, r=50, t=80, b=50),
            legend=dict(
                yanchor="top",
                y=0.99,
                xanchor="right",
                x=0.99
            )
        )
    )




def create_raw_data_tables(raw_data):
    """Create enhanced raw data tables components with interactive features"""
    print(f"Creating raw data tables with {len(raw_data)} tickers")
    
    if not raw_data or len(raw_data) == 0:
        print("WARNING: No raw data available")
        return html.Div("No raw data available", className="text-center text-gray-500 p-4")
    
    # Debug information
    for ticker, data in raw_data.items():
        print(f"Raw data for {ticker}: {len(data)} records")
        if len(data) > 0:
            print(f"First record sample: {list(data[0].keys())[:5]}...")
    
    # Create a ticker selector dropdown
    ticker_options = [{'label': ticker, 'value': ticker} for ticker in raw_data.keys()]
    
    return html.Div([
        html.Div([
            html.H3("Interactive Data Explorer", className="text-lg font-semibold mb-3"),
            html.P("Select a ticker to view detailed data", className="text-gray-600 mb-3"),
            dcc.Dropdown(
                id='raw-data-ticker-selector',
                options=ticker_options,
                value=list(raw_data.keys())[0] if raw_data else None,
                placeholder="Select a ticker",
                className="w-full mb-4"
            ),
            
            # Add search and filter capabilities
            html.Div([
                html.Div([
                    html.Label("Search:", className="mr-2 font-medium"),
                    dcc.Input(
                        id="raw-data-search",
                        type="text",
                        placeholder="Enter search term",
                        className="p-2 border rounded flex-grow"
                    )
                ], className="flex items-center mb-3"),
                
                html.Div([
                    html.Label("Filter by Signal:", className="mr-2 font-medium"),
                    dcc.Dropdown(
                        id="raw-data-signal-filter",
                        options=[
                            {'label': 'All Signals', 'value': 'all'},
                            {'label': 'Buy Signals', 'value': 'Buy'},
                            {'label': 'Sell Signals', 'value': 'Sell'},
                            {'label': 'Hold Signals', 'value': 'Hold'}
                        ],
                        value='all',
                        clearable=False,
                        className="w-64"
                    )
                ], className="flex items-center")
            ], className="mb-4 p-3 bg-gray-50 rounded"),
            
            # Tabs for different data views
            dcc.Tabs([
                # Data Analysis Tab
                dcc.Tab(label="Data Analysis", children=[
                    # Container for selected ticker data
                    html.Div(id="selected-ticker-data", className="mt-4"),
                ]),
                
                # Charts Tab
                dcc.Tab(label="Charts & Signals", children=[
                    # Visualization of data
                    html.Div([
                        html.H4("Data Visualization", className="text-lg font-semibold mt-3 mb-3"),
                        dcc.Tabs([
                            dcc.Tab(label="Price Chart", children=[
                                dcc.Loading(
                                    id="loading-price-chart",
                                    type="circle",
                                    children=html.Div(id="ticker-price-chart", className="mt-3")
                                )
                            ]),
                            dcc.Tab(label="Signal Distribution", children=[
                                dcc.Loading(
                                    id="loading-signal-chart",
                                    type="circle",
                                    children=html.Div(id="ticker-signal-chart", className="mt-3")
                                )
                            ]),
                            dcc.Tab(label="Technical Indicators", children=[
                                dcc.Loading(
                                    id="loading-indicators-chart",
                                    type="circle",
                                    children=html.Div(id="ticker-indicators-chart", className="mt-3")
                                )
                            ])
                        ])
                    ])
                ]),
                
                # Backtesting Tab
                dcc.Tab(label="Backtesting Analysis", children=[
                    html.Div([
                        html.H4("Backtesting Results", className="text-lg font-semibold mt-3 mb-3"),
                        html.P("Analysis of buy/sell signals on historical data", className="text-gray-600 mb-3"),
                        
                        # Signal effectiveness metrics
                        html.Div(id="ticker-backtesting-metrics", className="mt-3"),
                        
                        # Profit simulation
                        dcc.Loading(
                            id="loading-profit-simulation",
                            type="circle",
                            children=html.Div(id="ticker-profit-simulation", className="mt-3")
                        )
                    ])
                ])
            ])
        ], className="p-4 bg-white rounded-lg shadow-sm")
    ])





def extract_leaderboard_data(leaderboard_content):
    """Extract data from the leaderboard component for download"""
    # This would need to extract data from the dash components
    # Since we can't directly access the data in this context, we'll return a placeholder
    return [
        {'Ticker': 'BBCA.JK', 'Indicator': 'Bollinger_Signal', 'Profit %': 5.42, 'Win Rate': 65.0},
        {'Ticker': 'TLKM.JK', 'Indicator': 'MA_Signal', 'Profit %': 4.81, 'Win Rate': 62.5},
        {'Ticker': 'ASII.JK', 'Indicator': 'MACD_Signal', 'Profit %': 3.76, 'Win Rate': 58.3}
    ]




@app.callback(
    [Output("ticker-backtesting-metrics", "children"),
     Output("ticker-profit-simulation", "children")],
    [Input("raw-data-ticker-selector", "value")],
    [State("raw-data-explorer", "data")]
)
def update_backtesting_analysis(selected_ticker, raw_data):
    """Update the backtesting analysis for selected ticker"""
    if not selected_ticker or not raw_data or selected_ticker not in raw_data:
        return html.Div("Select a ticker to view backtesting metrics", 
                      className="text-gray-500 text-center p-4"), html.Div()
    
    try:
        # Get data for the selected ticker
        ticker_data = pd.DataFrame(raw_data[selected_ticker])
        
        # Check if we have signal data
        if 'Combined_Signal' not in ticker_data.columns:
            return html.Div("No signal data available for backtesting analysis",
                          className="text-gray-500 text-center p-4"), html.Div()
        
        # Calculate signal metrics
        buy_signals = ticker_data[ticker_data['Combined_Signal'] == 'Buy']
        sell_signals = ticker_data[ticker_data['Combined_Signal'] == 'Sell']
        total_signals = len(buy_signals) + len(sell_signals)
        
        # Calculate how many buy signals were followed by profitable sell signals
        profitable_trades = 0
        total_trades = 0
        
        if not buy_signals.empty and not sell_signals.empty:
            # Sort by datetime to ensure proper order
            buy_signals = buy_signals.sort_values('Datetime').reset_index(drop=True)
            sell_signals = sell_signals.sort_values('Datetime').reset_index(drop=True)
            
            # Track each potential buy signal
            for _, buy_row in buy_signals.iterrows():
                buy_time = buy_row['Datetime']
                buy_price = buy_row['Close']
                
                # Find the next sell signal after this buy
                next_sell = sell_signals[sell_signals['Datetime'] > buy_time]
                if not next_sell.empty:
                    sell_price = next_sell.iloc[0]['Close']
                    total_trades += 1
                    if sell_price > buy_price:
                        profitable_trades += 1
        
        win_rate = (profitable_trades / total_trades * 100) if total_trades > 0 else 0
        
        # Create metrics cards
        metrics_cards = html.Div([
            html.Div([
                html.Div([
                    html.Div([
                        html.Span("Total Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{total_signals}", className="block text-xl font-bold text-blue-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Buy Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{len(buy_signals)}", className="block text-xl font-bold text-green-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Sell Signals", className="block text-sm text-gray-500"),
                        html.Span(f"{len(sell_signals)}", className="block text-xl font-bold text-red-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
                html.Div([
                    html.Div([
                        html.Span("Win Rate", className="block text-sm text-gray-500"),
                        html.Span(f"{win_rate:.2f}%", className="block text-xl font-bold text-blue-600")
                    ], className="p-4 border rounded bg-white shadow-sm")
                ], className="w-1/4 px-2"),
            ], className="flex -mx-2 mb-6")
        ])
        
        # Create profit simulation
        # Simulate a basic trading strategy using the signals
        initial_capital = 10000000  # 10 million
        cash = initial_capital
        position = 0
        trades = []
        
        # Sort by datetime
        ticker_data = ticker_data.sort_values('Datetime').reset_index(drop=True)
        
        # Run simulation
        for idx, row in ticker_data.iterrows():
            signal = row['Combined_Signal'] if 'Combined_Signal' in row else None
            
            if signal == 'Buy' and cash > 0:
                # Buy as many shares as possible
                shares_to_buy = int(cash / row['Close'])
                if shares_to_buy > 0:
                    cost = shares_to_buy * row['Close']
                    cash -= cost
                    position += shares_to_buy
                    
                    trades.append({
                        'type': 'Buy',
                        'date': row['Datetime'],
                        'price': row['Close'],
                        'shares': shares_to_buy,
                        'value': cost,
                        'capital': cash + (position * row['Close'])
                    })
                    
            elif signal == 'Sell' and position > 0:
                # Sell all shares
                value = position * row['Close']
                cash += value
                
                trades.append({
                    'type': 'Sell',
                    'date': row['Datetime'],
                    'price': row['Close'],
                    'shares': position,
                    'value': value,
                    'capital': cash
                })
                
                position = 0
        
        # Calculate final capital including any remaining position
        final_capital = cash
        if position > 0:
            final_capital += position * ticker_data['Close'].iloc[-1]
        
        profit = final_capital - initial_capital
        profit_percentage = (profit / initial_capital) * 100
        
        # Create simulation results
        simulation_results = html.Div([
            html.H4("Profit Simulation", className="text-lg font-semibold mb-3"),
            
            # Summary metrics
            html.Div([
                html.Div([
                    html.Span("Initial Capital: ", className="font-semibold"),
                    html.Span(f"{initial_capital:,.2f}", className="ml-1")
                ], className="mb-2"),
                html.Div([
                    html.Span("Final Capital: ", className="font-semibold"),
                    html.Span(f"{final_capital:,.2f}", 
                             className=f"ml-1 {'text-green-600' if profit > 0 else 'text-red-600'}")
                ], className="mb-2"),
                html.Div([
                    html.Span("Total Profit: ", className="font-semibold"),
                    html.Span(f"{profit:,.2f} ({profit_percentage:.2f}%)",
                             className=f"ml-1 {'text-green-600' if profit > 0 else 'text-red-600'}")
                ], className="mb-2"),
                html.Div([
                    html.Span("Total Trades: ", className="font-semibold"),
                    html.Span(f"{len(trades)}", className="ml-1")
                ]),
            ], className="p-4 bg-gray-50 rounded mb-4"),
            
            # Capital growth chart
            dcc.Graph(
                figure=go.Figure(
                    data=[
                        go.Scatter(
                            x=[i for i in range(len(trades))],
                            y=[trade['capital'] for trade in trades],
                            mode='lines+markers',
                            name='Capital',
                            line=dict(color='blue', width=2),
                            marker=dict(
                                size=10,
                                color=['green' if trade['type'] == 'Sell' else 'red' for trade in trades],
                                symbol=['triangle-up' if trade['type'] == 'Buy' else 'triangle-down' for trade in trades]
                            )
                        ),
                        go.Scatter(
                            x=[0, len(trades)-1],
                            y=[initial_capital, initial_capital],
                            mode='lines',
                            name='Initial Capital',
                            line=dict(color='gray', width=1, dash='dash')
                        )
                    ],
                    layout=go.Layout(
                        title=f"Capital Growth for {selected_ticker}",
                        xaxis_title="Trade Number",
                        yaxis_title="Capital",
                        height=400,
                        margin=dict(l=50, r=50, t=80, b=50)
                    )
                )
            ),
            
            # Trades table
            html.Div([
                html.H4("Trade History", className="text-lg font-semibold mt-4 mb-3"),
                dash_table.DataTable(
                    data=[{
                        'date': str(t['date']),
                        'type': t['type'],
                        'price': f"{t['price']:.2f}",
                        'shares': t['shares'],
                        'value': f"{t['value']:.2f}",
                        'capital': f"{t['capital']:.2f}"
                    } for t in trades],
                    columns=[
                        {'name': 'Date', 'id': 'date'},
                        {'name': 'Type', 'id': 'type'},
                        {'name': 'Price', 'id': 'price'},
                        {'name': 'Shares', 'id': 'shares'},
                        {'name': 'Value', 'id': 'value'},
                        {'name': 'Capital', 'id': 'capital'}
                    ],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{type} = "Buy"'},
                            'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                            'color': 'green'
                        },
                        {
                            'if': {'filter_query': '{type} = "Sell"'},
                            'backgroundColor': 'rgba(255, 0, 0, 0.1)',
                            'color': 'red'
                        }
                    ],
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    page_size=10
                )
            ])
        ])
        
        return metrics_cards, simulation_results
        
    except Exception as e:
        return html.Div([
            html.P(f"Error in backtesting analysis: {str(e)}", className="text-red-500"),
            html.Pre(traceback.format_exc(), className="text-xs bg-gray-100 p-2 rounded")
        ]), html.Div()










# BACKTESTING PROFIT

@app.callback(
    Output("backtesting-results", "children"),
    [Input("run-backtesting", "n_clicks")],
    [State("backtesting-title-dropdown", "value"),
     State("capital-input", "value"),
     State("analysis-dropdown", "value"),
     State("start-year-dropdown-backtesting", "value"),
     State("start-month-dropdown-backtesting", "value"),
     State("start-day-dropdown-backtesting", "value"),
     State("end-year-dropdown-backtesting", "value"),
     State("end-month-dropdown-backtesting", "value"),
     State("end-day-dropdown-backtesting", "value")]
)
def run_backtesting(n_clicks, title, capital, selected_analysis, start_year, start_month, start_day, end_year, end_month, end_day):
    # If button hasn't been clicked or inputs are incomplete
    if not n_clicks:
        raise dash.exceptions.PreventUpdate
    
    start_time = time.time()
    
    if not title or not capital:
        return html.Div("Please provide all inputs.", className="text-red-500")

    # Validate and format the date range
    try:
        start_date = pd.Timestamp(year=start_year, month=start_month, day=start_day)
        end_date = pd.Timestamp(year=end_year, month=end_month, day=end_day)
    except Exception as e:
        return html.Div(f"Invalid date range: {str(e)}", className="text-red-500")

    # Fetch raw ticker data
    try:
        df = fetch_ticker_data(title, start_date, end_date)
        
        if df.empty:
            return html.Div(f"No data found for the selected ticker: {title}.", className="text-gray-500")
            
        # Apply technical indicators to generate signals
        # Use selected_analysis to determine which indicators to apply
        indicators_to_apply = []
        if selected_analysis == 'Technical Analysis':
            indicators_to_apply = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
        elif selected_analysis == 'Moving Average':
            indicators_to_apply = ['MA_Signal']
        elif selected_analysis == 'RSI Analysis':
            indicators_to_apply = ['RSI_Signal']
        elif selected_analysis == 'MACD Analysis':
            indicators_to_apply = ['MACD_Signal']
        else:
            # Default to all indicators if analysis type isn't recognized
            indicators_to_apply = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
        
        # Apply the indicators to generate signals
        df_with_signals = apply_technical_indicators(df, indicators_to_apply)
        
        # Create analysis dataframe from signals
        analysis_df = pd.DataFrame()
        for indicator in indicators_to_apply:
            if indicator in df_with_signals.columns:
                indicator_data = []
                for idx, row in df_with_signals.iterrows():
                    if row[indicator] in ['Buy', 'Sell']:  # Only include Buy/Sell signals
                        indicator_data.append({
                            'Datetime': row['Datetime'],
                            'Price': row['Close'],
                            'Signal': row[indicator],
                            'Volume': row['Volume'],
                            'Analysis_info': indicator,
                            'Title': title
                        })
                
                if indicator_data:
                    indicator_df = pd.DataFrame(indicator_data)
                    analysis_df = pd.concat([analysis_df, indicator_df])

    except Exception as e:
        return html.Div(f"Error processing data: {str(e)}", className="text-red-500")

    # Sort data by date to ensure proper transaction order
    analysis_df = analysis_df.sort_values(by='Datetime').reset_index(drop=True)

    # Separate Buy and Sell signals
    buy_signals = analysis_df[analysis_df['Signal'] == 'Buy'].reset_index(drop=True)
    sell_signals = analysis_df[analysis_df['Signal'] == 'Sell'].reset_index(drop=True)

    # Initialize variables for the linear backtesting scenarios
    all_scenarios = []
    scenario_id = 1
    best_scenario = None
    max_final_capital = float('-inf')

    # Generate all possible linear scenarios
    # For each buy signal, try each sell signal that comes after it
    for buy_start_idx in range(len(buy_signals)):
        for sell_start_idx in range(len(sell_signals)):
            # Skip if the sell signal doesn't come after the buy signal
            if sell_signals.iloc[sell_start_idx]['Datetime'] <= buy_signals.iloc[buy_start_idx]['Datetime']:
                continue

            # Initialize scenario variables
            scenario_transactions = []
            current_capital = float(capital)
            current_position = None
            current_buy_idx = buy_start_idx
            current_sell_idx = sell_start_idx
            
            # Track dates to ensure we don't have multiple transactions on the same date
            transaction_dates = set()
            
            # Continue trading until we can't find more valid buy/sell pairs
            while current_buy_idx < len(buy_signals) and current_sell_idx < len(sell_signals):
                buy_signal = buy_signals.iloc[current_buy_idx]
                sell_signal = sell_signals.iloc[current_sell_idx]
                
                # Verify sell comes after buy
                if sell_signal['Datetime'] <= buy_signal['Datetime']:
                    # Find the next valid sell signal
                    found_valid_sell = False
                    for next_sell_idx in range(current_sell_idx + 1, len(sell_signals)):
                        if sell_signals.iloc[next_sell_idx]['Datetime'] > buy_signal['Datetime']:
                            current_sell_idx = next_sell_idx
                            found_valid_sell = True
                            break
                    
                    if not found_valid_sell:
                        break  # No more valid sell signals
                    
                    sell_signal = sell_signals.iloc[current_sell_idx]
                
                # Calculate transaction details for this trade
                buy_date = buy_signal['Datetime']
                buy_price = buy_signal['Price']
                sell_date = sell_signal['Datetime']
                sell_price = sell_signal['Price']
                
                # Skip if we've already traded on these dates
                if buy_date in transaction_dates or sell_date in transaction_dates:
                    # Try to find the next buy signal
                    current_buy_idx += 1
                    continue
                
                # Calculate shares and profit
                shares = int(current_capital // buy_price)
                if shares == 0:  # Not enough capital
                    break
                    
                investment = shares * buy_price
                proceeds = shares * sell_price
                profit = proceeds - investment
                percentage_profit = ((sell_price - buy_price) / buy_price) * 100
                
                # Update capital
                current_capital = current_capital - investment + proceeds
                
                # Add the transaction to our scenario
                transaction = {
                    'Buy Date': buy_date,
                    'Buy Price': buy_price,
                    'Sell Date': sell_date,
                    'Sell Price': sell_price,
                    'Shares': shares,
                    'Investment': investment,
                    'Proceeds': proceeds,
                    'Profit': profit,
                    'Percentage Profit': percentage_profit,
                    'Capital After Trade': current_capital
                }
                scenario_transactions.append(transaction)
                
                # Add dates to our set of transaction dates
                transaction_dates.add(buy_date)
                transaction_dates.add(sell_date)
                
                # Find the next buy signal that comes after this sell signal
                found_valid_buy = False
                for next_buy_idx in range(buy_start_idx, len(buy_signals)):
                    if buy_signals.iloc[next_buy_idx]['Datetime'] > sell_date:
                        current_buy_idx = next_buy_idx
                        found_valid_buy = True
                        break
                
                if not found_valid_buy:
                    break  # No more valid buy signals
            
            # Only include scenarios that had at least one transaction
            if not scenario_transactions:
                continue
                
            # Calculate scenario summary
            initial_capital = float(capital)
            final_capital = scenario_transactions[-1]['Capital After Trade']
            total_profit = final_capital - initial_capital
            total_percentage_profit = (total_profit / initial_capital) * 100
            total_trades = len(scenario_transactions)
            
            # Add a summary entry
            summary = {
                'Buy Date': "SUMMARY",
                'Buy Price': "",
                'Sell Date': "",
                'Sell Price': "",
                'Shares': "",
                'Investment': "",
                'Proceeds': "",
                'Profit': total_profit,
                'Percentage Profit': total_percentage_profit,
                'Capital After Trade': final_capital
            }
            scenario_transactions.append(summary)
            
            # Create the scenario object
            scenario = {
                'Scenario ID': scenario_id,
                'Transactions': scenario_transactions,
                'Initial Capital': initial_capital,
                'Final Capital': final_capital,
                'Total Profit': total_profit,
                'Total Percentage Profit': total_percentage_profit,
                'Number of Trades': total_trades
            }
            
            all_scenarios.append(scenario)
            scenario_id += 1
            
            # Update best scenario if needed
            if final_capital > max_final_capital:
                max_final_capital = final_capital
                best_scenario = scenario

    # Sort scenarios by profitability
    all_scenarios.sort(key=lambda x: x['Final Capital'], reverse=True)

    # Limit to top X scenarios for display purposes
    top_scenarios = all_scenarios[:10] if len(all_scenarios) > 10 else all_scenarios

    # Generate the output display
    scenario_components = []

    end_time = time.time()  # End time measurement
    execution_time = end_time - start_time

    # Add a summary of the best scenario
    if best_scenario:
        best_scenario_summary = html.Div([
            html.H2(f"Best Linear Scenario for {selected_analysis}", className="text-2xl font-bold mb-4 text-green-600"),
            html.Div([
                html.Div([
                    html.Span("Initial Capital: ", className="font-semibold"),
                    html.Span(f"{best_scenario['Initial Capital']:.2f}", className="ml-1")
                ], className="mb-2"),
                html.Div([
                    html.Span("Final Capital: ", className="font-semibold"),
                    html.Span(f"{best_scenario['Final Capital']:.2f}", className="ml-1 text-green-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Total Profit: ", className="font-semibold"),
                    html.Span(f"{best_scenario['Total Profit']:.2f}", className="ml-1 text-green-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Total Percentage Profit: ", className="font-semibold"),
                    html.Span(f"{best_scenario['Total Percentage Profit']:.2f}%", className="ml-1 text-blue-600")
                ], className="mb-2"),
                html.Div([
                    html.Span("Number of Trades: ", className="font-semibold"),
                    html.Span(str(best_scenario['Number of Trades']), className="ml-1")
                ], className="mb-2"),
                html.Div([
                    html.Span("Date Range: ", className="font-semibold"),
                    html.Span(f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", className="ml-1")
                ], className="mb-2"),
                html.Div([
                    html.Span("Execution Time: ", className="font-semibold"),
                    html.Span(f"{execution_time:.2f} seconds", className="ml-1 text-blue-600")
                ])
            ], className="p-4 bg-white rounded shadow-sm")
        ], className="mb-6")
        
        scenario_components.append(best_scenario_summary)

    # Add a table showing overall statistics for top scenarios
    top_scenario_stats = []
    for scenario in top_scenarios:
        top_scenario_stats.append({
            'Scenario ID': scenario['Scenario ID'],
            'Initial Capital': f"{scenario['Initial Capital']:.2f}",
            'Final Capital': f"{scenario['Final Capital']:.2f}",
            'Total Profit': f"{scenario['Total Profit']:.2f}",
            'Total % Profit': f"{scenario['Total Percentage Profit']:.2f}%",
            'Trades': scenario['Number of Trades']
        })

    if top_scenario_stats:
        top_scenarios_table = html.Div([
            html.H2("Top Performing Scenarios", className="text-xl font-bold mb-3"),
            dash_table.DataTable(
                data=top_scenario_stats,
                columns=[{'name': col, 'id': col} for col in top_scenario_stats[0].keys()],
                page_size=10,
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                style_data_conditional=[
                    {
                        'if': {'row_index': 0},
                        'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    }
                ]
            )
        ], className="mb-6")
        
        scenario_components.append(top_scenarios_table)

    # Generate detailed tables for each of the top scenarios
    for scenario in top_scenarios:
        scenario_id = scenario['Scenario ID']
        transactions = scenario['Transactions']
        
        # Create a table for this scenario
        table = dash_table.DataTable(
            data=transactions,
            columns=[{'name': col, 'id': col} for col in transactions[0].keys()],
            page_size=10,
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '10px'},
            style_header={
                'backgroundColor': 'rgb(240, 240, 240)',
                'fontWeight': 'bold'
            },
            style_data_conditional=[
                {
                    'if': {'filter_query': '{Buy Date} contains "SUMMARY"'},
                    'backgroundColor': 'rgba(0, 255, 0, 0.1)',
                    'fontWeight': 'bold'
                }
            ]
        )
        
        # Add the table to our components
        scenario_detail = html.Div([
            html.H3(f"Scenario {scenario_id} Details", className="text-lg font-semibold mb-3"),
            html.Div([
                html.Div([
                    html.Span("Initial Capital: ", className="font-semibold"),
                    html.Span(f"{scenario['Initial Capital']:.2f}", className="ml-1")
                ], className="mr-6"),
                html.Div([
                    html.Span("Final Capital: ", className="font-semibold"),
                    html.Span(f"{scenario['Final Capital']:.2f}", className="ml-1 text-green-600")
                ], className="mr-6"),
                html.Div([
                    html.Span("Total Profit: ", className="font-semibold"),
                    html.Span(f"{scenario['Total Profit']:.2f}", className="ml-1 text-green-600")
                ], className="mr-6"),
                html.Div([
                    html.Span("Total % Profit: ", className="font-semibold"),
                    html.Span(f"{scenario['Total Percentage Profit']:.2f}%", className="ml-1 text-blue-600")
                ]),
            ], className="flex mb-4"),
            table
        ], className="mb-6 p-4 bg-white rounded shadow-sm")
        
        scenario_components.append(scenario_detail)

    # If no scenarios were found
    if not scenario_components:
        return html.Div("No valid trading scenarios found for the given parameters.", className="text-red-500")

    # Return all scenario components
    return html.Div([
        html.H1("Backtesting Results", className="text-2xl font-bold mb-6"),
        html.Div(f"Total scenarios evaluated: {len(all_scenarios)}", className="mb-4"),
        html.Div(scenario_components)
    ])









# BACKTESTING ANALYSIS

@app.callback(
    Output("analysis-results", "children"),
    [Input("run-analysis", "n_clicks")],
    [State("backtesting-title-dropdown-analysis", "value"),
     State("capital-input-analysis", "value"),
     State("analysis-dropdown-analysis", "value"),
     State("start-year-dropdown-analysis", "value"),
     State("start-month-dropdown-analysis", "value"),
     State("start-day-dropdown-analysis", "value"),
     State("end-year-dropdown-analysis", "value"),
     State("end-month-dropdown-analysis", "value"),
     State("end-day-dropdown-analysis", "value"),
     State("signal-filter-analysis", "value"),
     State("indicator-selection", "value")]  # New state for indicator selection
)
def run_backtest_analysis(n_clicks, title, capital, selected_analysis, 
                       start_year, start_month, start_day,
                       end_year, end_month, end_day,
                       signal_filter, selected_indicators):
    if not n_clicks:
        raise dash.exceptions.PreventUpdate
        
    if not all([title, capital]):
        return html.Div("Please provide all required inputs.", className="text-red-500")

    try:
        # Convert date inputs to datetime objects
        start_date = pd.Timestamp(year=start_year, month=start_month, day=start_day)
        end_date = pd.Timestamp(year=end_year, month=end_month, day=end_day)
        
        # Fetch ticker data
        df = fetch_ticker_data(title, start_date, end_date)
        
        if df.empty:
            return html.Div("No data available for selected criteria.", className="text-red-500")
            
        # Apply technical indicators based on the raw data
        if not selected_indicators or len(selected_indicators) == 0:
            # Default indicators if none selected
            selected_indicators = ['Bollinger_Signal', 'MA_Signal', 'RSI_Signal', 'MACD_Signal']
        
        # Apply technical indicators to generate signals
        df_with_signals = apply_technical_indicators(df, selected_indicators)
        
        # Create a new dataframe that mimics the structure expected by the analysis code
        analysis_df = pd.DataFrame()
        
        # Convert each signal column to rows in the analysis dataframe
        for indicator in selected_indicators:
            if indicator in df_with_signals.columns:
                indicator_data = []
                for idx, row in df_with_signals.iterrows():
                    if row[indicator] in ['Buy', 'Sell']:  # Only include Buy/Sell signals
                        indicator_data.append({
                            'Datetime': row['Datetime'],
                            'Price': row['Close'],
                            'Signal': row[indicator],
                            'Volume': row['Volume'],
                            'Analysis_info': indicator,
                            'Title': title
                        })
                
                if indicator_data:
                    indicator_df = pd.DataFrame(indicator_data)
                    analysis_df = pd.concat([analysis_df, indicator_df])
        
        if analysis_df.empty:
            return html.Div("No trading signals were generated for the selected period.", 
                          className="text-center text-red-500 p-4")
        
        # Sort by datetime
        analysis_df = analysis_df.sort_values('Datetime')
        
        # Group results by indicator analysis
        all_results = []  # To store results for all tested strategies
        combination_results = []  # To store results for combination strategies
        
        # Test individual indicators
        for indicator in selected_indicators:
            indicator_df = analysis_df[analysis_df['Analysis_info'] == indicator]
            
            if indicator_df.empty:
                continue
            
            # Get buy and sell signals
            buy_signals = indicator_df[indicator_df['Signal'] == 'Buy']
            sell_signals = indicator_df[indicator_df['Signal'] == 'Sell']
            
            if len(buy_signals) == 0 or len(sell_signals) == 0:
                continue
                
            # Test different combinations of buy/sell signals
            for buy_idx in range(min(3, len(buy_signals))):  # Test up to first 3 buy signals
                for sell_idx in range(min(3, len(sell_signals))):  # Test up to first 3 sell signals
                    strategy_name = f"{indicator} (Buy {buy_idx+1}, Sell {sell_idx+1})"
                    
                    # Reset for this test
                    initial_capital = float(capital)
                    current_capital = initial_capital
                    position = None
                    trades = []
                    
                    # Get signals for this test
                    test_buys = buy_signals.iloc[buy_idx::3]  # Take every 3rd buy signal starting from the selected index
                    test_sells = sell_signals.iloc[sell_idx::3]  # Take every 3rd sell signal starting from the selected index
                    
                    # Combine and sort signals by datetime
                    test_signals = pd.concat([
                        test_buys[['Datetime', 'Price', 'Signal', 'Volume']],
                        test_sells[['Datetime', 'Price', 'Signal', 'Volume']]
                    ]).sort_values('Datetime')
                    
                    # Run backtest simulation
                    for idx, row in test_signals.iterrows():
                        if position is None and row['Signal'] == 'Buy':
                            # Open position
                            shares = int(current_capital // row['Price'])
                            if shares > 0:
                                position = {
                                    'entry_date': row['Datetime'],
                                    'entry_price': row['Price'],
                                    'entry_volume': row['Volume'],
                                    'shares': shares,
                                    'cost': shares * row['Price'],
                                    'indicator': indicator
                                }
                                current_capital -= position['cost']
                                
                        elif position is not None and row['Signal'] == 'Sell':
                            # Close position
                            proceeds = position['shares'] * row['Price']
                            profit = proceeds - position['cost']
                            
                            # Calculate price and volume changes
                            price_change_pct = ((row['Price'] - position['entry_price']) / position['entry_price']) * 100
                            volume_change_pct = ((row['Volume'] - position['entry_volume']) / position['entry_volume']) * 100 if position['entry_volume'] > 0 else 0
                            
                            trades.append({
                                'Entry Date': position['entry_date'],
                                'Entry Price': position['entry_price'],
                                'Entry Volume': position['entry_volume'],
                                'Exit Date': row['Datetime'],
                                'Exit Price': row['Price'],
                                'Exit Volume': row['Volume'],
                                'Shares': position['shares'],
                                'Profit/Loss': profit,
                                'Return %': (profit / position['cost']) * 100,
                                'Price Change %': price_change_pct,
                                'Volume Change %': volume_change_pct,
                                'Indicator': position['indicator']
                            })
                            current_capital += proceeds
                            position = None
                    
                    # Calculate metrics for this strategy
                    total_trades = len(trades)
                    if total_trades > 0:
                        winning_trades = len([t for t in trades if t['Profit/Loss'] > 0])
                        total_profit = sum(t['Profit/Loss'] for t in trades)
                        profit_percentage = ((current_capital - initial_capital) / initial_capital) * 100
                        avg_price_change = sum(t['Price Change %'] for t in trades) / total_trades
                        avg_volume_change = sum(t['Volume Change %'] for t in trades) / total_trades
                        
                        # Add to results
                        all_results.append({
                            'Strategy': strategy_name,
                            'Initial Capital': initial_capital,
                            'Final Capital': current_capital,
                            'Total Profit/Loss': total_profit,
                            'Return %': profit_percentage,
                            'Total Trades': total_trades,
                            'Win Rate': (winning_trades/total_trades*100) if total_trades > 0 else 0,
                            'Avg Price Change %': avg_price_change,
                            'Avg Volume Change %': avg_volume_change,
                            'Trades': trades
                        })
        
        # Test combinations of indicators (if multiple indicators were selected)
        if len(selected_indicators) > 1:
            for buy_indicator in selected_indicators:
                for sell_indicator in selected_indicators:
                    if buy_indicator == sell_indicator:
                        continue  # Skip same indicator combinations as they were already tested
                        
                    # Get buy signals from first indicator
                    buy_df = analysis_df[(analysis_df['Analysis_info'] == buy_indicator) & 
                                         (analysis_df['Signal'] == 'Buy')]
                    
                    # Get sell signals from second indicator
                    sell_df = analysis_df[(analysis_df['Analysis_info'] == sell_indicator) & 
                                          (analysis_df['Signal'] == 'Sell')]
                    
                    if buy_df.empty or sell_df.empty:
                        continue
                        
                    # Sort by datetime
                    buy_df = buy_df.sort_values('Datetime')
                    sell_df = sell_df.sort_values('Datetime')
                    
                    # Test combinations of first few signals
                    for buy_idx in range(min(2, len(buy_df))):  # First 2 buy signals
                        for sell_idx in range(min(2, len(sell_df))):  # First 2 sell signals
                            combo_name = f"{buy_indicator} (Buy {buy_idx+1}) + {sell_indicator} (Sell {sell_idx+1})"
                            
                            # Reset for this test
                            initial_capital = float(capital)
                            current_capital = initial_capital
                            position = None
                            trades = []
                            
                            # Get signals for this test
                            test_buys = buy_df.iloc[buy_idx::2]  # Every 2nd buy signal from selected index
                            test_sells = sell_df.iloc[sell_idx::2]  # Every 2nd sell signal from selected index
                            
                            # Combine and sort signals by datetime
                            test_signals = pd.concat([
                                test_buys[['Datetime', 'Price', 'Signal', 'Volume', 'Analysis_info']],
                                test_sells[['Datetime', 'Price', 'Signal', 'Volume', 'Analysis_info']]
                            ]).sort_values('Datetime')
                            
                            # Run backtest simulation
                            for idx, row in test_signals.iterrows():
                                if position is None and row['Signal'] == 'Buy' and row['Analysis_info'] == buy_indicator:
                                    # Open position
                                    shares = int(current_capital // row['Price'])
                                    if shares > 0:
                                        position = {
                                            'entry_date': row['Datetime'],
                                            'entry_price': row['Price'],
                                            'entry_volume': row['Volume'],
                                            'shares': shares,
                                            'cost': shares * row['Price'],
                                            'buy_indicator': row['Analysis_info']
                                        }
                                        current_capital -= position['cost']
                                        
                                elif position is not None and row['Signal'] == 'Sell' and row['Analysis_info'] == sell_indicator:
                                    # Close position
                                    proceeds = position['shares'] * row['Price']
                                    profit = proceeds - position['cost']
                                    
                                    # Calculate price and volume changes
                                    price_change_pct = ((row['Price'] - position['entry_price']) / position['entry_price']) * 100
                                    volume_change_pct = ((row['Volume'] - position['entry_volume']) / position['entry_volume']) * 100 if position['entry_volume'] > 0 else 0
                                    
                                    trades.append({
                                        'Entry Date': position['entry_date'],
                                        'Entry Price': position['entry_price'],
                                        'Entry Volume': position['entry_volume'],
                                        'Exit Date': row['Datetime'],
                                        'Exit Price': row['Price'],
                                        'Exit Volume': row['Volume'],
                                        'Shares': position['shares'],
                                        'Profit/Loss': profit,
                                        'Return %': (profit / position['cost']) * 100,
                                        'Price Change %': price_change_pct,
                                        'Volume Change %': volume_change_pct,
                                        'Buy Indicator': position['buy_indicator'],
                                        'Sell Indicator': row['Analysis_info']
                                    })
                                    current_capital += proceeds
                                    position = None
                            
                            # Calculate metrics for this combination
                            total_trades = len(trades)
                            if total_trades > 0:
                                winning_trades = len([t for t in trades if t['Profit/Loss'] > 0])
                                total_profit = sum(t['Profit/Loss'] for t in trades)
                                profit_percentage = ((current_capital - initial_capital) / initial_capital) * 100
                                avg_price_change = sum(t['Price Change %'] for t in trades) / total_trades
                                avg_volume_change = sum(t['Volume Change %'] for t in trades) / total_trades
                                
                                # Add to combination results
                                combination_results.append({
                                    'Strategy': combo_name,
                                    'Initial Capital': initial_capital,
                                    'Final Capital': current_capital,
                                    'Total Profit/Loss': total_profit,
                                    'Return %': profit_percentage,
                                    'Total Trades': total_trades,
                                    'Win Rate': (winning_trades/total_trades*100) if total_trades > 0 else 0,
                                    'Avg Price Change %': avg_price_change,
                                    'Avg Volume Change %': avg_volume_change,
                                    'Trades': trades
                                })
        
        # Sort results by profitability (Return %)
        all_results = sorted(all_results, key=lambda x: x['Return %'], reverse=True)
        combination_results = sorted(combination_results, key=lambda x: x['Return %'], reverse=True)
        
        # Create analysis summary components
        components = []

        # Add overall best strategy section
        all_strategies = all_results + combination_results
        if all_strategies:
            best_strategy = max(all_strategies, key=lambda x: x['Return %'])
            components.append(html.Div([
                html.H3("Best Performing Strategy", className="text-xl font-bold mb-2 text-green-700"),
                html.Div([
                    html.Div([
                        html.Span("Strategy: ", className="font-semibold"),
                        html.Span(best_strategy['Strategy'], className="ml-1")
                    ], className="mb-1"),
                    html.Div([
                        html.Span("Return: ", className="font-semibold"),
                        html.Span(f"{best_strategy['Return %']:.2f}%", 
                                className=f"ml-1 {'text-green-600' if best_strategy['Return %'] >= 0 else 'text-red-600'}")
                    ], className="mb-1"),
                    html.Div([
                        html.Span("Total Profit: ", className="font-semibold"),
                        html.Span(f"{best_strategy['Total Profit/Loss']:,.2f}", 
                                className=f"ml-1 {'text-green-600' if best_strategy['Total Profit/Loss'] >= 0 else 'text-red-600'}")
                    ], className="mb-1"),
                    html.Div([
                        html.Span("Win Rate: ", className="font-semibold"),
                        html.Span(f"{best_strategy['Win Rate']:.2f}%", className="ml-1")
                    ], className="mb-1"),
                ], className="p-3 bg-green-50 rounded border border-green-200 mb-4")
            ]))
        
        # Add individual indicator analysis section
        if all_results:
            components.append(html.H3("Individual Indicator Analysis", className="text-xl font-bold mt-4 mb-3"))
            
            # Create a table for individual indicator results
            indicator_table = dash_table.DataTable(
                data=[{
                    'Strategy': r['Strategy'],
                    'Return %': f"{r['Return %']:.2f}%",
                    'Total Profit/Loss': f"{r['Total Profit/Loss']:,.2f}",
                    'Win Rate': f"{r['Win Rate']:.2f}%",
                    'Avg Price Change %': f"{r['Avg Price Change %']:.2f}%",
                    'Avg Volume Change %': f"{r['Avg Volume Change %']:.2f}%",
                    'Total Trades': r['Total Trades']
                } for r in all_results],
                columns=[
                    {'name': 'Strategy', 'id': 'Strategy'},
                    {'name': 'Return %', 'id': 'Return %'},
                    {'name': 'Total Profit/Loss', 'id': 'Total Profit/Loss'},
                    {'name': 'Win Rate', 'id': 'Win Rate'},
                    {'name': 'Avg Price Change %', 'id': 'Avg Price Change %'},
                    {'name': 'Avg Volume Change %', 'id': 'Avg Volume Change %'},
                    {'name': 'Total Trades', 'id': 'Total Trades'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Return %} contains "-"'},
                        'color': 'red'
                    },
                    {
                        'if': {'filter_query': '{Return %} contains "%"', 'column_id': 'Return %'},
                        'color': 'green'
                    }
                ],
                sort_action='native',
                page_size=5
            )
            components.append(indicator_table)
            
            # Add indicator insights
            if len(all_results) > 0:
                best_indicator = all_results[0]
                components.append(html.Div([
                    html.H4("Indicator Insights", className="text-lg font-semibold mt-4 mb-2"),
                    html.P([
                        f"The best individual indicator strategy was ",
                        html.Strong(best_indicator['Strategy']),
                        f", which produced a return of ",
                        html.Strong(f"{best_indicator['Return %']:.2f}%"),
                        f". This strategy had an average price change of ",
                        html.Strong(f"{best_indicator['Avg Price Change %']:.2f}%"),
                        f" and average volume change of ",
                        html.Strong(f"{best_indicator['Avg Volume Change %']:.2f}%"),
                        f" between entry and exit points."
                    ], className="mb-2"),
                    html.P([
                        "The strategy's performance was ",
                        html.Strong("primarily driven by price movements") if abs(best_indicator['Avg Price Change %']) > abs(best_indicator['Avg Volume Change %']) else html.Strong("significantly influenced by volume changes"),
                        "."
                    ], className="mb-2")
                ], className="mt-3 mb-4"))
        
        # Add combination strategy analysis section (rest of function continues as before)
        if combination_results:
            components.append(html.H3("Combination Strategy Analysis", className="text-xl font-bold mt-5 mb-3"))
            
            # Create a table for combination results
            combo_table = dash_table.DataTable(
                data=[{
                    'Strategy': r['Strategy'],
                    'Return %': f"{r['Return %']:.2f}%",
                    'Total Profit/Loss': f"{r['Total Profit/Loss']:,.2f}",
                    'Win Rate': f"{r['Win Rate']:.2f}%",
                    'Avg Price Change %': f"{r['Avg Price Change %']:.2f}%",
                    'Avg Volume Change %': f"{r['Avg Volume Change %']:.2f}%",
                    'Total Trades': r['Total Trades']
                } for r in combination_results],
                columns=[
                    {'name': 'Strategy', 'id': 'Strategy'},
                    {'name': 'Return %', 'id': 'Return %'},
                    {'name': 'Total Profit/Loss', 'id': 'Total Profit/Loss'},
                    {'name': 'Win Rate', 'id': 'Win Rate'},
                    {'name': 'Avg Price Change %', 'id': 'Avg Price Change %'},
                    {'name': 'Avg Volume Change %', 'id': 'Avg Volume Change %'},
                    {'name': 'Total Trades', 'id': 'Total Trades'}
                ],
                style_table={'overflowX': 'auto'},
                style_cell={'textAlign': 'left', 'padding': '10px'},
                style_header={
                    'backgroundColor': 'rgb(240, 240, 240)',
                    'fontWeight': 'bold'
                },
                style_data_conditional=[
                    {
                        'if': {'filter_query': '{Return %} contains "-"'},
                        'color': 'red'
                    },
                    {
                        'if': {'filter_query': '{Return %} contains "%"', 'column_id': 'Return %'},
                        'color': 'green'
                    }
                ],
                sort_action='native',
                page_size=5
            )
            components.append(combo_table)
            
            # Add combination insights
            if len(combination_results) > 0:
                best_combo = combination_results[0]
                components.append(html.Div([
                    html.H4("Combination Strategy Insights", className="text-lg font-semibold mt-4 mb-2"),
                    html.P([
                        f"The best combination strategy was ",
                        html.Strong(best_combo['Strategy']),
                        f", which produced a return of ",
                        html.Strong(f"{best_combo['Return %']:.2f}%"),
                        f". "
                    ], className="mb-2"),
                    
                    # Compare with best individual indicator
                    html.P([
                        "Compared to the best individual indicator strategy (",
                        html.Strong(all_results[0]['Strategy'] if all_results else "N/A"),
                        f"), this combination ",
                        html.Strong("performed better") if best_combo['Return %'] > all_results[0]['Return %'] else html.Strong("performed worse"),
                        f" by ",
                        html.Strong(f"{abs(best_combo['Return %'] - all_results[0]['Return %']):.2f}%"),
                        "."
                    ], className="mb-2")
                ], className="mt-3 mb-4"))
        
        # Add overall conclusion section
        if all_strategies:
            best_strategy = max(all_strategies, key=lambda x: x['Return %'])
            components.append(html.Div([
                html.H3("Analysis Conclusion", className="text-xl font-bold mt-5 mb-3"),
                html.Div([
                    html.P([
                        "Based on backtesting results, ",
                        html.Strong(best_strategy['Strategy']),
                        " is the most profitable strategy for this dataset in the selected timeframe."
                    ], className="mb-2"),
                    
                    html.P([
                        "The analysis suggests that ",
                        html.Strong("indicator combinations outperformed individual indicators") 
                            if combination_results and combination_results[0]['Return %'] > all_results[0]['Return %'] 
                            else html.Strong("individual indicators performed better than combinations"),
                        " for this particular dataset."
                    ], className="mb-2"),
                    
                    html.P([
                        "Trade performance was ",
                        html.Strong("more influenced by price movements") 
                            if best_strategy['Avg Price Change %'] > best_strategy['Avg Volume Change %'] 
                            else html.Strong("more influenced by volume changes"),
                        ", suggesting that ",
                        "price-based signals were more reliable indicators" 
                            if best_strategy['Avg Price Change %'] > best_strategy['Avg Volume Change %'] 
                            else "volume changes played a significant role in trade outcomes",
                        "."
                    ], className="mb-2"),
                ], className="p-4 bg-blue-50 rounded border border-blue-200")
            ]))
        
        # Show detailed trades for the best strategy
        if all_strategies:
            best_strategy = max(all_strategies, key=lambda x: x['Return %'])
            if best_strategy['Trades']:
                components.append(html.H3("Trade Details for Best Strategy", className="text-xl font-bold mt-5 mb-3"))
                
                trades_table_data = []
                for i, trade in enumerate(best_strategy['Trades']):
                    # Format trade data for display
                    trade_data = {
                        'Trade #': i + 1,
                        'Entry Date': trade['Entry Date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['Entry Date'], 'strftime') else str(trade['Entry Date']),
                        'Entry Price': f"{trade['Entry Price']:.2f}",
                        'Exit Date': trade['Exit Date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['Exit Date'], 'strftime') else str(trade['Exit Date']),
                        'Exit Price': f"{trade['Exit Price']:.2f}",
                        'Profit/Loss': f"{trade['Profit/Loss']:.2f}",
                        'Return %': f"{trade['Return %']:.2f}%",
                        'Price Change %': f"{trade['Price Change %']:.2f}%",
                        'Volume Change %': f"{trade['Volume Change %']:.2f}%"
                    }
                    trades_table_data.append(trade_data)
                
                trades_table = dash_table.DataTable(
                    data=trades_table_data,
                    columns=[{'name': col, 'id': col} for col in trades_table_data[0].keys()],
                    style_table={'overflowX': 'auto'},
                    style_cell={'textAlign': 'left', 'padding': '10px'},
                    style_header={
                        'backgroundColor': 'rgb(240, 240, 240)',
                        'fontWeight': 'bold'
                    },
                    style_data_conditional=[
                        {
                            'if': {'filter_query': '{Profit/Loss} contains "-"'},
                            'color': 'red'
                        },
                        {
                            'if': {'filter_query': '{Profit/Loss} contains "."', 'column_id': 'Profit/Loss'},
                            'color': 'green'
                        }
                    ],
                    page_size=5
                )
                components.append(trades_table)
                
        # Add detailed trades section for all scenarios
        components.append(html.Div([
            html.H3("All Trading Scenarios Details", className="text-xl font-bold mt-5 mb-3"),
            
            # Create tabs for different views
            dcc.Tabs([
                dcc.Tab(label="Individual Indicator Trades", children=[
                    html.Div([
                        html.H4(f"Trades for {result['Strategy']}", className="text-lg font-semibold mt-4 mb-2"),
                        dash_table.DataTable(
                            data=[{
                                'Entry Date': trade['Entry Date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['Entry Date'], 'strftime') else str(trade['Entry Date']),
                                'Entry Price': f"{trade['Entry Price']:.2f}",
                                'Exit Date': trade['Exit Date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['Exit Date'], 'strftime') else str(trade['Exit Date']),
                                'Exit Price': f"{trade['Exit Price']:.2f}",
                                'Shares': trade['Shares'],
                                'Profit/Loss': f"{trade['Profit/Loss']:.2f}",
                                'Return %': f"{trade['Return %']:.2f}%",
                                'Price Change %': f"{trade['Price Change %']:.2f}%",
                                'Volume Change %': f"{trade['Volume Change %']:.2f}%"
                            } for trade in result['Trades']],
                            columns=[
                                {'name': col, 'id': col} for col in [
                                    'Entry Date', 'Entry Price', 'Exit Date', 'Exit Price',
                                    'Shares', 'Profit/Loss', 'Return %', 'Price Change %',
                                    'Volume Change %'
                                ]
                            ],
                            style_table={'overflowX': 'auto'},
                            style_cell={'textAlign': 'left', 'padding': '10px'},
                            style_header={
                                'backgroundColor': 'rgb(240, 240, 240)',
                                'fontWeight': 'bold'
                            },
                            style_data_conditional=[
                                {
                                    'if': {'filter_query': '{Profit/Loss} contains "-"'},
                                    'color': 'red'
                                },
                                {
                                    'if': {'filter_query': '{Profit/Loss} > "0.00"'},
                                    'color': 'green'
                                }
                            ],
                            sort_action='native',
                            page_size=10
                        )
                    ]) for result in all_results
                ]),

                dcc.Tab(label="Combination Strategy Trades", children=[
                    html.Div([
                        html.H4(f"Trades for {combo['Strategy']}", className="text-lg font-semibold mt-4 mb-2"),
                        dash_table.DataTable(
                            data=[{
                                'Entry Date': trade['Entry Date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['Entry Date'], 'strftime') else str(trade['Entry Date']),
                                'Entry Price': f"{trade['Entry Price']:.2f}",
                                'Exit Date': trade['Exit Date'].strftime('%Y-%m-%d %H:%M') if hasattr(trade['Exit Date'], 'strftime') else str(trade['Exit Date']),
                                'Exit Price': f"{trade['Exit Price']:.2f}",
                                'Shares': trade['Shares'],
                                'Profit/Loss': f"{trade['Profit/Loss']:.2f}",
                                'Return %': f"{trade['Return %']:.2f}%",
                                'Buy Indicator': trade.get('Buy Indicator', ''),
                                'Sell Indicator': trade.get('Sell Indicator', '')
                            } for trade in combo['Trades']],
                            columns=[
                                {'name': col, 'id': col} for col in [
                                    'Entry Date', 'Entry Price', 'Exit Date', 'Exit Price',
                                    'Shares', 'Profit/Loss', 'Return %', 'Buy Indicator',
                                    'Sell Indicator'
                                ]
                            ],
                            style_table={'overflowX': 'auto'},
                            style_cell={'textAlign': 'left', 'padding': '10px'},
                            style_header={
                                'backgroundColor': 'rgb(240, 240, 240)',
                                'fontWeight': 'bold'
                            },
                            style_data_conditional=[
                                {
                                    'if': {'filter_query': '{Profit/Loss} contains "-"'},
                                    'color': 'red'
                                },
                                {
                                    'if': {'filter_query': '{Profit/Loss} > "0.00"'},
                                    'color': 'green'
                                }
                            ],
                            sort_action='native',
                            page_size=10
                        )
                    ]) for combo in combination_results
                ])
            ])
        ], className="mt-6 mb-6 p-4 bg-white rounded shadow-sm"))
        
        return html.Div(components)

    except Exception as e:
        return html.Div([
            html.H3("Error", className="text-xl font-bold text-red-600 mb-2"),
            html.P(f"An error occurred during analysis: {str(e)}", className="text-red-500"),
            html.Pre(traceback.format_exc(), className="bg-gray-100 p-4 rounded text-sm mt-2")
        ])
